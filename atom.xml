<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Happy Coding, Happy Life]]></title>
  <link href="http://wldandan.github.com/atom.xml" rel="self"/>
  <link href="http://wldandan.github.com/"/>
  <updated>2019-04-06T12:37:26+08:00</updated>
  <id>http://wldandan.github.com/</id>
  <author>
    <name><![CDATA[wldandan]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[K8s之Volume]]></title>
    <link href="http://wldandan.github.com/blog/2019/04/05/k8s-concept-volume/"/>
    <updated>2019-04-05T21:04:00+08:00</updated>
    <id>http://wldandan.github.com/blog/2019/04/05/k8s-concept-volume</id>
    <content type="html"><![CDATA[<p>本篇文章主要介绍在K8S中，pod的容器如何访问外部磁盘存储，以及容器间如何实现共享存储，主要内容包括</p>

<ul>
<li>通过volume和emptyDir在容器中共享数据</li>
<li>在Pod中使用Git Repo</li>
<li>使用外部存储，如GCE</li>
<li>使用PV(PersistentVolume)和PVC(PersistentVolumeClaim)</li>
</ul>


<!--More-->


<h4>一. 使用emptyDir</h4>

<p>最简单的卷类型是emptyDir。顾名思义，emptyDir是从空目录开始。在pod中运行的应用程序可以向它写入任何文件。因为emptyDir卷的生命周期与pod的生命周期相关联，所以当pod被删除时，卷的内容会丢失。</p>

<p>emptyDir卷对于在同一个pod中运行的容器间共享文件特别有用。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='yaml'><span class='line'><span class="l-Scalar-Plain">apiVersion</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">v1</span>
</span><span class='line'><span class="l-Scalar-Plain">kind</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">Pod</span>
</span><span class='line'><span class="l-Scalar-Plain">metadata</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">fortune</span>
</span><span class='line'><span class="l-Scalar-Plain">spec</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="l-Scalar-Plain">containers</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">image</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">luksa/fortune                   1</span>
</span><span class='line'>    <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">html-generator                   1</span>
</span><span class='line'>    <span class="l-Scalar-Plain">volumeMounts</span><span class="p-Indicator">:</span>                          <span class="l-Scalar-Plain">2</span>
</span><span class='line'>    <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">html                           2</span>
</span><span class='line'>      <span class="l-Scalar-Plain">mountPath</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">/var/htdocs               2</span>
</span><span class='line'>  <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">image</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">nginx:alpine                    3</span>
</span><span class='line'>    <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">web-server                       3</span>
</span><span class='line'>    <span class="l-Scalar-Plain">volumeMounts</span><span class="p-Indicator">:</span>                          <span class="l-Scalar-Plain">4</span>
</span><span class='line'>    <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">html                           4</span>
</span><span class='line'>      <span class="l-Scalar-Plain">mountPath</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">/usr/share/nginx/html     4</span>
</span><span class='line'>      <span class="l-Scalar-Plain">readOnly</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">true                       4</span>
</span><span class='line'>    <span class="l-Scalar-Plain">ports</span><span class="p-Indicator">:</span>
</span><span class='line'>    <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">containerPort</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">80</span>
</span><span class='line'>      <span class="l-Scalar-Plain">protocol</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">TCP</span>
</span><span class='line'>  <span class="l-Scalar-Plain">volumes</span><span class="p-Indicator">:</span>                                 <span class="l-Scalar-Plain">5</span>
</span><span class='line'>  <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">html                             5</span>
</span><span class='line'>    <span class="l-Scalar-Plain">emptyDir</span><span class="p-Indicator">:</span> <span class="p-Indicator">{}</span>                           <span class="l-Scalar-Plain">5</span>
</span></code></pre></td></tr></table></div></figure>


<blockquote><ol>
<li>第1个容器名为<code>html-generator</code>，其镜像为<code>luksa/fortune</code></li>
<li>volume的名称是<code>html</code>，其在容器中的路径为<code>/var/htdocs</code></li>
<li>第2个容器为<code>web-server</code>，镜像为<code>nginx:alpine</code></li>
<li>第2个容器使用的卷为<code>html</code>，加载到<code>/usr/share/nginx/html</code></li>
<li>volume名称为<code>name</code>，emptyDir初始为为空</li>
</ol>
</blockquote>

<p>默认情况下，emptyDir使用Node的磁盘，但是你也可以使用内存，类似如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='yaml'><span class='line'><span class="l-Scalar-Plain">volumes</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">html</span>
</span><span class='line'>    <span class="l-Scalar-Plain">emptyDir</span><span class="p-Indicator">:</span>
</span><span class='line'>      <span class="l-Scalar-Plain">medium</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">Memory</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<h4>二. 使用Git Repo</h4>

<p>Git Repo卷基本上是基于emptyDir，通过克隆Git仓库并在pod启动时（但在创建其容器之前）签出特定版本填充该卷。如图6.3所示:</p>

<p><img src="http://wldandan.github.com/images/k8s/k8s-volume-gitrepo.png" /></p>

<p>示例代码如下所示：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='yaml'><span class='line'><span class="l-Scalar-Plain">apiVersion</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">v1</span>
</span><span class='line'><span class="l-Scalar-Plain">kind</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">Pod</span>
</span><span class='line'><span class="l-Scalar-Plain">metadata</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">gitrepo-volume-pod</span>
</span><span class='line'><span class="l-Scalar-Plain">spec</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="l-Scalar-Plain">containers</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">image</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">nginx:alpine</span>
</span><span class='line'>    <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">web-server</span>
</span><span class='line'>    <span class="l-Scalar-Plain">volumeMounts</span><span class="p-Indicator">:</span>
</span><span class='line'>    <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">html</span>
</span><span class='line'>      <span class="l-Scalar-Plain">mountPath</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">/usr/share/nginx/html</span>
</span><span class='line'>      <span class="l-Scalar-Plain">readOnly</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">true</span>
</span><span class='line'>    <span class="l-Scalar-Plain">ports</span><span class="p-Indicator">:</span>
</span><span class='line'>    <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">containerPort</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">80</span>
</span><span class='line'>      <span class="l-Scalar-Plain">protocol</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">TCP</span>
</span><span class='line'>  <span class="l-Scalar-Plain">volumes</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">html</span>
</span><span class='line'>    <span class="l-Scalar-Plain">gitRepo</span><span class="p-Indicator">:</span>
</span><span class='line'>      <span class="l-Scalar-Plain">repository</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">https://github.com/luksa/kubia-website-example.git</span>
</span><span class='line'>      <span class="l-Scalar-Plain">revision</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">master</span>
</span><span class='line'>      <span class="l-Scalar-Plain">directory</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">.</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意，默认情况下，使用gitrepo卷时存在一个缺点，它不会与所引用的git repo保持同步。只有当pod重启或者创建一个新的pod，才会获取最新的提交。</p>

<blockquote><p>可以使用其他容器来实现文件的同步，更多细节可以在dokerhub上搜索“git sync.”</p></blockquote>

<h4>三. 使用hostPath</h4>

<p>hostPath是一种持久性存储，它指向Node文件系统上的目录（如图）。运行在同一节点上的Pod，如果使用相同的hostPath卷，则可以彼此看到相同的文件。</p>

<p><img src="http://wldandan.github.com/images/k8s/k8s-volume-hostpath.png" /></p>

<p>使用hostPath的方式如下所示：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='yaml'><span class='line'><span class="l-Scalar-Plain">Volumes</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="l-Scalar-Plain">varlog</span><span class="p-Indicator">:</span>
</span><span class='line'>    <span class="l-Scalar-Plain">Type</span><span class="p-Indicator">:</span>       <span class="l-Scalar-Plain">HostPath (bare host directory volume)</span>
</span><span class='line'>    <span class="l-Scalar-Plain">Path</span><span class="p-Indicator">:</span>       <span class="l-Scalar-Plain">/var/log</span>
</span><span class='line'>  <span class="l-Scalar-Plain">varlibdockercontainers</span><span class="p-Indicator">:</span>
</span><span class='line'>    <span class="l-Scalar-Plain">Type</span><span class="p-Indicator">:</span>       <span class="l-Scalar-Plain">HostPath (bare host directory volume)</span>
</span><span class='line'>    <span class="l-Scalar-Plain">Path</span><span class="p-Indicator">:</span>       <span class="l-Scalar-Plain">/var/lib/docker/containers</span>
</span></code></pre></td></tr></table></div></figure>


<p>当一个pod被删除时，gitrepo和emptydir卷的内容都会被删除，但hostPath卷的内容不会。当pod被删除时，运行在该Node上新的pod，如果有相同路径的hostPath卷，它将能访问到之前Pod写入的数据。</p>

<p>如果您考虑使用hostPath作为数据库数据目录的话，请谨慎考虑。因为卷的内容存储在特定Node的文件系统中，当数据库pod被重新调度到另一个节点时，它将无法看到数据。</p>

<h4>四. 使用网络文件存储</h4>

<p>对于网络存储而言，可以使用GCE Persistent Disk、AWS Elastic BlockStore、Azure File、Azure Disk。</p>

<p>譬如，使用GCE Persisteng Disk的方式如下所示：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='yaml'><span class='line'><span class="l-Scalar-Plain">apiVersion</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">v1</span>
</span><span class='line'><span class="l-Scalar-Plain">kind</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">Pod</span>
</span><span class='line'><span class="l-Scalar-Plain">metadata</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">mongodb</span>
</span><span class='line'><span class="l-Scalar-Plain">spec</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="l-Scalar-Plain">volumes</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">mongodb-data           1</span>
</span><span class='line'>    <span class="l-Scalar-Plain">gcePersistentDisk</span><span class="p-Indicator">:</span>           <span class="l-Scalar-Plain">1</span>
</span><span class='line'>      <span class="l-Scalar-Plain">pdName</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">mongodb            1</span>
</span><span class='line'>      <span class="l-Scalar-Plain">fsType</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">ext4               1</span>
</span><span class='line'>  <span class="l-Scalar-Plain">containers</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">image</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">mongo</span>
</span><span class='line'>    <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">mongodb</span>
</span><span class='line'>    <span class="l-Scalar-Plain">volumeMounts</span><span class="p-Indicator">:</span>
</span><span class='line'>    <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">mongodb-data         2</span>
</span><span class='line'>      <span class="l-Scalar-Plain">mountPath</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">/data/db        2</span>
</span><span class='line'>    <span class="l-Scalar-Plain">ports</span><span class="p-Indicator">:</span>
</span><span class='line'>    <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">containerPort</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">27017</span>
</span><span class='line'>      <span class="l-Scalar-Plain">protocol</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">TCP</span>
</span></code></pre></td></tr></table></div></figure>


<blockquote><ol>
<li>使用GCE Persistent Disk.</li>
<li>使用GCE Persistent Disk，挂载到/data/db上</li>
</ol>
</blockquote>

<h4>五. 自建文件系统存储</h4>

<p>NFS、iscsi(ISCSI disk)、glusterfs(GlusterFS), rbd(RADOS Block Device), flexVolume, cinder, cephfs, flocker, fc (Fibre Channel)等</p>

<h4>六. 如何将Pod与存储机制解耦</h4>

<p>到目前为止，所有持久卷类型都要求POD的开发人员了解集群实际的网络存储基础结构。例如，要创建一个支持NFS的卷，开发人员必须知道NFS所在的实际服务器。这与Kubernetes的基本理念背道而驰，Kubernetes的目标是对应用程序及其开发人员透明化其背后的基础设施，使他们不必关心基础设施的具体情况，也不必让应用程序在各种云提供商和内部数据中心之间实现数据的移植。</p>

<p>理想情况下，在Kubernetes上部署应用程序的开发人员不必知道底层使用的是哪种存储技术，就像他们不必知道运行其pod所使用的物理服务器类型一样。当开发人员需要为他们的应用程序提供持久化的存储时，他们应该直接能够配置，就像在创建pod时配置CPU、内存和其他资源一样。</p>

<p>为了使应用程序能够在Kubernetes集群中请求存储，而不必处理基础设施的具体细节，K8S引入了两种新的资源:</p>

<ul>
<li>PersistentVolumes</li>
<li>PersistentVolumeClaims</li>
</ul>


<p>使用方式如下所示:</p>

<p><img src="http://wldandan.github.com/images/k8s/k8s-volume-pv-and-pvc.png" /></p>

<p>如图所示，开发人员不需要在pod中使用特定的存储机制，集群管理员设置底层存储，然后通过kubernetes创建PV，并且指定其大小和支持的访问模式。</p>

<p>当开发人员需要在pod中使用持久存储时，他们首先创建一个PVC清单，指定所需的大小和访问模式。然后用户将PVC清单提交给kubernetes ，kubernetes找到适当的PV并将其绑定到PV上。</p>

<p>当使用了PV和PVC后，使用GCE Persisent Disk的机制如下所示：</p>

<p><img src="http://wldandan.github.com/images/k8s/k8s-volume-pv-vs-volume.png" /></p>

<p>总而言之，在pod中使用持久性存储的最佳方法是创建pvc（必要时使用显式指定的storageclassname），并由动态PersistentVolume Provider负责创建。</p>

<h4>总结</h4>

<p>在K8S中使用存储机制总结如下：</p>

<ul>
<li>使用EmptyDir卷存储临时的非持久性数据</li>
<li>使用gitrepo卷在pod启动时获取git存储库的内容。</li>
<li>使用hostpath卷访问主机节点的文件</li>
<li>在volume中挂在外部存储，在pod启动后保持数据</li>
<li>通过使用persistentvolume和persistentvolumeclaims将pod与存储基础结构分离</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[K8s之Service]]></title>
    <link href="http://wldandan.github.com/blog/2019/03/17/k8s-concept-service/"/>
    <updated>2019-03-17T20:45:00+08:00</updated>
    <id>http://wldandan.github.com/blog/2019/03/17/k8s-concept-service</id>
    <content type="html"><![CDATA[<h3>如何访问Pod？</h3>

<p>在非k8s世界中，管理员可以通过在配置文件中指定IP地址或主机名，容许客户端访问，但在k8s中这种方式是行不通的。因为Pod 是有生命周期的，它们可以被创建或销毁。虽然通过 ReplicationController 能够动态地创建Pod，但当Pod被分配到某个节点时，K8s都会为其分配一个IP地址，而该IP地址不总是稳定可依赖的。因此，在 Kubernetes 集群中，如果一组 Pod（称为 backend）为其它 Pod （称为 frontend）提供服务，那么那些 frontend 该如何发现，并连接到这组backend的Pod呢？</p>

<!-- More -->


<h3>Service</h3>

<p>Kubernetes中的Service是一种资源的定义，它将Pod逻辑分组，并提供客户端访问。</p>

<p><img src="http://wldandan.github.com/images/k8s/k8s-service-1.png" /></p>

<p> 通过 Label Selector，一组 Pod 能够被暴露为Service，供客户端访问。</p>

<p> <img src="http://wldandan.github.com/images/k8s/k8s-service-2.png" /></p>

<p>举个例子，考虑一个图片处理 backend，它运行了3个副本。这些副本是可互换的，通过Service能够解耦frontend与backend的关联。</p>

<blockquote><p>frontend 不需要关心它们调用了哪个 backend 副本。 然而组成这一组 backend 程序的 Pod 实际上可能会发生变化，frontend 客户端不应该也没必要知道，而且也不需要跟踪这一组 backend 的状态。</p></blockquote>

<h3>创建Service</h3>

<p>一个 Service 在 Kubernetes 中是一个 REST 对象，和 Pod 类似。 像所有的 REST 对象一样， Service 定义可以基于 POST 方式，请求 apiserver 创建新的实例。 例如，假定有一组 Pod，它们对外暴露了 9376 端口，同时还被打上 &#8220;app=MyApp&#8221; 标签。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='yaml'><span class='line'><span class="l-Scalar-Plain">kind</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">Service</span>
</span><span class='line'><span class="l-Scalar-Plain">apiVersion</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">v1</span>
</span><span class='line'><span class="l-Scalar-Plain">metadata</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">my-service</span>
</span><span class='line'><span class="l-Scalar-Plain">spec</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="l-Scalar-Plain">selector</span><span class="p-Indicator">:</span>
</span><span class='line'>    <span class="l-Scalar-Plain">app</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">MyApp            //根据Label选择一组Pod</span>
</span><span class='line'>  <span class="l-Scalar-Plain">ports</span><span class="p-Indicator">:</span>
</span><span class='line'>    <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">protocol</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">TCP</span>
</span><span class='line'>      <span class="l-Scalar-Plain">port</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">80            //用于访问该Service的端口</span>
</span><span class='line'>      <span class="l-Scalar-Plain">targetPort</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">9376    //用于访问容器的端口</span>
</span></code></pre></td></tr></table></div></figure>


<p>接下来，我们可以使用<code>kubectl</code>访问该Service</p>

<p><img src="http://wldandan.github.com/images/k8s/k8s-service-3.png" /></p>

<h3>Service如何被外部网络的Client访问</h3>

<p>可以通过如下三种方式，容许外部网络的Client访问Service：</p>

<h4>1.将Service Type置为<code>NodePort</code></h4>

<p>对于NotePort的Service，每个节点(Node)都会打开节点本身的端口，并将该端口上接收到的流量重定向到Service。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='yaml'><span class='line'><span class="l-Scalar-Plain">apiVersion</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">v1</span>
</span><span class='line'><span class="l-Scalar-Plain">kind</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">Service</span>
</span><span class='line'><span class="l-Scalar-Plain">metadata</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">kubia-nodeport</span>
</span><span class='line'><span class="l-Scalar-Plain">spec</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="l-Scalar-Plain">type</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">NodePort             //NodePort类型</span>
</span><span class='line'>  <span class="l-Scalar-Plain">ports</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">port</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">80                 //Service内部访问的地址</span>
</span><span class='line'>    <span class="l-Scalar-Plain">targetPort</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">8080         //转发给目标Pod的地址</span>
</span><span class='line'>    <span class="l-Scalar-Plain">nodePort</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">30123          //可访问的nodeport端口</span>
</span><span class='line'>  <span class="l-Scalar-Plain">selector</span><span class="p-Indicator">:</span>
</span><span class='line'>    <span class="l-Scalar-Plain">app</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">kubia</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>使用NodePort的Service如下图所示：
<img src="http://wldandan.github.com/images/k8s/k8s-service-4.png" /></p>

<h4>2.将Service Type设置为<code>LoadBalancer</code></h4>

<p>通过设置<code>LoadBalancer</code>，Service可以通过一个专用的负载均衡器来访问（这个均衡器是运行kubernetes的基础设施提供的）。负载均衡器将流量重定向到所有节点上的节点端口。客户机通过负载均衡器的IP连接到服务。</p>

<p>如果kubernetes在不支持LoadBalancer服务的环境中运行，则不会提供负载均衡器，但该服务的行为仍将类似于NodePort服务。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='yaml'><span class='line'><span class="l-Scalar-Plain">apiVersion</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">v1</span>
</span><span class='line'><span class="l-Scalar-Plain">kind</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">Service</span>
</span><span class='line'><span class="l-Scalar-Plain">metadata</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">kubia-loadbalancer</span>
</span><span class='line'><span class="l-Scalar-Plain">spec</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="l-Scalar-Plain">type</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">LoadBalancer</span>
</span><span class='line'>  <span class="l-Scalar-Plain">ports</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">port</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">80</span>
</span><span class='line'>    <span class="l-Scalar-Plain">targetPort</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">8080</span>
</span><span class='line'>  <span class="l-Scalar-Plain">selector</span><span class="p-Indicator">:</span>
</span><span class='line'>    <span class="l-Scalar-Plain">app</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">kubia</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>使用如上配置文件创建Service之后，会调用云基础设施，创建负载均衡器并将其IP地址写入Service对象。一旦结束，IP地址将作为Service的外部IP地址列出：</p>

<p>如下图所示：
<img src="http://wldandan.github.com/images/k8s/k8s-service-5.png" /></p>

<h4>3.使用<code>Ingress</code>资源</h4>

<p>这是一种完全不同的机制，通过一个IP地址公开多个服务，它在HTTP（网络层7）上运行，因此可以提供比第4层服务更多的功能。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='yaml'><span class='line'><span class="l-Scalar-Plain">apiVersion</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">extensions/v1beta1</span>
</span><span class='line'><span class="l-Scalar-Plain">kind</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">Ingress</span>
</span><span class='line'><span class="l-Scalar-Plain">metadata</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">kubia</span>
</span><span class='line'><span class="l-Scalar-Plain">spec</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="l-Scalar-Plain">rules</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">host</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">kubia.example.com               //使用domain name访问service</span>
</span><span class='line'>    <span class="l-Scalar-Plain">http</span><span class="p-Indicator">:</span>
</span><span class='line'>      <span class="l-Scalar-Plain">paths</span><span class="p-Indicator">:</span>
</span><span class='line'>      <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">path</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">/                           //访问的路径</span>
</span><span class='line'>        <span class="l-Scalar-Plain">backend</span><span class="p-Indicator">:</span>
</span><span class='line'>          <span class="l-Scalar-Plain">serviceName</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">kubia-nodeport</span>
</span><span class='line'>          <span class="l-Scalar-Plain">servicePort</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">80</span>
</span></code></pre></td></tr></table></div></figure>


<p>通过Ingress访问Service的流程如下：</p>

<p><img src="http://wldandan.github.com/images/k8s/k8s-service-7.png" /></p>

<p>另外，可以通过Ingress访问多个服务：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='yaml'><span class='line'><span class="nn">...</span>
</span><span class='line'>  <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">host</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">kubia.example.com</span>
</span><span class='line'>    <span class="l-Scalar-Plain">http</span><span class="p-Indicator">:</span>
</span><span class='line'>      <span class="l-Scalar-Plain">paths</span><span class="p-Indicator">:</span>
</span><span class='line'>      <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">path</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">/kubia</span>
</span><span class='line'>        <span class="l-Scalar-Plain">backend</span><span class="p-Indicator">:</span>
</span><span class='line'>          <span class="l-Scalar-Plain">serviceName</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">kubia</span>
</span><span class='line'>          <span class="l-Scalar-Plain">servicePort</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">80</span>
</span><span class='line'>      <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">path</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">/foo</span>
</span><span class='line'>        <span class="l-Scalar-Plain">backend</span><span class="p-Indicator">:</span>
</span><span class='line'>          <span class="l-Scalar-Plain">serviceName</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">bar</span>
</span><span class='line'>          <span class="l-Scalar-Plain">servicePort</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">80</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="http://wldandan.github.com/images/k8s/k8s-service-6.png" /></p>

<h3>Service的诊断</h3>

<p>Service是Kubernetes的关键概念，也是令许多开发人员沮丧的根源。我见过许多开发人员耗费大量时间，来弄清楚为什么无法通过Servic IP或fqdn访问到自己的pods。
出于这个原因，简单介绍一下如何对服务进行故障排除。当无法通过Service访问您的pod时，可以从以下列表开始：</p>

<ul>
<li><p>首先，确保从集群内而不是从外部连接到Service的集群IP。</p></li>
<li><p>不要费心Ping Service的IP来确定服务是否可以访问（记住，服务的集群IP是一个虚拟IP，Ping它永远不会工作）。</p></li>
<li><p>如果您已经定义了一个readiness probe，请确保它是成功的；否则Pod将不属于服务的一部分。</p></li>
<li><p>要确认Pod是服务的一部分，请使用kubectl get endpoints检查相应的endpoint对象。</p></li>
<li><p>如果您试图通过其fqdname或其一部分（例如，myservice.mynamespace.svc.cluster.local或myservice.mynamespace）访问服务，但该服务不起作用，请查看是否可以使用其群集IP而不是fqdname访问该服务。</p></li>
<li><p>检查您是否连接到服务公开的端口，而不是目标端口。</p></li>
<li><p>尝试直接连接到pod ip以确认pod是否接受正确端口上的连接。</p></li>
<li><p>如果你甚至不能通过pod的IP访问你的应用，确保你的应用是否绑定到locahost。</p></li>
</ul>


<h3>总结</h3>

<p>Service是K8s中重要的概念，你应该至少明白Service的这些内容：</p>

<ul>
<li><p>通过Lable selector，将一组Pod设置为Service，并为Service配置静态的IP和端口</p></li>
<li><p>Service可以从Cluster内部访问，也可以通过设置为NodePort或者LoadBalancer的方式从外部访问</p></li>
<li><p>Pod可以通过环境变量获取Service的IP和Port，进行访问</p></li>
<li><p>可以将对Pod的关联关系，设置到Endpoint资源中，而简化label selector的方式</p></li>
<li><p>通过设置ServiceType为<code>ExternalName</code>，可以访问外部的Service</p></li>
<li><p>通过Ingress可以设置多个Service被外部访问</p></li>
<li><p>使用pod的readiness probe可以决定pod是否被作为service的一部分</p></li>
<li><p>通过headless Service，可以使用DNS获取Pod的IP</p></li>
</ul>


<h3>参考</h3>

<p>《Kubernetes in action》
《Kubernetes handbook》</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[K8s之控制器]]></title>
    <link href="http://wldandan.github.com/blog/2019/03/16/k8s-concept-controller/"/>
    <updated>2019-03-16T20:45:00+08:00</updated>
    <id>http://wldandan.github.com/blog/2019/03/16/k8s-concept-controller</id>
    <content type="html"><![CDATA[<p>Kubernetes中内建了很多controller（控制器），这些相当于一个状态机，用来控制Pod的具体状态和行为。</p>

<!-- More -->


<p>这里已经讲的很详细了，请<a href="https://jimmysong.io/kubernetes-handbook/concepts/deployment.html">参考</a></p>

<h4>Deployment 是什么？</h4>

<p>Deployment为Pod和Replica Set（下一代Replication Controller）提供声明式更新。</p>

<p>您只需要在 Deployment 中描述期望的目标状态，Deployment controller 会帮您将 Pod 和ReplicaSet 的实际状态改变到您的目标状态。</p>

<p>典型的用例如下：</p>

<ul>
<li>使用Deployment来创建ReplicaSet。ReplicaSet在后台创建pod。检查启动状态，看它是成功还是失败。</li>
<li>然后，通过更新Deployment的PodTemplateSpec字段来声明Pod的新状态。这会创建一个新的ReplicaSet，Deployment会按照控制的速率将pod从旧的ReplicaSet移动到新的ReplicaSet中。</li>
<li>如果当前状态不稳定，回滚到之前的Deployment revision。每次回滚都会更新Deployment的revision。</li>
<li>扩容Deployment以满足更高的负载。</li>
<li>暂停Deployment来应用PodTemplateSpec的多个修复，然后恢复上线。</li>
<li>根据Deployment 的状态判断上线是否hang住了。</li>
<li>清除旧的不必要的 ReplicaSet。</li>
</ul>


<h4>创建 Deployment</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ kubectl create -f https://kubernetes.io/docs/user-guide/nginx-deployment.yaml --record
</span><span class='line'>deployment "nginx-deployment" created</span></code></pre></td></tr></table></div></figure>


<h4>更新Deployment</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ kubectl set image deployment/nginx-deployment nginx=nginx:1.9.1
</span><span class='line'>deployment "nginx-deployment" image updated</span></code></pre></td></tr></table></div></figure>


<h4>检查 Deployment 升级的历史记录</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ kubectl rollout history deployment/nginx-deployment
</span><span class='line'>deployments "nginx-deployment":
</span><span class='line'>REVISION    CHANGE-CAUSE
</span><span class='line'>1           kubectl create -f https://kubernetes.io/docs/user-guide/nginx-deployment.yaml--record
</span><span class='line'>2           kubectl set image deployment/nginx-deployment nginx=nginx:1.9.1
</span><span class='line'>3           kubectl set image deployment/nginx-deployment nginx=nginx:1.91</span></code></pre></td></tr></table></div></figure>


<h4>回退到历史版本</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ kubectl rollout undo deployment/nginx-deployment --to-revision=2
</span><span class='line'>deployment "nginx-deployment" rolled back</span></code></pre></td></tr></table></div></figure>


<h4>Deployment 扩容</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ kubectl scale deployment nginx-deployment --replicas 10
</span><span class='line'>deployment "nginx-deployment" scaled</span></code></pre></td></tr></table></div></figure>


<h4>Deployment 状态</h4>

<p>Deployment 在生命周期中有多种状态。在创建一个新的 ReplicaSet 的时候它可以是 <code>progressing</code> 状态， <code>complete</code> 状态，或者 <code>fail to progress</code> 状态。</p>

<h3>编写 Deployment Spec</h3>

<p>在所有的 Kubernetes 配置中，Deployment 也需要<code>apiVersion</code>，<code>kind</code>和<code>metadata</code>这些配置项。配置文件的通用使用说明查看 <a href="https://kubernetes.io/docs/tasks/run-application/run-stateless-application-deployment/">部署应用</a>，配置容器，和 <a href="https://kubernetes.io/docs/tutorials/object-management-kubectl/object-management/">使用 kubectl 管理资源 </a> 文档。</p>

<h4>Pod Template</h4>

<p> <code>.spec.template</code> 是 <code>.spec</code>中唯一要求的字段。</p>

<p><code>.spec.template</code> 是 <a href="https://kubernetes.io/docs/user-guide/replication-controller/#pod-template">pod template</a>. 它跟 <a href="https://kubernetes.io/docs/user-guide/pods">Pod</a>有一模一样的schema，除了它是嵌套的并且不需要<code>apiVersion</code> 和 <code>kind</code>字段。</p>

<p>另外为了划分Pod的范围，Deployment中的pod template必须指定适当的label（不要跟其他controller重复了，参考<a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment#selector">selector</a>）和适当的重启策略。</p>

<p><a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle"><code>.spec.template.spec.restartPolicy</code></a> 可以设置为 <code>Always</code> , 如果不指定的话这就是默认配置。</p>

<h4>Replicas</h4>

<p><code>.spec.replicas</code> 是可以选字段，指定期望的pod数量，默认是1。</p>

<h4>Selector</h4>

<p><code>.spec.selector</code>是可选字段，用来指定 <a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/labels">label selector</a> ，圈定Deployment管理的pod范围。</p>

<p>如果被指定， <code>.spec.selector</code> 必须匹配 <code>.spec.template.metadata.labels</code>，否则它将被API拒绝。如果 <code>.spec.selector</code> 没有被指定， <code>.spec.selector.matchLabels</code> 默认是 <code>.spec.template.metadata.labels</code>。</p>

<p>在Pod的template跟<code>.spec.template</code>不同或者数量超过了<code>.spec.replicas</code>规定的数量的情况下，Deployment会杀掉label跟selector不同的Pod。</p>

<p><strong>注意：</strong> 您不应该再创建其他label跟这个selector匹配的pod，或者通过其他Deployment，或者通过其他Controller，例如ReplicaSet和ReplicationController。否则该Deployment会被把它们当成都是自己创建的。Kubernetes不会阻止您这么做。</p>

<p>如果您有多个controller使用了重复的selector，controller们就会互相打架并导致不正确的行为。</p>

<h4>策略</h4>

<p><code>.spec.strategy</code> 指定新的Pod替换旧的Pod的策略。 <code>.spec.strategy.type</code> 可以是&#8221;Recreate&#8221;或者是 &#8220;RollingUpdate&#8221;。&#8221;RollingUpdate&#8221;是默认值。</p>

<h5>Recreate Deployment</h5>

<p><code>.spec.strategy.type==Recreate</code>时，在创建出新的Pod之前会先杀掉所有已存在的Pod。</p>

<h5>Rolling Update Deployment</h5>

<p><code>.spec.strategy.type==RollingUpdate</code>时，Deployment使用<a href="https://kubernetes.io/docs/tasks/run-application/rolling-update-replication-controller">rolling update</a> 的方式更新Pod 。您可以指定<code>maxUnavailable</code> 和 <code>maxSurge</code> 来控制 rolling update 进程。</p>

<h5>Max Unavailable</h5>

<p><code>.spec.strategy.rollingUpdate.maxUnavailable</code> 是可选配置项，用来指定在升级过程中不可用Pod的最大数量。该值可以是一个绝对值（例如5），也可以是期望Pod数量的百分比（例如10%）。通过计算百分比的绝对值向下取整。如果<code>.spec.strategy.rollingUpdate.maxSurge</code> 为0时，这个值不可以为0。默认值是1。</p>

<p>例如，该值设置成30%，启动rolling update后旧的ReplicatSet将会立即缩容到期望的Pod数量的70%。新的Pod ready后，随着新的ReplicaSet的扩容，旧的ReplicaSet会进一步缩容，确保在升级的所有时刻可以用的Pod数量至少是期望Pod数量的70%。</p>

<h5>Max Surge</h5>

<p><code>.spec.strategy.rollingUpdate.maxSurge</code> 是可选配置项，用来指定可以超过期望的Pod数量的最大个数。该值可以是一个绝对值（例如5）或者是期望的Pod数量的百分比（例如10%）。当<code>MaxUnavailable</code>为0时该值不可以为0。通过百分比计算的绝对值向上取整。默认值是1。</p>

<p>例如，该值设置成30%，启动rolling update后新的ReplicatSet将会立即扩容，新老Pod的总数不能超过期望的Pod数量的130%。旧的Pod被杀掉后，新的ReplicaSet将继续扩容，旧的ReplicaSet会进一步缩容，确保在升级的所有时刻所有的Pod数量和不会超过期望Pod数量的130%。</p>

<h4>Progress Deadline Seconds</h4>

<p><code>.spec.progressDeadlineSeconds</code> 是可选配置项，用来指定在系统报告Deployment的<a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment#failed-deployment">failed progressing</a> ——表现为resource的状态中<code>type=Progressing</code>、<code>Status=False</code>、 <code>Reason=ProgressDeadlineExceeded</code>前可以等待的Deployment进行的秒数。Deployment controller会继续重试该Deployment。未来，在实现了自动回滚后， deployment controller在观察到这种状态时就会自动回滚。</p>

<p>如果设置该参数，该值必须大于 <code>.spec.minReadySeconds</code>。</p>

<h4>Min Ready Seconds</h4>

<p><code>.spec.minReadySeconds</code>是一个可选配置项，用来指定没有任何容器crash的Pod并被认为是可用状态的最小秒数。默认是0（Pod在ready后就会被认为是可用状态）。进一步了解什么什么后Pod会被认为是ready状态，参阅 <a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes">Container Probes</a>。</p>

<h4>Rollback To</h4>

<p><code>.spec.rollbackTo</code> 是一个可以选配置项，用来配置Deployment回退的配置。设置该参数将触发回退操作，每次回退完成后，该值就会被清除。</p>

<h4>Revision</h4>

<p><code>.spec.rollbackTo.revision</code>是一个可选配置项，用来指定回退到的revision。默认是0，意味着回退到上一个revision。</p>

<h4>Revision History Limit</h4>

<p>Deployment revision history存储在它控制的ReplicaSets中。</p>

<p><code>.spec.revisionHistoryLimit</code> 是一个可选配置项，用来指定可以保留的旧的ReplicaSet数量。该理想值取决于心Deployment的频率和稳定性。如果该值没有设置的话，默认所有旧的Replicaset或会被保留，将资源存储在etcd中，是用<code>kubectl get rs</code>查看输出。每个Deployment的该配置都保存在ReplicaSet中，然而，一旦您删除的旧的RepelicaSet，您的Deployment就无法再回退到那个revison了。</p>

<p>如果您将该值设置为0，所有具有0个replica的ReplicaSet都会被删除。在这种情况下，新的Deployment rollout无法撤销，因为revision history都被清理掉了。</p>

<h4>Paused</h4>

<p><code>.spec.paused</code>是可以可选配置项，boolean值。用来指定暂停和恢复Deployment。Paused和没有paused的Deployment之间的唯一区别就是，所有对paused deployment中的PodTemplateSpec的修改都不会触发新的rollout。Deployment被创建之后默认是非paused。</p>

<h3>资源参考</h3>

<p><a href="https://jimmysong.io/kubernetes-handbook/concepts/deployment.html">k8s handbook - Deployment</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[K8s之Pod]]></title>
    <link href="http://wldandan.github.com/blog/2019/03/16/k8s-concept-pod/"/>
    <updated>2019-03-16T19:45:00+08:00</updated>
    <id>http://wldandan.github.com/blog/2019/03/16/k8s-concept-pod</id>
    <content type="html"><![CDATA[<p>Pod是kubernetes中你可以创建和部署的最小也是最简的单位。Pod代表着集群中运行的进程。Pod中封装着应用的容器（1或多个容器）、存储、独立的网络IP，并管理着容器运行的策略选项。</p>

<!-- More -->


<h3>Pod概览</h3>

<p>Pod是一个服务的多个进程的聚合单位，pod通过提供一个更高级别的抽象的方式，极大简化了应用部署管理。
Pod作为一个独立的部署单位，支持横向扩展和复制、协同调度、命运共同体（例如被同时终结），协同复制，资源共享，依赖管理等，Pod会自动的为容器处理这些问题。</p>

<h4>什么是Pod</h4>

<p>Pod是kubernetes中你可以创建和部署的最小也是最简的单位。Pod代表着集群中运行的进程。</p>

<p>Pod中封装着应用的容器（1或多个容器）、存储、独立的网络IP，并管理着容器运行的策略选项。</p>

<p>在Kubrenetes集群中Pod有如下两种使用方式：</p>

<ul>
<li><p>一个Pod中运行一个容器。“每个Pod中一个容器”的模式是最常见的用法；在这种使用方式中，你可以把Pod想象成是单容器的封装，kuberentes管理的是Pod而不是容器。</p></li>
<li><p>在一个Pod中同时运行多个容器。一个Pod中也可以同时封装几个紧密耦合、互相协作的容器，它们之间共享资源。这些在同一个Pod中的容器互相协作，成为一个service单位——如一个容器共享文件，另一个容器更新文件。Pod将这些容器的存储资源作为一个实体来管理。</p></li>
</ul>


<h4>Pod的生命周期</h4>

<p>Pod 的 status 字段是一个 PodStatus 对象，PodStatus中有一个 phase 字段。</p>

<p>下面是 phase 可能的值：</p>

<ul>
<li>挂起（Pending）：Pod 已被 Kubernetes
系统接受，但有一个或者多个容器镜像尚未创建。等待时间包括调度 Pod的时间和通过网络下载镜像的时间，这可能需要花点时间。</li>
<li>运行中（Running）：该 Pod 已经绑定到了一个节点上，Pod 中所有的容器都已被创建。至少有一个容器正在运行，或者正处于启动或重启状态。</li>
<li>成功（Succeeded）：Pod 中的所有容器都被成功终止，并且不会再重启。</li>
<li>失败（Failed）：Pod 中的所有容器都已终止了，并且至少有一个容器是因为失败终止。也就是说，容器以非0状态退出或者被系统终止。</li>
<li>未知（Unknown）：因为某些原因无法取得 Pod 的状态，通常是因为与 Pod 所在主机通信失败。</li>
</ul>


<p>下图是Pod的生命周期示意图，从图中可以看到Pod状态的变化。</p>

<p><img src="http://wldandan.github.com/images/k8s/kubernetes-pod-life-cycle.jpg" /></p>

<h4>Pod如何管理多个容器</h4>

<p>Pod中可以同时运行多个容器（独立进程运行）并协同工作。同一个Pod中的容器会自动的分配到同一个node 上运行，同时，同一个Pod中的容器共享存储、网络和依赖，它们总是被同时调度。</p>

<ul>
<li><p>网络</p>

<blockquote><p>每个Pod都会被分配唯一的一个IP地址。Pod中的所有容器共享网络空间，包括IP地址和端口。Pod内部的容器可以使用localhost互相通信。Pod中的容器与外界通信时，必须分配共享网络资源（例如使用宿主机的端口映射）。</p></blockquote></li>
<li><p>存储</p>

<blockquote><p>可以为一个Pod指定多个共享的Volume。Pod中的所有容器都可以访问共享的volume。Volume也可以用来持久化Pod中的存储资源，以防容器重启后文件丢失。</p></blockquote></li>
</ul>


<h3>Pod的管理</h3>

<h4>Pod间发现</h4>

<p>Pod中应用容器共享网络空间（IP地址和端口），因此可以通过localhost互相发现。
Pod中应用容器的hostname被设置成Pod的名字。
Pod中应用容器可以共享volume。volume能够保证pod重启时使用的数据不丢失。</p>

<h4>Pod的使用</h4>

<p>Pod也可以用于垂直应用（例如LAMP），这样使用的动机是为了支持共同调度和协调应用程序，例如：
* 内容管理系统、文件和数据加载器、本地换群管理器等。
* 日志和检查点备份、压缩、旋转、快照等。
* 数据变更观察者、日志和监控适配器、活动发布者等。
* 代理、桥接和适配器等。
* 控制器、管理器、配置器、更新器等。</p>

<h4>Pod的持久性</h4>

<p>Pod不是作为持久化设计的。在调度失败、节点故障、缺少资源或者节点维护的状态下都会失败。</p>

<p>通常，用户不需要手动直接创建Pod，而是应该使用controller（例如Deployments），即使是在创建单个Pod的情况下。Controller可以提供集群级别的自愈功能、复制和升级管理。</p>

<h3>Pod高级特性</h3>

<h4>Pod Preset</h4>

<p>Kubernetes提供了一个准入控制器（PodPreset），当其启用时，Pod Preset 会将应用创建请求传入到该控制器上。因此，<code>Pod Preset</code>是用来在 Pod 被创建的时候向其中注入额外的运行时需求的 API 资源。</p>

<p>您可以使用<code>label selector</code> 来指定为哪些 Pod 应用 Pod Preset。</p>

<h4>Pod和Controller</h4>

<p>Controller可以创建和管理多个Pod，提供副本管理、滚动升级和集群级别的自愈能力。例如，如果一个Node故障，Controller就能自动将该节点上的Pod调度到其他健康的Node上。</p>

<p>包含一个或者多个Pod的Controller示例：</p>

<ul>
<li>Deployment</li>
<li>StatefulSet</li>
<li>DaemonSet</li>
</ul>


<p>通常，Controller会用你提供的Pod Template来创建相应的Pod。</p>

<h4>Init容器</h4>

<p>Init是一种专用的容器，在应用程序容器启动之前运行，包含应用镜像中工具或环境的安装脚本。</p>

<p>Pod 能够有一个或多个先于应用容器启动的 Init 容器。</p>

<p>Init 容器与普通的容器非常像，除了如下两点：
* Init 容器总是运行到成功完成为止。
* 每个 Init 容器都必须在下一个 Init 容器启动之前成功完成。</p>

<p>如果 Pod 的 Init 容器失败，Kubernetes 会不断地重启该 Pod，直到 Init容器成功为止。然而，如果 Pod 对应的 restartPolicy 为 Never，它不会重新启动。</p>

<p>因为 Init 容器具有与应用程序容器分离的单独镜像，所以它们的启动相关代码具有如下优势：</p>

<ul>
<li><p>它们可以包含并运行实用工具，它们可以包含使用工具和定制化代码来安装。例如，创建镜像没必要FROM 另一个镜像，只需要在安装过程中使用类似 sed、 awk、 python 或 dig 这样的工具。</p></li>
<li><p>应用程序镜像可以分离出创建和部署的角色，而没有必要联合它们构建一个单独的镜像。</p></li>
<li><p>Init 容器使用 Linux Namespace，所以相对应用程序容器来说具有不同的文件系统视图。因此，它们能够具有访问 Secret 的权限，而应用程序容器则不能。</p></li>
<li><p>它们必须在应用程序容器启动之前运行完成，所以 Init 容器能够提供一种简单的阻塞或延迟应用容器的启动的方法，直到满足了一组先决条件。</p></li>
</ul>


<h4>Pod 安全策略</h4>

<p>Pod 安全策略 是集群级别的资源，它能够控制 Pod 运行的行为，以及它具有访问什么资源的能力。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[K8s之网络]]></title>
    <link href="http://wldandan.github.com/blog/2019/03/15/k8s-concept-network/"/>
    <updated>2019-03-15T23:45:00+08:00</updated>
    <id>http://wldandan.github.com/blog/2019/03/15/k8s-concept-network</id>
    <content type="html"><![CDATA[<p>K8s的网络介绍</p>

<!-- More -->


<h3>K8s集群IP</h3>

<p>Kubernetes集群内部存在三类IP，分别是：</p>

<ul>
<li>Node IP：宿主机的IP地址</li>
<li>Pod IP：使用网络插件创建的IP（如flannel），使跨主机的Pod可以互通</li>
<li>Cluster IP：虚拟IP，通过iptables规则访问服务</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[K8s之集群]]></title>
    <link href="http://wldandan.github.com/blog/2019/03/15/k8s-concept-cluster/"/>
    <updated>2019-03-15T21:45:00+08:00</updated>
    <id>http://wldandan.github.com/blog/2019/03/15/k8s-concept-cluster</id>
    <content type="html"><![CDATA[<p>为了管理异构和不同配置的主机，为了便于Pod的运维管理，Kubernetes中提供了很多集群管理的配置和管理功能，通过namespace划分的空间，通过为node节点创建label和taint用于pod的调度等。</p>

<!-- More -->


<h3>Node</h3>

<p>Node是kubernetes集群的工作节点，可以是物理机也可以是虚拟机。</p>

<h5>Node的状态:</h5>

<ul>
<li><p>Address</p>

<ul>
<li>HostName：可以被kubelet中的&#8211;hostname-override参数替代。</li>
<li>ExternalIP：可以被集群外部路由到的IP地址。</li>
<li>InternalIP：集群内部使用的IP，集群外部无法访问。</li>
</ul>
</li>
<li><p>Condition</p>

<ul>
<li>OutOfDisk：磁盘空间不足时为True</li>
<li>Ready：Node controller 40秒内没有收到node的状态报告为Unknown，健康为True，否则为False。</li>
<li>MemoryPressure：当node没有内存压力时为True，否则为False。</li>
<li>DiskPressure：当node没有磁盘压力时为True，否则为False。</li>
</ul>
</li>
<li><p>Capacity</p>

<ul>
<li>CPU</li>
<li>内存</li>
<li>可运行的最大Pod个数</li>
</ul>
</li>
<li><p>Info：节点的一些版本信息，如OS、kubernetes、docker等</p></li>
</ul>


<h3>Namespace</h3>

<p>在一个Kubernetes集群中可以使用namespace创建多个“虚拟集群”，这些集群之间可以完全隔离。如当项目和人员众多的时候可以考虑根据项目属性，例如生产、测试、开发划分不同的namespace。</p>

<p>另外，也可以让一个namespace中的service访问到其他的namespace中的服务。</p>

<h3>Label &amp; Annonication</h3>

<p>Label是附在对象上（例如Pod）的键值对。可以在创建对象的时候指定，也可以在对象创建后随时指定。Labels的值对系统本身并没有什么含义，只是对用户有意义。通过label selector，客户端／用户可以指定一个object集合，通过label selector对object的集合进行操作。</p>

<p>Annotation,可以将Kubernetes资源对象关联到任意的非标识性元数据。使用客户端（如工具和库）可以检索到这些元数据。</p>

<p>Label和Annotation都可以将元数据关联到Kubernetes资源对象。Label主要用于选择对象，可以挑选出满足特定条件的对象。相比之下，annotation 不能用于标识及选择对象。annotation中的元数据可多可少，可以是结构化的或非结构化的，也可以包含label中不允许出现的字符。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[K8s核心概念]]></title>
    <link href="http://wldandan.github.com/blog/2019/03/14/k8s-concepts/"/>
    <updated>2019-03-14T23:45:00+08:00</updated>
    <id>http://wldandan.github.com/blog/2019/03/14/k8s-concepts</id>
    <content type="html"><![CDATA[<p>Paxos发明人Leslie Lamport提出，分布式系统有两类特性：</p>

<ul>
<li><p>安全性(Safety)</p>

<blockquote><p>保证系统的稳定，保证系统不会崩溃，不会出现业务错误，不会做坏事，是严格约束的。</p></blockquote></li>
<li><p>活性(Liveness)</p>

<blockquote><p>使得系统可以提供功能，提高性能，增加易用性，让系统可以在用户“看到的时间内”做些好事，是尽力而为的。</p></blockquote></li>
</ul>


<p>从Kubernetes的系统架构和设计来看，存在两个最核心的设计理念，符合Lamport的理论：</p>

<ul>
<li><p>容错性</p>

<blockquote><p>容错性实际是保证Kubernetes系统稳定性和安全性的基础</p></blockquote></li>
<li><p>易扩展性</p>

<blockquote><p>易扩展性是保证对变更友好，可以快速迭代增加新功能的基础</p></blockquote></li>
</ul>


<!-- More -->


<p>在K8S中，支撑核心设计理念的背后，存在着诸多领域对象，本文主要梳理了K8S系统中存在的主要概念。</p>

<table>
<thead>
<tr>
<th></th>
<th>类别</th>
<th>名称</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>资源对象</td>
<td>Pod、ReplicaSet、ReplicationController、Deployment、StatefulSet、DaemonSet、Job、CronJob、HorizontalPodAutoscaling、Node、Namespace、Service、Ingress、Label、CustomResourceDefinition|</td>
</tr>
<tr>
<td></td>
<td>存储对象</td>
<td>Volume、PersistentVolume、Secret、ConfigMap|</td>
</tr>
<tr>
<td></td>
<td>策略对象</td>
<td>SecurityContext、ResourceQuota、LimitRange|</td>
</tr>
<tr>
<td></td>
<td>身份对象</td>
<td>ServiceAccount、Role、ClusterRole|</td>
</tr>
</tbody>
</table>


<h4>1.核心概念</h4>

<h5>Pod</h5>

<blockquote><p>Pod是在Kubernetes集群中运行部署应用或服务的最小单元，它是可以支持多容器的。Pod的设计理念是支持多个容器在一个Pod中共享网络地址和文件系统，可以通过进程间通信和文件共享这种简单高效的方式组合完成服务。
目前Kubernetes中的业务主要可以分为长期伺服型（long-running）、批处理型（batch）、后台支撑型（node-daemon）和有状态应用型（stateful application）；分别对应的控制器为Deployment、Job、DaemonSet和StatefulSet，</p></blockquote>

<h5>部署（Deployment）</h5>

<blockquote><p>部署表示用户对Kubernetes集群的一次更新操作。部署是一个比RS应用模式更广的API对象，可以是创建一个新的服务，更新一个新的服务，也可以是滚动升级一个服务。滚动升级一个服务，实际是创建一个新的RS，然后逐渐将新RS中副本数增加到理想状态。以Kubernetes的发展方向，未来对所有长期伺服型的的业务的管理，都会通过Deployment来管理。</p></blockquote>

<h5>服务（Service）</h5>

<blockquote><p>RC、RS和Deployment只是保证了支撑服务的微服务Pod的数量，但是没有解决如何访问这些服务的问题。一个Pod只是一个运行服务的实例，随时可能在不同节点上停止或者启动，因此不能确定其IP和端口号提供服务。那谁来稳定地提供<code>服务发现</code>和<code>负载均衡</code>的能力呢？在K8集群中，客户端要访问的服务就是Service对象。
每个Service会对应一个集群内部有效的虚拟IP，集群内部通过虚拟IP访问服务。
在K8集群中微服务的负载均衡是由Kube-proxy实现的。Kube-proxy是Kubernetes集群内部的负载均衡器。它是一个分布式代理服务器，在Kubernetes的每个节点上都有一个。这一设计体现了它的伸缩性优势，需要访问服务的节点越多，提供负载均衡能力的Kube-proxy就越多，高可用节点也随之增多。</p></blockquote>

<h5>节点（Node）</h5>

<blockquote><p>Kubernetes集群中的计算能力由Node提供，最初Node称为服务节点Minion，后来改名为Node。Kubernetes集群中的Node也就等同于Mesos集群中的Slave节点，是所有Pod运行所在的工作主机，可以是物理机也可以是虚拟机。不论是物理机还是虚拟机，工作主机的统一特征是上面要运行kubelet管理节点上运行的容器。</p></blockquote>

<h5>命名空间（Namespace）</h5>

<blockquote><p>命名空间为Kubernetes集群提供虚拟的隔离作用，Kubernetes集群初始有两个命名空间，分别是默认命名空间default和系统命名空间kube-system，除此以外，管理员可以可以创建新的命名空间满足需要。</p></blockquote>

<h5>任务(Job)</h5>

<blockquote><p>Job是Kubernetes用来控制批处理型任务的API对象。批处理业务与长期伺服业务的主要区别是批处理业务的运行有头有尾，而长期伺服业务在用户不停止的情况下永远运行。Job管理的Pod把任务成功完成就自动退出了。成功完成的标志根据不同的spec.completions策略而不同：单Pod型任务有一个Pod成功就标志完成；多任务的成功保证有N个任务全部执行成功；工作队列型任务根据应用确认的全局成功而标志成功。</p></blockquote>

<h4>2.管理与支撑概念</h4>

<h5>API</h5>

<blockquote><p>API对象是Kubernetes集群中的管理操作单元。Kubernetes集群系统每支持一项新功能，引入一项新概念，一定会新引入对应的API对象，支持对该功能的管理操作。例如副本集Replica Set对应的API对象是RS。
每个API对象都有3大类属性：元数据metadata、规范spec和状态status</p></blockquote>

<h5>副本控制器（Replication Controller，RC）</h5>

<blockquote><p>RC是Kubernetes集群中最早的保证Pod高可用的API对象。通过监控运行中的Pod来保证集群中运行指定数目的Pod副本。</p></blockquote>

<h5>副本集（Replica Set，RS)</h5>

<blockquote><p>RS是新一代RC，提供同样的高可用能力，区别主要在于RS后来居上，能支持更多种类的匹配模式。副本集对象一般不单独使用，而是作为Deployment的理想状态参数使用。</p></blockquote>

<h5>后台支撑服务集（DaemonSet）</h5>

<blockquote><p>长期伺服型和批处理型服务的核心在业务应用，可能有些节点运行多个同类业务的Pod，有些节点上又没有这类Pod运行；而后台支撑型服务的核心关注点在Kubernetes集群中的节点（物理机或虚拟机），要保证每个节点上都有一个此类Pod运行。节点可能是所有集群节点也可能是通过nodeSelector选定的一些特定节点。典型的后台支撑型服务包括，存储，日志和监控等在每个节点上支持Kubernetes集群运行的服务。</p></blockquote>

<h5>有状态服务集（StatefulSet）</h5>

<blockquote><p>在云原生应用的体系里，有下面两组近义词；第一组是无状态（stateless）、牲畜（cattle）、无名（nameless）、可丢弃（disposable）；第二组是有状态（stateful）、宠物（pet）、有名（having name）、不可丢弃（non-disposable）
RC和RS主要是控制提供无状态服务的，其所控制的Pod的名字是随机设置的，一个Pod出故障了就被丢弃掉，在另一个地方重启一个新的Pod，名字变了和启动在哪儿都不重要，重要的只是Pod总数；而StatefulSet是用来控制有状态服务，StatefulSet中的每个Pod的名字都是事先确定的，不能更改。
对于RC和RS中的Pod，一般不挂载存储或者挂载共享存储，保存的是所有Pod共享的状态，Pod像牲畜一样没有分别（这似乎也确实意味着失去了人性特征）；对于StatefulSet中的Pod，每个Pod挂载自己独立的存储，如果一个Pod出现故障，从其他节点启动一个同样名字的Pod，要挂载上原来Pod的存储继续以它的状态提供服务。
适合于StatefulSet的业务包括数据库服务MySQL和PostgreSQL，集群化管理服务ZooKeeper、etcd等有状态服务。使用StatefulSet，Pod仍然可以通过漂移到不同节点提供高可用，而存储也可以通过外挂的存储来提供高可靠性，StatefulSet做的只是将确定的Pod与确定的存储关联起来保证状态的连续性。</p></blockquote>

<h5>集群联邦（Federation）</h5>

<blockquote><p>在云计算环境中，服务的作用距离范围从近到远一般可以有：同主机（Host，Node）、跨主机同可用区（Available Zone）、跨可用区同地区（Region）、跨地区同服务商（Cloud Service Provider）、跨云平台。Kubernetes的设计定位是单一集群在同一个地域内，因为同一个地区的网络性能才能满足Kubernetes的调度和计算存储连接要求。而联合集群服务就是为提供跨Region跨服务商Kubernetes集群服务而设计的。
每个Kubernetes Federation有自己的分布式存储、API Server和Controller Manager。用户可以通过Federation的API Server注册该Federation的成员Kubernetes Cluster。当用户通过Federation的API Server创建、更改API对象时，Federation API Server会在自己所有注册的子Kubernetes Cluster都创建一份对应的API对象。在提供业务请求服务时，Kubernetes Federation会先在自己的各个子Cluster之间做负载均衡，而对于发送到某个具体Kubernetes Cluster的业务请求，会依照这个Kubernetes Cluster独立提供服务时一样的调度模式去做Kubernetes Cluster内部的负载均衡。而Cluster之间的负载均衡是通过域名服务的负载均衡来实现的。</p></blockquote>

<h4>3.用户与权限概念</h4>

<h5>用户帐户（User Account）</h5>

<blockquote><p>用户帐户为人提供账户标识，对应的是人的身份，人的身份与服务的namespace无关，所以用户账户是跨namespace的</p></blockquote>

<h5>服务帐户（Service Account）</h5>

<blockquote><p>服务账户为计算机进程和Kubernetes集群中运行的Pod提供账户标识。服务帐户对应的是一个运行中程序的身份，与特定namespace是相关的。</p></blockquote>

<h5>密钥对象（Secret）</h5>

<blockquote><p>Secret是用来保存和传递密码、密钥、认证凭证这些敏感信息的对象。为了避免将类似的敏感信息明文写在配置文件中，可以将其存入一个Secret对象，并在配置文件中通过Secret对象引用这些敏感信息</p></blockquote>

<h5>RBAC访问授权</h5>

<blockquote><p>RBAC主要是引入了角色（Role）以及与角色绑定（RoleBinding）的相关抽象概念。</p></blockquote>

<h3>参考资料</h3>

<p><a href="https://infoq.cn/article/kubernetes-and-cloud-native-applications-part01">《Kubernetes 与云原生应用》系列之 Kubernetes 的系统架构与设计理念</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[K8s核心架构]]></title>
    <link href="http://wldandan.github.com/blog/2019/03/14/k8s-architecture/"/>
    <updated>2019-03-14T23:45:00+08:00</updated>
    <id>http://wldandan.github.com/blog/2019/03/14/k8s-architecture</id>
    <content type="html"><![CDATA[<p>Kubernetes主要由以下几个核心组件组成：</p>

<ul>
<li>etcd保存了整个集群的状态；</li>
<li>apiserver提供了资源操作的唯一入口，并提供认证、授权、访问控制、API注册和发现等机制；</li>
<li>controller manager负责维护集群的状态，比如故障检测、自动扩展、滚动更新等；</li>
<li>scheduler负责资源的调度，按照预定的调度策略将Pod调度到相应的机器上；</li>
<li>kubelet负责维护容器的生命周期，同时也负责Volume（CSI）和网络（CNI）的管理；</li>
<li>Container runtime负责镜像管理以及Pod和容器的真正运行（CRI）；</li>
<li>kube-proxy负责为Service提供cluster内部的服务发现和负载均衡；</li>
</ul>


<!-- More -->


<p>除了核心组件，还有一些推荐的插件，其中有的已经成为CNCF中的托管项目：</p>

<ul>
<li>CoreDNS负责为整个集群提供DNS服务</li>
<li>Ingress Controller为服务提供外网入口</li>
<li>Prometheus提供资源监控</li>
<li>Dashboard提供GUI</li>
<li>Federation提供跨可用区的集群</li>
</ul>


<h3>K8s整体架构</h3>

<p><img src="http://wldandan.github.com/images/k8s/kubernetes-whole-arch.png" /></p>

<h5>K8s-Master架构图</h5>

<p><img src="http://wldandan.github.com/images/k8s/kubernetes-master-arch.png" /></p>

<h5>K8s-Node架构图</h5>

<p><img src="http://wldandan.github.com/images/k8s/kubernetes-node-arch.png" /></p>

<h3>K8s分层架构</h3>

<p><img src="http://wldandan.github.com/images/k8s/kubernetes-layers-arch.png" /></p>

<h3>K8s简化图</h3>

<p><img src="http://wldandan.github.com/images/k8s/k8s-control-plane.jpg" /></p>

<ul>
<li>核心层：Kubernetes最核心的功能，对外提供API构建高层的应用，对内提供插件式应用执行环境</li>
<li>应用层：部署（无状态应用、有状态应用、批处理任务、集群应用等）和路由（服务发现、DNS解析等）、Service Mesh（部分位于应用层）</li>
<li>管理层：系统度量（如基础设施、容器和网络的度量），自动化（如自动扩展、动态Provision等）以及策略管理（RBAC、Quota、PSP、NetworkPolicy等）、Service Mesh（部分位于管理层）</li>
<li>接口层：kubectl命令行工具、客户端SDK以及集群联邦</li>
<li><p>生态系统：在接口层之上的庞大容器集群管理调度的生态系统，可以划分为两个范畴</p>

<ul>
<li><p>Kubernetes外部：日志、监控、配置管理、CI/CD、Workflow、FaaS、OTS应用、ChatOps、GitOps、SecOps等</p></li>
<li><p>Kubernetes内部：CRI、CNI、CSI、镜像仓库、Cloud Provider、集群自身的配置和管理等</p></li>
</ul>
</li>
</ul>


<blockquote><p>关于分层架构，可以关注下Kubernetes社区正在推进的<a href="https://docs.google.com/document/d/1XkjVm4bOeiVkj-Xt1LgoGiqWsBfNozJ51dyI-ljzt1o">Kubernetes architectual roadmap</a>和<a href="https://docs.google.com/presentation/d/1GpELyzXOGEPY0Y1ft26yMNV19ROKt8eMN67vDSSHglk/edit">slide</a>。</p></blockquote>

<h3>参考资料</h3>

<p><a href="http://queue.acm.org/detail.cfm?id=2898444">Borg, Omega, and Kubernetes - Lessons learned from three container-management systems over a decade</a></p>

<p><a href="http://static.googleusercontent.com/media/research.google.com/zh-CN//pubs/archive/43438.pdf">Paper - Large-scale cluster management at Google with Borg</a></p>

<p><a href="http://thenewstack.io/kubernetes-an-overview">KUBERNETES: AN OVERVIEW</a></p>

<p><a href="https://docs.google.com/document/d/1XkjVm4bOeiVkj-Xt1LgoGiqWsBfNozJ51dyI-ljzt1o">Kubernetes architectual roadmap</a>和<a href="https://docs.google.com/presentation/d/1GpELyzXOGEPY0Y1ft26yMNV19ROKt8eMN67vDSSHglk/edit">slide</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[微服务实战系列(5) - HAL 101]]></title>
    <link href="http://wldandan.github.com/blog/2016/11/08/microservices-in-action-rest-hal/"/>
    <updated>2016-11-08T23:45:00+08:00</updated>
    <id>http://wldandan.github.com/blog/2016/11/08/microservices-in-action-rest-hal</id>
    <content type="html"><![CDATA[<p>[如需转载，请联系本人]</p>

<p>过去的几个月，我作为独立咨询师，为多个传统企业提供了微服务架构的培训、咨询以及交付工作。实际上，传统企业在过去多年的业务积累中，由于组织架构、业务发展和市场竞争等综合因素，技术体系相对封闭，缺乏快速交付的理念。因此，微服务的出现，加之社区的热捧，导致很多传统的团队过于追热而并没有完全理解微服务。</p>

<p>经过2015年的快速普及，微服务的优势被越来越多的传统组织和企业所认可，但由于架构相关的知识本身比较抽象，虽然各大会议上有很多互联网公司的案例分享，但开发者似乎依然很难全面了解微服务架构。</p>

<p>所以，希望通过本系列的文章以及视频，以一个真实的案例为背景，以持续交付和DevOps为主线，帮助初学者理解微服务架构，并能通过动手实验，了解相关的实践以及方法论。</p>

<p>精彩课程已经出炉，请移步<a href="http://www.stuq.org/course/detail/1088">这里</a></p>

<!-- More -->


<h3>综述</h3>

<p>REST API通常作为服务间协作的轻量级通信协议(语言无关、平台无关)，被微服务架构广泛采用。</p>

<p>在微服务架构的中，如何有效的设计REST API，如何处理API响应中资源的依赖关系，服务规模化后如何提高服务团队间的协作效率&#8230;..这些都成为微服务实践中API设计面临的挑战。</p>

<p>本篇将介绍REST、REST成熟度模型、为什么使用HAL以及HAL的核心。</p>

<h3>REST 101</h3>

<p>REST（Representational State Transfer，表述性状态传递）是近几年使用广泛的架构风格之一。在微服务架构的实践中，REST经常作为服务间协作的轻量级通信协议(语言无关、平台无关)被采用。</p>

<p><img src="http://wldandan.github.com/images/microservice-in-action-with-spring/rest-hal/rest-core-600-450.png" /></p>

<p>REST从语义层面将响应结果定义为资源，并使用HTTP协议的标准动词映射为对资源的操作，形成了一种以资源为核心、以HTTP协议为操作方式的，与语言无关、平台无关的服务间的通信机制。</p>

<p>通过资源表述、状态转移以及统一接口，REST将客户端的请求、服务器端的响应基于资源联系起来，形成一种以资源为核心、以HTTP协议为操作方式的，与语言无关、平台无关的通信机制。</p>

<p>同时，由于HTTP协议本身的无状态性，使用REST，能够有效保持服务应用的无状态型，并利于水平伸缩。</p>

<h3>REST 成熟度模型</h3>

<p>REST成熟度模型描述了REST在实施过程中不同的级别。</p>

<p><img src="http://wldandan.github.com/images/microservice-in-action-with-spring/rest-hal/rest-maturity-model-600-450.png" /></p>

<h3>REST不是银弹</h3>

<p>随着组织业务的不断增长，服务规模化的实施，以及响应内容复杂度的增加，REST的使用面临如下两个挑战：</p>

<ul>
<li>如何标准化资源结构</li>
</ul>


<p>使用REST，需要将业务场景的响应抽象为资源，并基于JSON或者XML的格式，返回给客户端。随着业务复杂度的增加，响应的内容会愈发复杂。</p>

<p>REST架构风格，并没有定义响应结构应该遵循什么标准。这也就意味着，在企业内部，不同的部门，不同的开发团队，对同一类资源，所定义的结构可能不尽相同；</p>

<p>譬如，如下是服务器端对客户端获取产品请求的的响应结果，两种结构都是合理的，但存在着差异</p>

<pre><code>GET http://bookstore.com/books/12 
Accept: application/json
</code></pre>

<hr />

<pre><code>响应结构一
{  
    "name":"Spring Boot In Action",  
    "category": "Book",  
    "price":69.00,  
    "ref": "http://bookstore.com/books/12",
    "created_at": "2015-05-01 10:00:00",
    "updated_at": "2015-06-01 11:00:00"
}  
</code></pre>

<hr />

<pre><code>响应结构二
{
  "basic_info":
  {
    "name":"Spring Boot In Action",
    "category":"Book"
    "price":69.00,
  },

  "ref":{
    "self": "http://bookstore.com/books/12”,
    “list": "http://bookstore.com/books"
  },

  "timestamp":{
    "created_at": "2015-05-01 10:00:00",
    "updated_at": "2015-06-01 11:00:00"
  }
}
</code></pre>

<p>因此，如何定义一套标准的资源响应结构，成为服务规模化后使用REST面临的一个挑战。</p>

<ul>
<li>如何处理资源的跳转链接</li>
</ul>


<p>在<a href="http://martinfowler.com/articles/richardsonMaturityModel.html">《Richardson Maturity Model》</a>模型中，定义了REST API不同成熟度应该具备的特征。</p>

<p>对于REST API Level 3，明确提出了&#8221;资源跳转的重要性&#8221;，即<code>HATEOAS</code>。</p>

<p>对于实际情况而言，大部分REST的实现，都是基于JSON作为传输格式，不过JSON最大的遗憾，正如W3C所描述的：</p>

<blockquote><p>JSON has no built-in support for hyperlinks, which are a fundamental building block on the Web.</p>

<p>没有对超链接处理做内建的支持，是JSON最大的遗憾。而这部分却恰恰是互联网的基石。</p></blockquote>

<p>这带来的潜在问题是，对于调用接口的Consumer而言，需要通过查看相关文档，才能了解如何获取相关的资源信息。譬如，某些社交系统可能会提供类似如下的接口文档，来帮助Consumer了解如何使用其提供的接口。</p>

<pre><code>https://api.example.com/users/1234567890      GET 获取用户明细
https://api.example.com/users/[ID]/friends    GET 获取用户相关的好友
https://api.example.com/users/[ID]/posts      GET 获取用户相关的文章
</code></pre>

<h3>HAL 101</h3>

<p>HAL（Hypertext Application Language）是一种轻量级超文本应用描述协议。HAL的实现基于REST，并对REST中资源结构无法标准化和不支持资源间跳转链接做了有效的互补。</p>

<p>目前，越来越多的企业和组织开始使用HAL提供标准化的服务接口，譬如</p>

<ul>
<li><p><a href="http://docs.aws.amazon.com/appstream/latest/developerguide/rest-api-application.html">AWS APP Stream API</a></p></li>
<li><p><a href="https://smxemail.com">SMXEmail API</a></p></li>
<li><p><a href="http://api.m.ox.ac.uk/browser/#/">牛津大学官方数据API</a></p></li>
</ul>


<p>更多案例请可以参考<a href="http://stateless.co/hal_specification.html">HAL官方网站</a>。</p>

<h3>HAL的核心</h3>

<p>在HAL中，任何响应都被定义成一种资源（Resource），这是遵循REST原则对资源的定义标准。
同REST不同的是，在每个资源中，HAL又将其分成了如下三个标准的部分：</p>

<ul>
<li>状态(Resource State) - 通常指资源本身固有的属性，如之前提到的book的title、price等</li>
<li>链接(Links) - 定义了与当前资源相关的资源链接的集合</li>
<li>子资源(Embedded Resource) - 描述在当前资源的内部，其嵌套的资源。</li>
</ul>


<p><img src="http://wldandan.github.com/images/microservice-design-and-practice/rest-api-design/hal-model-400-300.png" /></p>

<h4>使用HAL定义单一资源(Resource)</h4>

<p>对于单一资源而言，如果没有使用HAL，通常我们会定义成这样：</p>

<pre><code>GET - /api/users/wldandan
Content-Type: application/json

{
    "id": "wldandan",
    "name": "Wang Lei",
    "email": "useremail@email.com",
    "wechat": "abcdefg"
}   
</code></pre>

<p>如果要访问用户相关的联系人资源，则可能需要查看文档获取相应的API接口，或者将相关信息放在之前返回的结果里：</p>

<pre><code>{
    "id": "wldandan",
    "name": "Wang Lei",
    "email": "useremail@email.com",
    "wechat": "abcdefg",
    "contacts": [
        {
            "id": "chenyue",
            "name": "Chen Yue"
            "link": "/api/users/chenyue"
        },
        {
            "id": "kouxi",
            "name": "Kou Xi"
            "link": "/api/users/chenyue"
        }
    ]
}   
</code></pre>

<p>如果基于HAL，则可以使用<code>_links</code>描述相关链接，同时使用<code>_embedded</code>描述嵌套资源，类似如下：</p>

<pre><code>{
    "_links": {
        "self": {
            "href": "http://example.org/api/users/wldandan"
        }
    },
    "id": "wldandan",
    email: 'useremail@email.com',
    "name": "Wang Lei"
    wechat: 'abcdefg',

    "_embedded": {
        "contacts": [
        {
            "_links": {
                "self": {
                    "href": "http://example.org/api/users/chenyue"
                }
            },
            "id": "chenyue",
            "name": "Chen Yue"
        },
        {
            "_links": {
                "self": {
                    "href": "http://example.org/api/users/kouxi"
                }
            },
            "id": "kouxi",
            "name": "Kou Xi"
        }
        ]
    }
}
</code></pre>

<h4>使用HAL定义集合资源(Collection Resource)</h4>

<p>对于集合资源而言，如果没有使用HAL，通常我们会定义成这样：</p>

<pre><code>GET - /api/users
Content-Type: application/json

{
    total: 10
    page: 5
    page_size: 2
    users: [
    {
        id: 'wldandan',
        name: 'Wang Lei'
    },
    {
        id: 'chenyue',
        name: 'Chen Yue'
    },
    ]
}
</code></pre>

<p>基于HAL，则使用<code>_links</code>描述相关链接，同时使用<code>_embedded</code>描述嵌套资源，类似则如下所示：</p>

<pre><code>{
    "_links": {
        "self": {
            "href": "http://example.org/api/users?page=3"
        },
        "first": {
            "href": "http://example.org/api/users"
        },
        "prev": {
            "href": "http://example.org/api/users?page=2"
        },
        "next": {
            "href": "http://example.org/api/users?page=4"
        },
        "last": {
            "href": "http://example.org/api/users?page=5"
        }
    },
    "page_size": 2,
    "total": 10,
    "page": 5,
    "_embedded": {
        "users": [
            {
                "_links": {
                    "self": {
                        "href": "http://example.org/api/users/wldandan"
                    }
                },
                "id": "wldandan",
                "name": "Wang Lei"
            },
            {
                "_links": {
                    "self": {
                        "href": "http://example.org/api/user/chenyue"
                    }
                },
                "id": "chenyue",
                "name": "Chen Yue"
            }
        ]
    }
}
</code></pre>

<blockquote><p>所以，HAL的最大价值，帮助我们标准化定义了Resource的结构，并同时实现了HATEOAS。</p></blockquote>

<p>关于课程更多内容，请看<a href="http://www.stuq.org/course/detail/1088">这里</a></p>

<h3>参考资料</h3>

<p><a href="https://apigility.org/documentation/api-primer/halprimer">Hypertext Application Language</a></p>

<p><a href="http://blog.stateless.co/post/13296666138/json-linking-with-hal">JSON Linking with HAL</a></p>

<p><a href="Creating%20Service%20Contract%20with%20AutoRest,%20Swagger%20and%20HAL">Creating Service Contract with AutoRest, Swagger and HAL</a></p>

<p><a href="https://opencredo.com/hal-hypermedia-api-spring-hateoas/">Implementing HAL hypermedia REST API using Spring HATEOAS</a></p>

<p><a href="http://stateless.co/hal_specification.html">HAL Specification</a></p>

<p><a href="https://groups.google.com/forum/#!forum/hal-discuss">hal-discuss@google groups</a></p>

<p><a href="http://hyperschema.org/mediatypes/hal">HAL+JSON</a></p>

<p><a href="https://opencredo.com/rest-api-tooling-review/">Documenting REST APIs – a tooling review</a></p>

<p><a href="http://phlyrestfully.readthedocs.io/en/latest/halprimer.html">HAL Primer</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[微服务实战(4) - Spring Cloud 101]]></title>
    <link href="http://wldandan.github.com/blog/2016/11/07/microservices-in-action-spring-cloud-101/"/>
    <updated>2016-11-07T23:37:00+08:00</updated>
    <id>http://wldandan.github.com/blog/2016/11/07/microservices-in-action-spring-cloud-101</id>
    <content type="html"><![CDATA[<p>[如需转载，请联系本人]</p>

<p>过去的几个月，我作为独立咨询师，为多个传统企业提供了微服务架构的培训、咨询以及交付工作。实际上，传统企业在过去多年的业务积累中，由于组织架构、业务发展和市场竞争等综合因素，技术体系相对封闭，缺乏快速交付的理念。因此，微服务的出现，加之社区的热捧，导致很多传统的团队过于追热而并没有完全理解微服务。</p>

<p>经过2015年的快速普及，微服务的优势被越来越多的传统组织和企业所认可，但由于架构相关的知识本身比较抽象，虽然各大会议上有很多互联网公司的案例分享，但开发者似乎依然很难全面了解微服务架构。</p>

<p>所以，希望通过本系列的文章以及视频，以一个真实的案例为背景，以持续交付和DevOps为主线，帮助初学者理解微服务架构，并能通过动手实验，了解相关的实践以及方法论。</p>

<p>精彩课程已经出炉，请移步<a href="http://www.stuq.org/course/detail/1088">这里</a></p>

<!-- More -->


<h2>服务实施的挑战</h2>

<h3>个体服务的实现越来越容易</h3>

<p>在上一节中，我们学习了Spring Boot的核心，明白了<code>Starter</code>与<code>AutoConfiguration</code>的重要性，并知道了如何快速创建Spring Boot应用。</p>

<p>基于现有的<code>Spring Framework</code>，以及<code>Spring Boot的Starter</code>，加上<code>官方CLI</code>、 <code>Initializr</code>以及各种<code>IDE</code>提供的快速创建SpringBoot 应用的方式，我们能轻松的完成一个基于RESTful API的服务实现。</p>

<p>因此，从Spring Boot的优势来看，构建单个的服务单元非常容易了~</p>

<blockquote><p>从IT社区的发展来看，工具正在变得越来越强大，开发人员的大部分重复性工作都将会被简化。</p>

<p>伴随着人工智能的快速发展，将来编码的工作都可以交给机器了，喝着咖啡告诉它，你想要什么语言，你的验收条件，啦啦啦&#8230;.</p></blockquote>

<h3>但服务间的协作、管理成本越来越高</h3>

<p>但是，对于微服务的实施而言，服务单元不会孤立存在，必然相互协作，共同实现业务价值。</p>

<p><img src="http://wldandan.github.com/images/microservice-in-action-with-spring/spring-boot/microservice-coordination-600-450.png" /></p>

<p>而随着服务规模化的推进，服务间协作和管理的成本会越来越高，包括但不限于：</p>

<ul>
<li>服务地址发生变化

<ul>
<li>服务结点数量动态变化(水平伸缩)</li>
<li>服务结点地址动态变化(重启、升级)</li>
</ul>
</li>
<li>服务的配置信息变更

<ul>
<li>配置信息修改后，如何动态更新单实例</li>
<li>配置信息修改后，如何同步多个实例</li>
<li>配置信息的追溯、回滚及可用性保障</li>
</ul>
</li>
<li>服务间调用出现异常

<ul>
<li>如何防止调用间的”雪崩”</li>
</ul>
</li>
<li>为消费者提供统一接口

<ul>
<li>如何提供单一的入口简化设备的调用</li>
<li>屏蔽不同的应用协议(MQ/JMS)</li>
</ul>
</li>
</ul>


<p>所以，如何应对如上这些问题，成为微服务实施中重要的环节。</p>

<h2>什么是Spring Cloud</h2>

<p><code>Spring Cloud</code>是Pivotal官方提供的旨在帮助开发者降低构建复杂分布式系统的工具集。</p>

<p>2015年3月4日，Spring Cloud发布了第一个GA版本。</p>

<p>Spring Cloud的核心宗旨是：</p>

<blockquote><p>A toolset designed for building complexed distributed systems.</p></blockquote>

<p>在Spring Cloud中，整合了很多功能组件，包括Config、Messaging、Netflix OSS以及对Heroku、Amazon Web Service、Cloud Foundry等云平台的接口支持。</p>

<p><img src="http://wldandan.github.com/images/microservice-in-action-with-spring/spring-boot/spring-cloud-components-600-450.png" /></p>

<p>基于这些组件，能够帮助我们解决之前提到的服务实施后面临的挑战。</p>

<h2>常用的Spring Cloud组件</h2>

<p>Spring Cloud中的组件很多，而且在快速的演进中，在本系列<code>服务构建篇</code>里，主要涉及的有</p>

<blockquote><p>Spring Cloud Netflix</p></blockquote>

<p>集成了Netflix OSS的组件(Eureka/Ribbon/Hystrix/Zuul等)</p>

<blockquote><p>Spring Cloud Config</p></blockquote>

<p>提供集中化的服务配置信息，动态更新实例的配置</p>

<blockquote><p>Spring Cloud Bus</p></blockquote>

<p>使用分布式消息机制，提供不同服务实例之间的协作</p>

<blockquote><p>Spring Cloud Security</p></blockquote>

<p>提供服务安全相关的实现机制(OAuth2)</p>

<h2>总结</h2>

<blockquote><p>Spring Cloud本着<code>全家桶</code>的一站式解决方案，为微服务的实施提供了支持。</p>

<p>虽然Spring Cloud GA的时间并不长，但其快速的演进以及大量社区用户的支持，已成为Java领域微服务架构实施的利器，帮助我们有效的应对服务实践时的构建支撑组件的挑战。</p>

<p>后续我们将使用Spring Cloud构建本案例服务的支撑组件。</p>

<p>关于课程，请看<a href="http://www.stuq.org/course/detail/1088">这里</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[微服务实战(3) - Spring Boot 101]]></title>
    <link href="http://wldandan.github.com/blog/2016/11/06/microservices-in-action-spring-boot-101/"/>
    <updated>2016-11-06T17:57:00+08:00</updated>
    <id>http://wldandan.github.com/blog/2016/11/06/microservices-in-action-spring-boot-101</id>
    <content type="html"><![CDATA[<p>[如需转载，请联系本人]</p>

<p>过去的几个月，我作为独立咨询师，为多个传统企业提供了微服务架构的培训、咨询以及交付工作。实际上，传统企业在过去多年的业务积累中，由于组织架构、业务发展和市场竞争等综合因素，技术体系相对封闭，缺乏快速交付的理念。因此，微服务的出现，加之社区的热捧，导致很多传统的团队过于追热而并没有完全理解微服务。</p>

<p>经过2015年的快速普及，微服务的优势被越来越多的传统组织和企业所认可，但由于架构相关的知识本身比较抽象，虽然各大会议上有很多互联网公司的案例分享，但开发者似乎依然很难全面了解微服务架构。</p>

<p>所以，希望通过本系列的文章以及视频，以一个真实的案例为背景，以持续交付和DevOps为主线，帮助初学者理解微服务架构，并能通过动手实验，了解相关的实践以及方法论。</p>

<p>精彩课程已经出炉，请移步<a href="http://www.stuq.org/course/detail/1088">这里</a></p>

<!-- More -->


<h2>为什么是Spring Boot</h2>

<p>在Java开发领域，估计没有多少兄弟不知道Spring，当年的SSH组合，风靡社区，几乎成为J2EE 程序开发的标配。</p>

<p>另外，Spring对诸多企业特性的强大支持，为构建Java的企业应用提供了<code>全家桶</code>的解决方案。</p>

<p><img src="http://wldandan.github.com/images/microservice-in-action-with-spring/spring-boot/spring-io-600-450.png" /></p>

<p>对于现代Java开发，尤其是以微服务为主的应用，虽然有<a href="https://dropwizard.github.io/">DropWizard</a>、<a href="https://ee.kumuluz.com/">KumuluzEE</a>等微服务框架的诞生，但Spring Boot借助极致的<code>Convention Over Configuration</code>，加上对<code>Spring Framework</code>的无缝支持，被社区普遍看好。</p>

<p>在今年10月中旬结束的<a href="https://jaxlondon.com/jax-awards/">2016 JAX Java Innovation</a>评选中，Spring Boot一举拔得头筹，而去年Java领域的这个奖项是颁给了著名的<a href="https://netflix.github.io/">Netflix OSS</a>，足以证明Spring Boot在社区的影响力。</p>

<p><img src="http://wldandan.github.com/images/microservice-in-action-with-spring/spring-boot/jax-award-spring-boot-600-450.png" /></p>

<h2>Spring Boot的优势</h2>

<ul>
<li><code>快速构建</code>可运行的应用

<ul>
<li><code>无XML配置</code></li>
<li>支持<code>内嵌</code>WebServer(Tomcat/Jetty/Undertow)</li>
<li>通过<code>注解</code>的方式，一行代码启动应用</li>
</ul>
</li>
<li><code>自动配置</code>和<code>装载机制</code>

<ul>
<li>使用Starter</li>
<li>自动配置装载依赖</li>
</ul>
</li>
<li>运维接口友好

<ul>
<li><code>Metrics/health</code>显示健康监控状态</li>
<li><code>Trace/dump</code>显示调用/调试信息</li>
</ul>
</li>
</ul>


<h2>Spring Boot核心</h2>

<h3>简单的说，Spring Boot的核心，主要包括两大部分：</h3>

<blockquote><p>1.Starter</p></blockquote>

<p>Starter负责将申明的依赖Jar包导入到当前ClassPath。</p>

<p>每个Starter都提供一个<code>spring.providers文件</code>，申明当前Starter依赖的Jar包。</p>

<p>譬如，<code>Spring-boot-starter-web</code>中的<code>spring.providers文件</code>描述的依赖如下所示：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>provides: spring-webmvc,spring-web,jackson-databind</span></code></pre></td></tr></table></div></figure>


<p>包括<code>spring-webmvc</code>，<code>spring-web</code>，<code>jackson-databind</code>，分别提供mvc，web和JSON解析绑定的功能。</p>

<p>欲了解更多的Starter，请移步<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-starters">官方列表</a></p>

<blockquote><p>2.AutoConfiguratioin</p></blockquote>

<p>AutoConfiguratioin根据<code>ConditionalOnXxx</code>条件，使用<code>@Bean</code>注解，完成对Bean的创建和组装。</p>

<p>根据不同的<code>ConditionalOnXxx</code>，AutoConfiguration可以根据合适的场景创建并组装Bean。</p>

<p>譬如</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ConditionalOnMissingBean(A.class)</span></code></pre></td></tr></table></div></figure>


<blockquote><p>表示当前指定的A实例不存在，才创建@Bean.</p></blockquote>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ConditionalOnWebApplication</span></code></pre></td></tr></table></div></figure>


<blockquote><p>表示当前是在Web Application才创建@Bean</p></blockquote>

<p>Java Web中我们经常使用<code>HttpEncodingAutoConfiguration</code>，完成UTF8的转码。如下是SpringBoot中，HttpEncodingAutoConfiguration的部分实现：</p>

<blockquote><p>仅当ApplicationContext中没有CharacterEncodingFilter的时候，才会创建<code>CharacterEncodingFilter</code></p></blockquote>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@Bean
</span><span class='line'>@ConditionalOnMissingBean(CharacterEncodingFilter.class)
</span><span class='line'>public CharacterEncodingFilter characterEncodingFilter() {
</span><span class='line'>  CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter();
</span><span class='line'>  filter.setEncoding(this.properties.getCharset().name());
</span><span class='line'>  filter.setForceRequestEncoding(this.properties.shouldForce(Type.REQUEST));
</span><span class='line'>  filter.setForceResponseEncoding(this.properties.shouldForce(Type.RESPONSE));
</span><span class='line'>  return filter;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<blockquote><p>所以, 我对SpringBoot的理解为，如下两个核心点(配合起来，天下无敌&#8230;.)</p></blockquote>

<ul>
<li><code>Starter打包提供相关的包依赖，加载到ClassPath</code></li>
<li><code>EnableAutoConfiguration借助ConditionalOnXxx条件，创建并配置Bean的依赖关系</code></li>
</ul>


<p>关于更多<code>Conditional</code>的细节，请查看包
<em>org.springframework.boot.autoconfigure.condition</em>中的具体实现，其列表如下图所示：</p>

<p><img src="http://wldandan.github.com/images/microservice-in-action-with-spring/spring-boot/spring-boot-conditional-xxx-600-450.png" /></p>

<h3>另外，每个SpringBoot应用上都会加标签@SpringBootApplication</h3>

<p>这个标签是SpringBoot应用的核心标签，主要包括三部分子：</p>

<ul>
<li>@Configuration</li>
</ul>


<p>Spring3.0引入@Configuration(Java配置)，使用Java配置简化XML配置。</p>

<p>譬如以前我们通常使用类似如下XML配置Spring Bean</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;beans xmlns="http://www.springframework.org/schema/beans"
</span><span class='line'>  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
</span><span class='line'>  xsi:schemaLocation="http://www.springframework.org/schema/beans
</span><span class='line'>  http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt;
</span><span class='line'>
</span><span class='line'>  &lt;bean id="helloBean" class=“com.microservice.training.HelloWorldImpl"&gt;
</span><span class='line'>&lt;/beans&gt;</span></code></pre></td></tr></table></div></figure>


<p>通过使用Java Configuration，声明当前类是一个配置类， 相当于声明一个Spring配置的XML文件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@Configuration
</span><span class='line'>public class AppConfig {
</span><span class='line'>
</span><span class='line'>    @Bean(name="helloBean")
</span><span class='line'>    public HelloWorld helloWorld() {
</span><span class='line'>        return new HelloWorldImpl();
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ul>
<li>@EnableAutoConfiguration</li>
</ul>


<p>它帮助我们加载当前Spring Boot中META-INF/spring.factories，并使用其中的*AutoConfiguration</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>HttpEncodingAutoConfiguration
</span><span class='line'>RabbitAutoConfiguration 
</span><span class='line'>EmbeddedServletContainerAutoConfiguration
</span><span class='line'>……</span></code></pre></td></tr></table></div></figure>


<p>每个AutoConfiguration都会根据其中的Condition条件，在合适的场景完成对相关Bean的创建</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@ConditionalOnBean //容器里有指定Bean存在
</span><span class='line'>@ConditionalOnClass //类路径下有指定Class存在
</span><span class='line'>@ConditionalOnWebApplication //当前项目是Web项目
</span><span class='line'>……</span></code></pre></td></tr></table></div></figure>


<ul>
<li>@ComponentScan</li>
</ul>


<p>它定义Spring了自动加载Bean的根路径，是Spring Framwork中较早的一个标签，这里就不赘述了。</p>

<h2>快速构建Spring Boot应用</h2>

<p>Spring Boot提供了方便的项目创建方式，使得我们可以快速创建基于SpringBoot的项目：</p>

<ul>
<li>使用<a href="http://sdkman.io/">命令行CLI</a></li>
<li>使用<a href="start.spring.io">Initializr</a></li>
<li>使用IDE(IDEA，Spring Tool Suite等)</li>
</ul>


<h2>总结</h2>

<blockquote><p>本部分介绍了SpringBoot的核心，并提到了快速创建SpringBoot应用的方式，通过这部分内容，能够帮助大家完成<code>SpringBoot从0到1的过程</code> :)</p>

<p>关于课程，请看<a href="http://www.stuq.org/course/detail/1088">这里</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[微服务实战(2) - 目标系统]]></title>
    <link href="http://wldandan.github.com/blog/2016/11/05/microservices-in-action-simulation/"/>
    <updated>2016-11-05T14:28:00+08:00</updated>
    <id>http://wldandan.github.com/blog/2016/11/05/microservices-in-action-simulation</id>
    <content type="html"><![CDATA[<p>[如需转载，请联系本人]</p>

<p>过去的几个月，我作为独立咨询师，为多个传统企业提供了微服务架构的培训、咨询以及交付工作。在这些企业中，大部分的开发者对微服务的理解，以“银弹观念”为主。实际上，传统企业在过去多年的业务积累中，由于组织架构、业务发展和市场竞争等综合因素，技术体系相对封闭，缺乏快速交付的理念。因此，微服务的出现，加之社区的热捧，导致这种现象出现也是比较能理解的。</p>

<p>经过2015年的快速普及，微服务的优势被越来越多的传统组织和企业所认可，但由于架构相关的知识本身比较抽象，虽然各大会议上有很多互联网公司的案例分享，但开发者似乎依然很难全面了解微服务架构。</p>

<p>所以，希望通过本系列的文章，以一个模拟的案例为背景，以持续交付和DevOps为主线，帮助初学者理解微服务架构，并能通过动手实验，了解相关的实践以及方法论。</p>

<p>精彩课程已经出炉，请移步<a href="http://www.stuq.org/course/detail/1088">这里</a></p>

<!-- More -->


<h2>目标系统</h2>

<blockquote><p>构建一个用户查看活动、报名活动、接收通知的系统</p>

<ul>
<li>匿名用户可查看活动列表</li>
<li>匿名用户可以查看活动详情</li>
<li>匿名用户可以查看相关活动推荐和评论</li>
<li>用户登陆成功后完成报名</li>
<li>报名成功，用户获取通知</li>
</ul>
</blockquote>

<h2>服务定义</h2>

<blockquote><p>关于服务的划分，是一个非常有深度的话题，与业务场景、技术实现、团队能力有着密不可分的关系。
从方法论上有：</p>

<ul>
<li>根据<a href="https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215">DDD</a>，包括业务上下文、事件驱动、读写分离等</li>
<li>根据名词类对象，譬如商品、订单等</li>
<li>根据动词类行为，譬如支付，预订等</li>
<li>其他切入点</li>
</ul>


<p>在这个模拟场景中，为了保持简洁，我假定使用名词和动词进行划分，包括如下：</p></blockquote>

<ul>
<li><code>活动服务Event-service</code>(提供活动的列表和活动详情的相关数据）</li>
<li><code>推荐服务Recommendation-service</code>(提供与某个活动相关的推荐信息)</li>
<li><code>评论服务Review-service</code>(提供与某个活动相关的评论信息)</li>
<li><code>活动聚合服务Event-composite-service</code>(聚合服务 - 提供某个活动及其相关的推荐、评论信息</li>
<li><code>报名服务Enroll-service</code>(为登录用户提供报名)</li>
<li><code>通知服务Notification-service</code>(用户报名成功后获取通知)</li>
</ul>


<blockquote><p>该活动报名系统的应用架构图如下：</p></blockquote>

<p><img src="http://wldandan.github.com/images/microservice-in-action-with-spring/events-system-architecture-600-450.png" /></p>

<h2>服务实现</h2>

<ul>
<li>Java 8/Gradle 2.13</li>
<li>SpringBoot 1.4.2 / SpringCloud Camden.SR2</li>
<li>MongoDB 使用Document存储活动数据</li>
<li>REST/HAL/HAL-Browser 定义服务之间通信的接口</li>
<li>JVM-Pact 实现契约测试,服务间接口的测试</li>
</ul>


<h2>服务支撑组件</h2>

<ul>
<li>Netflix OSS Eureka 实现服务注册</li>
<li>Spring Cloud Config 实现服务的配置</li>
<li>Hystrix/Turbine 实现断路器</li>
<li>Zuul 实现API网关</li>
<li>Spring Cloud Security 实现安全</li>
</ul>


<h2>基础设施</h2>

<ul>
<li>ELK 提供服务的日志的聚合服务</li>
<li>Prometheus 提供服务的监控与告警</li>
<li>Jenkins 2.0搭建系统的持续交付流水线</li>
<li>Docker提供服务的打包以及发布</li>
<li>Rancher提供Docker的轻量级管理方案</li>
</ul>


<blockquote><p>该活动报名系统的微服务生态系统图如下：</p></blockquote>

<p><img src="http://wldandan.github.com/images/microservice-in-action-with-spring/microservices-eco-system-adoption-600-450.png" /></p>

<h2>总结</h2>

<blockquote><p>通过理论+模拟+实战的方式，梳理微服务的生态系统，并以持续交付和DevOps的实施为主线，体
系化的形成微服务从0到1的学习过程。</p>

<p>关于课程，请看<a href="http://www.stuq.org/course/detail/1088">这里</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[微服务实战(1) - 内容大纲]]></title>
    <link href="http://wldandan.github.com/blog/2016/11/04/microservices-in-action-outline/"/>
    <updated>2016-11-04T14:28:00+08:00</updated>
    <id>http://wldandan.github.com/blog/2016/11/04/microservices-in-action-outline</id>
    <content type="html"><![CDATA[<script src="https://cdn1.lncld.net/static/js/av-mini-0.6.10.js"></script>


<script src="http://jerry-cdn.b0.upaiyun.com/hit-kounter/hit-kounter-lc-0.2.0.js"></script>


<p>[如需转载，请联系本人]</p>

<p>过去的几个月，我作为独立咨询师，为多个传统企业提供了微服务架构的培训、咨询以及交付工作。实际上，传统企业在过去多年的业务积累中，由于组织架构、业务发展和市场竞争等综合因素，技术体系相对封闭，缺乏快速交付的理念。因此，微服务的出现，加之社区的热捧，导致很多传统的团队过于追热而并没有完全理解微服务。</p>

<p>经过2015年的快速普及，微服务的优势被越来越多的传统组织和企业所认可，但由于架构相关的知识本身比较抽象，虽然各大会议上有很多互联网公司的案例分享，但开发者似乎依然很难全面了解微服务架构。</p>

<p>所以，希望通过本系列的文章以及视频，以一个真实的案例为背景，以持续交付和DevOps为主线，帮助初学者理解微服务架构，并能通过动手实验，了解相关的实践以及方法论。</p>

<p>精彩视频课程已经出炉，请移步<a href="http://www.stuq.org/course/detail/1088">这里</a></p>

<!-- More -->


<h2>核心思路</h2>

<ul>
<li>以<code>微服务生态系统</code>和<code>持续交付</code>为指导原则</li>
<li>以<code>模拟案例实战</code>为主，并使<code>用SpringBoot</code>和<code>Spring Cloud</code>实现服务</li>
<li>分为<code>服务构建</code>与<code>服务实施</code>两个专题，包括<code>应用架构</code>，<code>部署模型</code>和<code>交付流水线</code></li>
</ul>


<h2>主要亮点</h2>

<h4>1.全面了解微服务架构的理论基础</h4>

<ul>
<li>微服务的定义与认识误区</li>
<li>微服务的核心原则以及同SOA的关系</li>
<li>微服务的<code>持续交付体系</code></li>
</ul>


<h4>2.基于微服务生态系统，搭建模拟案例</h4>

<ul>
<li>通过案例理解<code>微服务架构生态系统</code></li>
<li>掌握<code>REST &amp; HAL &amp; HAL Browser</code>的使用方式</li>
<li>掌握<code>Spring Boot</code>的核心与使用</li>
<li>熟悉<code>Spring Cloud</code>的服务支撑组件</li>
</ul>


<blockquote><p>微服务生态系统</p></blockquote>

<p><img src="http://wldandan.github.com/images/microservice-in-action-with-spring/microservices-eco-system-600-450.png" /></p>

<h4>3.理解微服务的高级话题</h4>

<ul>
<li>使用<code>PACT契约测试</code>验证服务接口</li>
<li>使用<code>OAuth</code>与<code>JWT</code>实现服务的安全</li>
<li><code>RESTful API</code>设计相关</li>
</ul>


<blockquote><p>基于消费者驱动的契约测试</p></blockquote>

<p><img src="http://wldandan.github.com/images/microservice-in-action-with-spring/pact-600-450.png" /></p>

<h4>4.理解实施微服务与DevOps(基于Docker)</h4>

<ul>
<li>建立<code>Docker私有仓库</code>，并将服务发布成Docker镜像</li>
<li>使用<code>Docker搭建Jenkins</code>持续交付流水线</li>
<li>以<code>Pipeline as Code</code>的方式管理流水线</li>
<li>使用<code>ELK实现日志聚合</code>的实践</li>
<li>使用<code>Prometheus</code>实现监控告警的实践</li>
<li>使用<code>Rancher</code>完成服务Docker镜像的部署</li>
</ul>


<blockquote><p>部署模型图</p></blockquote>

<p><img src="http://wldandan.github.com/images/microservice-in-action-with-spring/events-system-deployment-600-450.png" /></p>

<blockquote><p>持续交付流水线</p></blockquote>

<p><img src="http://wldandan.github.com/images/microservice-in-action-with-spring/events-system-cd-600-450.png" /></p>

<h2>总结</h2>

<blockquote><p>通过理论+模拟+实战的方式，梳理微服务的生态系统，并以持续交付和DevOps的实施为主线，体
系化的形成微服务从0到1的学习过程。</p>

<p>关于课程，请看<a href="http://www.stuq.org/course/detail/1088">这里</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[微服务实战视频课(0) - 聊聊开篇]]></title>
    <link href="http://wldandan.github.com/blog/2016/11/03/microservices-in-action-introduction/"/>
    <updated>2016-11-03T14:28:00+08:00</updated>
    <id>http://wldandan.github.com/blog/2016/11/03/microservices-in-action-introduction</id>
    <content type="html"><![CDATA[<p>[如需转载，请联系本人]</p>

<p>过去的几个月，我作为独立咨询师，为多个传统企业提供了微服务架构的培训、咨询以及交付工作。实际上，传统企业在过去多年的业务积累中，由于组织架构、业务发展和市场竞争等综合因素，技术体系相对封闭，缺乏快速交付的理念。因此，微服务的出现，加之社区的热捧，导致很多传统的团队过于追热而并没有完全理解微服务。</p>

<p>经过2015年的快速普及，微服务的优势被越来越多的传统组织和企业所认可，但由于架构相关的知识本身比较抽象，虽然各大会议上有很多互联网公司的案例分享，但开发者似乎依然很难全面了解微服务架构。</p>

<p>所以，希望通过本系列的文章以及视频，以一个模拟的案例为背景，以持续交付和DevOps为主线，帮助初学者理解微服务架构，并能通过动手实验，了解相关的实践以及方法论。</p>

<p>精彩课程已经出炉，请移步<a href="http://www.stuq.org/course/detail/1088">这里</a></p>

<!-- More -->


<h2>为什么搞这么个系列</h2>

<h4>1.微服务涉及内容广泛，学习成本高</h4>

<p>微服务架构提倡将<code>单一应用程序</code>划分成<code>一组小的服务</code>，<code>每个服务运行在独立的进程中</code>，服务间<code>采用轻量级的通信机制</code>互相协作(通常是基于 HTTP 协议的 RESTful API )，每个服务都围绕着具体业务进行构建，并且能被独立的<code>开发、测试、构建、部署和交付</code>。</p>

<p>客观来说，微服务架构所涉及的内容，已经不仅仅是<code>架构本身</code>，还包括了<code>持续集成</code>、<code>持续交付</code>、<code>自动化测试</code>、<code>部署/运维、监控</code>以及<code>DevOps</code>等多个方面，这些方面互相配合、相辅相成，才能在微服务实施的过程中展现威力。</p>

<p>一个完整的微服务系统，在实施的过程中，可能还要考虑服务的<code>公共支撑部分</code>，包括但不限于：</p>

<ul>
<li><code>日志聚合</code>(将不同服务实例上的日志聚合起来，便于分析、统计和定位问题)</li>
<li><code>监控</code>和<code>告警</code>(监控每个服务的状态，必要时产生告警)</li>
<li>服务的<code>注册和发现</code>机制</li>
<li>服务的<code>认证</code>和<code>鉴权</code></li>
<li><code>服务构建</code>和<code>打包机制</code></li>
<li>服务间的<code>接口测试</code></li>
<li><code>持续集成</code>/<code>持续交付流水线</code></li>
<li><code>服务依赖</code>关系管理</li>
<li>&#8230;&#8230;</li>
</ul>


<p>对于这么多的内容，如果能基于模拟场景的理解与练习，再借鉴各大会议上诸多公司的微服务实施案例，能够快速理解并开始尝试。</p>

<h3>2.《微服务与实践》一书，该更新了</h3>

<p>2015年4月，我开始撰写《微服务架构与实践》一书，当时国内微服务架构的概念还谈的比较少，所以《微服务架构与实践》侧重讲了微服务的理论基础和诞生背景，并分享了我在ThoughtWorks就职期间，实现微服务的工作方式（我们以持续交付和DevOps为核心，构建服务开发模板，并基于AWS实现快速发布，快速监控，快速反馈）。同时，也探讨了我们如何将遗留系统改造成微服务架构的策略和步骤，但由于精力有限，很多细节无法一一展开讨论。</p>

<p>另外，书中的大部分例子都是以<code>Ruby和AWS</code>为主，很多读者也提出了建议，希望给出采用Java实现的例子，更容易理解和使用。</p>

<p>当今时代，技术发展的速度越来越快，诞生的框架、工具越来越多，虽然有心更新书的内容，但时间和精力都无法快速更新并发布新版，所以，这次希望能通过这个系列，先将过去的一些实践细化，包括DevOps、持续集成、持续交付以及使用Pact等实践，并采用Java(基于Spring Boot/Spring Cloud的快速发展)实现一个模拟的案例。</p>

<h3>3. 为感兴趣的传统开发者提供可用的案例</h3>

<p>过去两年微服务的快速发展，已经有很多传统企业开始尝试使用微服务解耦业务系统。传统企业和互联网企业的业务形态不一样，互联网公司业务变化快，响应速度快，组织愿意积极尝试开源的工具和方法论，降低交付成本和缩短交付周期。互联网领域中，大部分的产品，本身就是基于分布式系统构建，所以微服务的概念只是新瓶装旧酒。</p>

<p>而传统企业在过去多年的业务运作积累中，综合多种因素（组织结构、业务发展等），技术体系相对封闭，缺乏持续交付的理念。如果光有微服务的理论基础，和业界的成功案例，不动手尝试持续交付、DevOps等，很难有深刻的理解。</p>

<p>Github上微服务相关的实现Repo蛮多，但作为完整系列的不多。</p>

<p>所以，基于这些原因，结合过去为企业实施微服务架构培训的内容，也希望能输出这个系列。</p>

<h2>受众用户是谁</h2>

<ul>
<li><p>本系列的受众用户，主要是年轻(1~3年)的Java开发者、传统应用的IT架构师，以及对微服务感兴趣的童鞋们。</p></li>
<li><p>希望通过本系列，能将微服务、持续交付、Docker以及DevOps等技术，作为整体输出，帮助大家缩短系统了解微服务的成本。</p></li>
</ul>


<h2>数据说话</h2>

<p>关于IT社区对微服务的关注度和市场的需求数据，请看下图，一个字🔥。</p>

<p><img src="http://wldandan.github.com/images/microservice-in-action-with-spring/google_trends.png" /></p>

<blockquote><p>图的上部分是Google Trends上关于<code>Microservice</code>的增长趋势。</p>

<p>图的左下部分是<code>Microservice</code>相关关键字的增长速度，<code>Breakout</code>表明在搜索的区间内，其增长的幅度超过5000%。</p>

<p>图的右下部分是Indeed.com中对于<code>Microservice</code>的市场招聘需求的增长曲线。(趋势来了，挡都挡不住，提升个人竞争力，赶紧哈~ 😝)</p></blockquote>

<h2>总结</h2>

<blockquote><p>好的，进入正题，请移步<a href="http://www.stuq.org/course/detail/1088">课程</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[解析微服务架构]]></title>
    <link href="http://wldandan.github.com/blog/2015/03/17/microservice-design-and-implementation/"/>
    <updated>2015-03-17T11:13:00+08:00</updated>
    <id>http://wldandan.github.com/blog/2015/03/17/microservice-design-and-implementation</id>
    <content type="html"><![CDATA[<p>过去的1年多，一直在助力澳洲最大的房地产互联网门户，研究并使用微服务架构改造其复杂的遗留系统。鉴于此，准备开个系列，讲讲我个人眼中的微服务是神马样的，它的概念，优缺点，为什么我们要使用它，以及在使用微服务的实践过程中，从开发、测试、部署、运维等几个方面相比以前方式有什么不同；同时，分享一下我们在微服务实践过程中的经验和踩过的那些坑。</p>

<!-- More -->


<p>目录大概如下</p>

<ul>
<li><h3>理论篇</h3>

<ul>
<li><h5>单块架构应用以及挑战</h5></li>
<li><h5>什么是微服务</h5></li>
<li><h5>微服务的核心特征</h5></li>
<li><h5>微服务的优缺点</h5></li>
<li><h5>微服务的适用场景</h5></li>
<li><h5>微服务与SOA</h5></li>
<li><h5>微服务诞生的催化剂</h5></li>
</ul>
</li>
<li><h3>实践篇</h3>

<ul>
<li><h5>麻雀虽小，五脏俱全</h5></li>
<li><h5>实现一个服务</h5></li>
<li><h5>微服务开发模板的重要性</h5></li>
<li><h5>不仅仅是REST</h5></li>
<li><h5>消费者驱动的契约测试</h5></li>
<li><h5>如何划分微服务</h5></li>
<li><h5>微服务的依赖管理</h5></li>
<li><h5>微服务与DevOPS</h5></li>
<li><h5>微服务与监控</h5></li>
</ul>
</li>
<li><h3>案例篇</h3>

<ul>
<li><h5>合同管理系统</h5></li>
<li><h5>市场定价系统</h5></li>
<li><h5>信息搜索系统</h5></li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[解析微服务架构(四)]]></title>
    <link href="http://wldandan.github.com/blog/2015/03/16/wei-fu-wu-jia-gou-she-ji-yu-shi-xian-4-wei-fu-wu-jia-gou-de-you-que-dian/"/>
    <updated>2015-03-16T22:07:00+08:00</updated>
    <id>http://wldandan.github.com/blog/2015/03/16/wei-fu-wu-jia-gou-she-ji-yu-shi-xian-4-wei-fu-wu-jia-gou-de-you-que-dian</id>
    <content type="html"><![CDATA[<p>[请勿转载]</p>

<h1>微服务架构的优缺点</h1>

<p>将单块架构应用分解为一系列相对独立的微服务，其中每个服务都运行在自己的进程中，并且通过轻量级的机制实现彼此间的通信，这通常是HTTP资源的微服务。这些服务是围绕着业务功能构建的，并且可以通过完全自动化的部署机制进行独立部署。这些服务的集中式管理做到了最小化，每一种服务都可以通过不同的编程语言进行编写，并且可以使用不同的数据存储技术。</p>

<!-- More -->


<p>从上面的定义可以看出，微服务的优势是显而易见的：</p>

<ul>
<li>每个服务都很简单，只关注于一个业务功能。</li>
<li>每个微服务可以由不同的团队独立开发。</li>
<li>微服务是松散耦合的。</li>
<li>微服务可以通过不同的编程语言与工具进行开发。</li>
</ul>


<p>这些优势使得微服务看起来是非常完美的解决方案，不过微服务难道就没有缺点么？下面我们就来探讨一下微服务在其实施过程中所遇到的问题和一些缺点。</p>

<h5>运维成本过高</h5>

<h5>DevOps是必须的</h5>

<h5>接口不匹配</h5>

<h5>代码重复</h5>

<h5>分布式系统的复杂性</h5>

<p>总而言之，微服务架构有很多吸引人的地方，不过在拥抱微服务之前，你需要认清它所带来的挑战。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[解析微服务架构(三)]]></title>
    <link href="http://wldandan.github.com/blog/2015/03/16/wei-fu-wu-jia-gou-she-ji-yu-shi-xian-3-wei-fu-wu-jia-gou-de-he-xin-te-zhen/"/>
    <updated>2015-03-16T22:07:00+08:00</updated>
    <id>http://wldandan.github.com/blog/2015/03/16/wei-fu-wu-jia-gou-she-ji-yu-shi-xian-3-wei-fu-wu-jia-gou-de-he-xin-te-zhen</id>
    <content type="html"><![CDATA[<p>[请勿转载]</p>

<h1>微服务架构的核心特征</h1>

<p>   什么是核心特征，就是当我们谈论同一件事情的时候，那些不同的人们所关注的相同的部分。从业界的讨论来看，微服务通
常有如下几个显著特征:</p>

<ul>
<li><h5>服务与组件</h5></li>
</ul>


<p>  一直以来，我们都比较提倡使用组件（Component）的方式，模块化应用系统。它类似生活中的汽车，由不同的零件组成，每个零件都是可以独立替换的。因此，这类通常都有很好的灵活性和替换性。</p>

<p>  在软件领域，我们也将组件定义为应用软件构建中独立的单元，它的最大特点是，对整个应用软件而言，组件能够被容易的替代或者更新。</p>

<p>   传统实现组件的方式是采用和应用程序一样的的编程语言，构建独立的共享库（Libaray），从而达到解耦和复用的效果。对于共享库而言，我们知道它是语言相关、平台相关，并且是和应用程序运行在同一个进程中的，因此，任何共享库的变化都意味着整个应用程序也要被更新，并且需要被重新部署。换句话说，如果应用由多个共享库组件组成，那么任何库的变更都将导致整体应用的重新发布。</p>

<!-- More -->


<p>   其实，微服务也可以作为组件。把微服务当成应用程序中的组件，其中一个最主要的好处是微
服务可以独立部署。如果应用由多个共享库组成，那么其只能跑在一个进程中，那么任何库的变更都将导致整体应用的重新发布。</p>

<p><img src="http://wldandan.github.com/images/microservice-design-and-practice/chapter3/library-as-component-800-600.png" /></p>

<p>但是如果应用程序由多个服务构成，我们可以想像，大部分情况下，每个服务的变更仅需要重新部署相应的服务。当然，这也不是绝对的，比如某些对服务接口的变更就需要其相关服务也发生变化，但微服务架构的目的，是尽量避免这种服务间的耦合并完善服务的交互接口。换句话说，通过服务来实现组件，将应用拆散为一系列的服务，运行在不同的进程中时，任何一个服务的局部变化只需重新部署对应的服务本身。同时，将服务作为组件也可以帮助我们明确的定义出组件的边界，因为服务之间的调用是跨进程的，清晰的边界和职责定义应该是在设计阶段时必须考虑的。</p>

<p><img src="http://wldandan.github.com/images/microservice-design-and-practice/chapter3/service-as-component-800-600.png" /></p>

<p>   把服务当成组件的另外一个优点是在组件和组件之间、或者组件和应用程序之间定义了清晰的、跨语言、跨平台的接口。许
多开发语言虽然定义了良好的公共调用接口的机制，也提供了详尽的文档和规范说明，但由于共享库其本身的特性，充分依赖于特定平台、特定语言，因此组件间的耦合度较高。同共享库相比，微服务是通过语言无关、平台无关的远程接口调用，因此不存在这个问题。当然，使用微服务也有它的不足之处，那就是远程调用比进制内部调用更消耗性能，而且远程的接口由于是分布式调用，无疑增加了维护的复杂度。</p>

<ul>
<li><h5>围绕业务组织团队</h5></li>
</ul>


<p>  在单块应用架构的时代，为了节省成本、快速实现目标，企业或者组织一般都会根
据技能类型的差异化来划分团队。例如用户体验设计师一般都被划分到用户体验设计团队，而懂服务器端的开发人员，一般都被归类为后端业务逻辑开发团队；对于那些精通数据库技能的开发者，一般会在DBA团队中找到他们的身影。实际上，当团队被按照这个策略或者维度划分后，即便是某些简单的需求变更，都有可能导致不同团队之间跨组织、跨团队的协作，耗费很高的跨团队的沟通和协作成本。</p>

<p>  正如<a href="http://en.wikipedia.org/wiki/Conway's_law">康威定律（Conway’s law)</a>提出的，一个组织的设计成果，其
结构往往对应于这个组织中的沟通和组织结构。另外，《敏捷宣言》的一个核心理念是“个体与交互高于过程和工具”。</p>

<p>如果仔细想想，我们发现康威定律从正反两方面支持了这一理念。有些公司受困于垂直、等级化的管理结构，这给工程师们带来了完成工作时不必要的阻力。更多的互联网公司则放手，让团队找到自组织的管理结构。我们既看到“漠视”康威定律所造成的危害，也看到了“拥抱”该定律所带来的好处。</p>

<p><img src="http://wldandan.github.com/images/microservice-design-and-practice/chapter3/build-team-aroud-business-800-600.png" /></p>

<p>   而微服务架构的开发模式不同于传统方式，它倡导围绕应用程序为核心，按业务能力来划分为不同的团队。每个团队都要求能
够对每个服务，将其对应的业务领域的全部功能实现，譬如对于某业务需求的更改，从用户体验界面到业务逻辑实现，再到数据的存储和迁移等。因此团队的组织是跨职能的，会包含实现该业务所需功能的所有技能。近年兴起的全栈工程师正是因为架构和开发模式的转变而出现，当然具备全栈的工程师其实很少，但将不同领域的工程师组织为一个全栈的团队就容易的多。</p>

<ul>
<li><h5>关注产品而不是项目</h5></li>
</ul>


<p>   传统的应用开发大部分都是基于项目模式的。什么是项目模式？就是当项目启动后，企业或者组织会从开发
团队中抽出一部分资源、从测试团队中抽出一部分资源，同时也从其他不同的技能团队中抽出不同的资源，组成一个项目团队，然后设置一个时间期限，让大家完成项目。当项目结束后，所有的资源都会被释放，所有人在项目中的职责结束。</p>

<p><img src="http://wldandan.github.com/images/microservice-design-and-practice/chapter3/team-by-skills-800-600.png" /></p>

<p>   但服务架构倡导的是避免采用这种项目模式，更倾向于让开发团队负责整个产品的生命周期。大家熟知的亚
马逊CTO Werner Vogels，曾经说过一句经典的名言，“You build it, you run it”。即对于开发产品的团队而言，产品就是团队的，也是每个成员的。团队中的每个人都有责任、有义务确保产品的快速发展以及演进。</p>

<ul>
<li><h5>去中心化</h5></li>
</ul>


<p>   在第二章我们提到，传统的单块应用架构，倾向于采用统一的技术平台或方案来解决所有问题。其实，我们
知道，在现实生活中，并不是每个问题都是钉子，也不是每个解决方案都是一个锤子。
问题有其具体性，解决方案也应有其针对性。用最适合的技术方案去解决具体的问题，往往会事半功倍。传统的单块架构系统倾向采用统一的技术平台或方案来解决所有问题，而微服务的架构意味着，可以针对不同的业务特征选择不同的技术方案，有针对性的解决具体的业务问题。</p>

<p>   对于单块架构系统，初始的技术选型严重限制将来采用不同语言或框架的能力。如果想尝试新的编程语言
或者框架，没有完备的功能测试集，很难平滑的完成替换，而且系统规模越大，风险越高。</p>

<p>  而基于微服务架构，使我们更容易在系统上尝试新的技术或解决方案。譬如说，可以先挑选风险最小的服务作为尝试，快速得到
反馈后再决定是否试用于其他服务。这也意味着，即便对一项新技术的尝试失败，也可以抛弃这个方案，并不会对整个产品带来风险。</p>

<ul>
<li><h5>独立业务数据</h5></li>
</ul>


<p>  传统的单块应用架构，倾向于采用统一的数据存储平台来存储所有的数据。随着业务的快速发展，需求的不断变化，一方面，数
据变得越来越复杂，难以管理；另一方面，随着应用系统的业务逻辑不断更新和发展，数据库不仅承担着数据存储的作用，还承担着不同系统之间的集成作用。同时，传统的数据库大多是关系型数据库，存储的数据都是以结构化信息为主，但随着互联网的快速发展，数据的结构并不具有确定性，或者说结构发生变化的频率非常快，因此，对于如何有效维护业务数据，也成了一个难题，相应的维护成本越来越高。</p>

<p>  微服务架构，提倡具有业务属性的独立单元或者服务自身维护其相关的业务数据。这样的话，有几个非常明显的优势：首先具有
业务属性的服务单元能够有权利管理其相关的数据，同时能够随着业务的发展，不断更新业务数据。其次，每个业务单元只关心自己的业务数据，因此可以选择最合适的工具或者产品来存储以及管理数据。譬如可以根据具体业务场景，使用MySQL、PostgreSQL等关系型数据库，也可以使用文档类型的MongoDB、键值类型的Riak等NoSQL数据库。譬如，在一个复杂的电商系统中，产品数据的种类繁多，更新也比较频繁，如果使用类似MongoDB这种文档数据库，能灵活的根据需求动态调整结构。而像当用户访问系统时产生的会话信息，则可以使用Redis等键值系统进行存储；通常来说，报表数据的结构变化不大，而且要求数据的高一致性，因此可以使用熟悉的关系型数据库。</p>

<p><img src="http://wldandan.github.com/images/microservice-design-and-practice/chapter3/polyglot-persistence-800-600.png" /></p>

<ul>
<li><h5>基础设施自动化</h5></li>
</ul>


<p>随着云技术的大规模推广与使用，部署和运维的复杂度在大幅度降低。利用云，我们可以快速的创建系统需要的资源，降低应用的交付周期。同时，由于持续集成、持续交付等实践的深入人心，很多团队都开始在构建软件的过程中，使用持续交付提倡的基础设施自动化技术（更多关于持续交付的知识，请参考《持续交付-发布可靠软件的系统方法》一书）。</p>

<p>这也就意味着，如果微服务架构将应用程序本身分成多个小的服务，每个服务都是一个独立的部署单元。因此，微服务的实践，对持续交付和部署流
水线要求非常高。微服务的粒度越细，就意味着需要部署的业务单元就越多，业务单元越多，就需要更稳定的基础设置自动化机制，能够创建运行环境，安装依赖，部署应用等。</p>

<p><img src="http://wldandan.github.com/images/microservice-design-and-practice/chapter2/loose-decouple-microservice-800-600.png" /></p>

<ul>
<li><h5>演进式架构设计</h5></li>
</ul>


<p>  在过去十年中，敏捷方法论以及其实践已经被越来越多的组织尝试并认可。敏捷方法论正在帮助组织以拥抱变化的心
态，去不断尝试，不断获取反馈，从而以高效的方式构建正确的应用系统。实际上，敏捷并不是一种静止的状态，它是组织一直在拥抱变化，尝试改变、获取反馈的演进式发展的一个动态过程。</p>

<p>  类似的，架构设计也应该是随着业务的发展而不断发展，随着需求的变化而不断变化的。当我们试图构建一个单块应用架构系统
时，我们会面临非常艰难的技术选型。哪种方案才是合理的？那种方案才是最正确的？在传统的单块设计中，企业或者组织通常是希望构建一个大而全、无所不能的平台，但是在技术发展如此之快的今天，单一的技术平台已经无法适应市场的快速变化，组织应该随着业务的发展，随着企业的发展，不断尝试并改进架构设计，真正做到业务驱动架构，架构服务于业务。</p>

<hr />

<h3>总结</h3>

<p>微服务强调的是一种独立测试、独立部署、独立运行的软件架构模式，是一种更灵活、更开放、更松散的演进式架构。通过本章所介绍的微服务的核心特征，帮助我们更清晰、深刻的理解了微服务其概念背后所蕴含的思想。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[解析微服务架构(二)]]></title>
    <link href="http://wldandan.github.com/blog/2015/03/16/wei-fu-wu-jia-gou-she-ji-yu-shi-xian-2-shen-me-shi-wei-fu-wu-jia-gou/"/>
    <updated>2015-03-16T22:07:00+08:00</updated>
    <id>http://wldandan.github.com/blog/2015/03/16/wei-fu-wu-jia-gou-she-ji-yu-shi-xian-2-shen-me-shi-wei-fu-wu-jia-gou</id>
    <content type="html"><![CDATA[<p>[请勿转载]</p>

<h1>什么是微服务架构</h1>

<p>在上一章中，我们认识了什么是单块架构应用，并分析了随着互联网时代的快速发展，随着市场变化快，用户需求变化快以及用户访问量的增加，单块架构应用的维护成本、人员的培养成本、缺陷修复成本以及技术架构演进的成本和系统扩展成本等都在增加，因此单块架构曾经的优势已逐渐无法适应互联网时代的快速变化，面临着越来越多的挑战。</p>

<p>在本章中，我们来了解到底什么是微服务架构，以及为什么微服务架构能有效解决单块架构在互联网时代所面临的挑战。</p>

<h3>概述</h3>

<p>   微服务架构一词在过去几年里，得到了广泛的讨论和关注。微服务架构提倡通过对特定业务领域的分析与建模，将复杂的、
集中的、耦合度高的应用系统分解成小而专、耦合度低并且高度自治的一组服务。这些服务与服务之间相互协作、相互配合，从而为最终用户或其他系统提供相应的功能。微服务将每个独立的业务逻辑划分出来，运行在它们自己的进程中，然后通过分布式的网络互相通信与协作，从而为终端用户或其他调用者提供灵活的接口。</p>

<!-- More -->


<p>   与传统IT行业的&#8217;服务架构&#8217;概念不一样的是，微服务更强调的是一种独立测试、独立部署、独立运行的软件架构模式。微服
务中的每个服务，都可以作为一个独立的业务单元进行测试、部署，而且每个服务都能独立运行在不同的进程中。这些微服务满足细粒度的业务需求，并使用自动化部署工具进行发布。同时，这些微服务可以使用不同的开发语言，不同框架，以及不同的数据存储技术，因此相比与&#8217;服务架构&#8217;，它是一种高度自治的、非集中式管理的、细粒度的业务单元。</p>

<p>   实际上，微服务架构并不是一个全新的概念。早在二十几年前，面向服务架构（SOA）概念的提出，就已经阐述了类似的思
想，“对于复杂的企业IT系统，应按照不同的、可重用的粒度划分，将功能相关的一组提供者组织在一起为消费者提供服务”。
仔细分析SOA的概念，就会发现，其在服务的定义上和我们今天所谈到的微服务定义大致类似，那为什么在SOA的概念提出这么多年后，又诞生了这个貌似是新瓶装旧酒的微服务架构呢？其实，鉴于过去十几年互联网行业的高速发展，以及敏捷、持续集成、持续交付、DevOPS，云技术等的深入人心，服务架构的开发、测试、部署以及监控等，相比我们提到的传统的SOA，已经大相径庭。相比SOA，微服务要更具有独立性、灵活性、可实施性以及可扩展性。换句话说，微服务架构可以被认为是一种更接地气的面向服务架构，是一种更容易帮助企业或组织构建演进式架构的方法和实践。关于更多SOA与微服务的区别，请参考[X部分]。</p>

<h3>微服务架构的定义</h3>

<p>   其实，即便了解了上面的介绍，还是很难对微服务下一个准确的定义。就像NoSQL，我们谈论了好几年的NoSQL，知道NoSQ
L代表着什么样的含义，也可以根据不同的应用场景选择不同的NoSQL数据库，但是我们还是很难对它下一个准确的定义。类似的，关于什么是‘函数式编程’，也或多或少存在同样的窘境。我们可以轻松的选择不同的函数式编程语言，可以轻松的写出函数式编程风格的代码，但很难对什么是函数式编程下一个准确的定义。</p>

<p>   实际上，从业界的讨论来看, 微服务本身并没有一个严格的定义。不过，ThoughtWorks的首席科学家，马丁-
福勒先生对微服务的这段描述，似乎更加具体、贴切，通俗易懂：</p>

<blockquote><p>  The microservice architectural style is an approach to developing a single application as a
suite of small services, each running in its own process and communicating with lightweight
mechanisms, often an HTTP resource API. These services are built around business capabilities and independently deployable by fully automated deployment machinery. There is a bare minimum of centralized management of these services, which may be written in different programming languages and use different data storage technologies.</p></blockquote>

<p>  微服务架构是一种架构模式，它提倡将单一应用程序划分成一组小的服务，服务之间互相协调、互相配合，为用户提供最终价值
。每个服务运行在其独立的进程中，服务与服务间采用轻量级的通信机制互相沟通（通常是基于HTTP协议的RESTful API）。每个服务都围绕着具体业务进行构建，并且能够被独立的部署到生产环境、类生产环境等。另外，应当尽量避免统一的、集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具对其进行构建。</p>

<p>  如果我们仔细分析这段话，不难发现，对于微服务的定义，我们可以从以下几个方面考虑：</p>

<h4>小，且专注于做一件事情</h4>

<p>   微服务架构通过对特定业务领域的分析与建模，将复杂的应用分解成小而专一、耦合度低并且高度自治的一组服务。每个服务都
是很小的应用。那么，微服务中提到的‘微’或者‘小’，到底是多‘微’、多‘小’呢？</p>

<p><img src="http://wldandan.github.com/images/microservice-design-and-practice/chapter2/confuse-how-small-800-600.png" /></p>

<p>实际上，关于多小的服务才合适，是一个非常有趣的话题。有人觉得使用代码行数来作为‘微’的衡量标准比较合适，而有些人认为，既然是微服务，就应该简单。就应该在很短的时间内，譬如2周内，能够非常容易的重写该服务，这样才符合小和微的概念。</p>

<p>关于代码行数，我们知道，不同的语言有不同的特点。静态类型语言的主要优点在于其结构非常规范，存在编译期的语法检查、便于调试，类型安全性高，通常其继承关系简洁明了，IDE对其支持也更加友好；但缺点是为此需要写更多的类型相关代码。因此如果实现同样的功能，代码量相对稍多，这类语言的典型代表有Java、C#等；动态语言，其灵活性较高，运行时可以改变内存的结构，无类型检查，不需要写非常多的类型相关的代码；缺点自然就是不方便调试，命名不规范时会造成不易理解等，典型的代表如JavaScript、Ruby或者Python等。另外，还有一些数学类计算语言，能够使用非常简洁的公式实现其逻辑。</p>

<p>譬如说，对于经典的<a href="http://zh.wikipedia.org/wiki/%E5%BA%B7%E5%A8%81%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F">康威生命游戏</a>而言，游戏开始时，细胞随机的被指定为存活或者死亡状态（黑色表示存活，白色表示死亡），每个细胞都会不断的演进，并且在演进的过程中，每个细胞下一代的状态由该细胞当前周围8个细胞的状态所决定，</p>

<p>其具体的规则如下图所示：</p>

<ul>
<li><p>规则1，如果一个细胞周围有少于2个存活细胞，则该细胞无论存活或者死亡，下一代将死亡；</p></li>
<li><p>规则2，如果一个细胞周围有多于3个存活细胞，则该细胞无论存活或者死亡，下一代将死亡；</p></li>
<li><p>规则3，如果一个细胞周围有3个存活细胞，则该细胞下一代将存活；</p></li>
<li><p>规则4，如果一个细胞周围且仅有2个存活细胞，则该细胞下一代状态保持不变；</p></li>
</ul>


<p><img src="http://wldandan.github.com/images/microservice-design-and-practice/chapter2/conwey-problem-description-800-600.png" /></p>

<p>对于这个问题，各位如果感兴趣的话，可以尝试使用自己最擅长的语言来试试。</p>

<p>但这里，我想说的是，有一种语言叫APL（<a href="http://en.wikipedia.org/wiki/APL_(programming_language)">A Programing Language</a>），如果我们使用它来实现，需要如下一行代码就可以解决该问题。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>life←{↑1 ⍵∨.∧3 4=+/,¯1 0 1∘.⊖¯1 0 1∘.⌽⊂⍵}
</span></code></pre></td></tr></table></div></figure>


<p>因此，对于实现同样的功能，选择不同的语言，代码的行数会有千差万别。因此代码行数这种量化的数字显然无法成为衡量微服务是否够‘微’的决定因素。</p>

<p>另外，有些人认为，既然是微服务，就应该简单。譬如说，就应该在固定时间内（譬如2周），能够非常容易的重写，这样才符合微的概念。实际上，2周时间，对不同的个体而言 ，其服务重写的结果可能大相径庭。我们知道，对于重写这种情况，很大部分取决于个体的工作经验、擅长的语言、对业务背景的了解等等。譬如说，工作年限长的开发者通常情况下可能对其擅长的技术更熟练，而对业务熟悉程度较好的开发者，如果重写可能完成的更快。因此，多长时间能够重写该服务也不能作为衡量其是否小的重要因素。</p>

<p>因此，我个人认为，微服务的“微”并不是一个真正可衡量、看得见、摸得着的“微”。这个“微”所表达的，是一种设计思想和指导方针，是需要团队或者组织共同努力找到的一个平衡点。因此，微服务到底有多微，是个仁者见仁，智者见智的问题，最重要的是团队觉得合适就好。但注意，当考虑微服务的“微”时，至少应该遵循两个原则：业务独立性和团队自主性。首先，应该保证微服务是具有业务独立性的单元，在这个前提下，由团队来判断当前的服务大小是否合适，考虑到团队的沟通成本，一般不建议超过10个人，或者在超过10个人的团队中，可以再划分子团队。在这种情况下，当团队中大部分成员认为当前的服务是能够容易维护的、容易理解的，这就是我们认为适合团队的、有意义的“微”。</p>

<p>   专注于做一件事情。从我们接触编程的第一天起，老师就教授我们，写出来的代码要符合“高内聚、低耦合”的原则，作为曾经似懂非懂的学生而言，我们也一直在朝
着这个方向努力着；另外，在面向对象设计的领域中，有几条放之四海而皆准的重要原则，那就是“SOLID原则”。大家请注意，在SOLID原则中的的第一条，叫单一职责原则（SRP-Single responsibility principle），其实描述的也是类似的事情。具体点说，单一职责原则的核心思想是：一个类，应该只有一个职责，也只有一个引起它变化的原因。如果一个类承担的职责过多，就等于把多个不同的职责耦合在了一起。这种耦合会导致当其中的某一职责发生变化时，可能会导致原本运行正常的其他职责或者功能发生故障。另外职责过多，也会导致引起该类变化的原因增多，多个职责之间相互依赖，容易产生影响，从而极大的损伤其内聚性和耦合度。Unix/Linux便是这一原则的完美体现者：在Unix中，各个程序都独立负责一个单一的事，我们可以通过管道将它们容易的连接起来。而Windows，则是这一原则的典型的反面示例：Windows中几乎所有的程序代码都交织耦合在一起，并没有做到一个类，只关注一个职责并把它做好。因此，如果希望避免这种现象的发生，就要尽可能的遵守单一职责原则，增强应用程序或者代码的内聚性以及降低耦合性。</p>

<h4>运行在独立的进程中</h4>

<p>  在传统的单块架构应用中，我们通常将应用程序的代码分成逻辑上的三层、四层甚至更多层，但它并不是物理上的分层。这也
就意味着，经过开发团队对不同层的代码实现，经历过编译（如果非静态语言，可以跳过编译阶段）、打包、部署后，不考虑负载均衡以及水平扩展的情况，应用程序会运行在同一个机器的同一个进程中。</p>

<p>另外，为了提高代码的重用率以及可维护性，在应用开发中，我们有时也会将重复的代码提取出来，封装成组件。注意，这里所说的组件，指的是可以独立升级、独立替换掉的这一部分。在传统的单块架构中，组件通常的形态叫共享库，譬如JVM平台下的jar包、或者Windows下的DLL等，它们都是组件的一种形态。当应用程序在运行期时，所有的组件最终也会被加载到同一个进程中运行。如下图所示：</p>

<p><img src="http://wldandan.github.com/images/microservice-design-and-practice/chapter2/run-in-one-process-800-600.png" /></p>

<p>但在微服务的架构里，应用程序有多个服务组成，每个服务都是一个具有高度自治性的独立业务实体，通常情况下，每个服务都能够运行在一个独立的操作系统进程中，这就意味着不同的服务能非常容易的被部署到不同的主机上。</p>

<p><img src="http://wldandan.github.com/images/microservice-design-and-practice/chapter2/run-in-multiple-process-800-600.png" /></p>

<p>理论上，虽然我们能够将多个服务部署到同一台节点上，并让它们运行在不同的进程中，这种方式是可行的，但并不推荐这么做。作为微服务运行的环境，我们希望它能够保持高度的自治性和隔离性。如果多个服务运行在同一个服务器节点上，虽然省去了节点的开销，但是增加了部署和伸缩的复杂度。譬如，当部署某个新的服务时，如果当前节点正在运行的多个进程的多个服务，则必然会对这些服务造成影响。另一方面，如果运行在某个阶段的多个服务中，某些服务随着业务的发展需要伸缩，某些服务却不需要，如何有效的组织这些服务？会给服务的水平伸缩带来不必要的麻烦。</p>

<h4>轻量级的通信机制</h4>

<p>  服务和服务之间通过轻量级的通信机制，实现彼此间的互通互联，互相协作。所谓轻量级通信机制，通常指基于语言无关、平
台无关、代码无关的这类协议，例如我们熟悉的XML或者JSON，他们的解析和使用与语言无关、平台无关。另外，基于HTTP协议，能让服务间的通信变得无状态化，目前大家所熟悉的REST(Representational State Transfer)就是服务之间互相协作常用的轻量级通信机制之一。
  对于传统我们所熟知的Java RMI或者.Net Remoting等，虽然这类协议能够使用RPC的方式简化客户端的调用，使其像调用
本地接口一样调用远端的接口，但其最大的劣势在于，这类协议和语言、平台有非常强的耦合性，灵活性和扩展性较差。譬如说，如果使用了RMI作为通信协议，就意味着我们必须采用运行在JVM之上的语言才能完成互相协作。</p>

<p>  对于微服务而言，通过使用语言无关、平台无关的轻量级通信机制，使服务与服务之间的协作变得更加简单、标准化。同时，服
务内部则可以选择任何语言、工具或者平台。</p>

<h4>松耦合，独立部署</h4>

<p>  在传统的单块架构应用里，由于所有的功能都存在同一个代码库里。因此，当修改了该代码库的某个功能，在后续的测试过程中
都需要做回归测试，才能保证当前功能的修改不会影响其他已经工作的功能。也就是说，功能和功能之间存在着强耦合关系。</p>

<p>  当测试完成后，通过持续集成或者其他机制，会构建新版本的部署包。这个大而全的部署包里，自然包括了应用的所有功能。当
将该部署包部署到生产环境或者类生产环境时，由于所有功能都运行在同一个进程中。因此，必须要停掉当前正在运行的进程，完成部署，然后再启动进程，相信这个部署的过程对大家都不陌生。</p>

<p><img src="http://wldandan.github.com/images/microservice-design-and-practice/chapter2/loose-decouple-tradition-800-600.png" /></p>

<p>  但是，如果当前应用程序里包含类似定时任务的功能，则要考虑什么时间窗口适合部署，是否需要先停掉原有的数据访问源，以
防止数据被读入应用程序内存，但未处理完而导致的数据不一致性。多年前，我曾经接触过一个JAVA项目，应用程序本身是个含有定时任务的系统，每隔5秒都会从数据库读入数据，然后将其转换成JMS的消息传给不同的内部组件。每次部署时候，我们都需要先关掉相关的消息队列，以防止数据被读入到应用，但还未被处理完，进程就被关闭而导致的数据不一致性。</p>

<p>  微服务架构中，每个服务都是一个独立的业务单元，服务和服务之间是松耦合的。当对某个服务进行改变时，对其他的服务并不
会产生影响。</p>

<p>  对于每个服务，最好能使用独立的代码库。这样的话，当我们对前服务的代码进行修改后，并不会影响其他服务。也就是说，从
代码库的层面，服务与服务是松耦合、高度解耦的。类似的，对于每个服务，都有独立的测试机制，因此，对当前服务代码的修改，也并不需要担心代码改动而导致的大范围的回归测试。因此，从测试的角度而言，服务和服务之间也是松耦合、高度解耦的。另外，由于构建包是独立的，部署流程也是独立的，服务的运行也是在不同的进程中。因此，从部署和运行的角度考虑，服务和服务之间同样是松耦合、高度解耦的。</p>

<p><img src="http://wldandan.github.com/images/microservice-design-and-practice/chapter2/loose-decouple-microservice-800-600.png" /></p>

<p> 因此，对于每个服务而言，与其他服务高度解耦，同时不需要改变其依赖，只改变当前服务本身，就可以完成部署。</p>

<hr />

<h3>总结</h3>

<p>综上所述，微服务架构将一个复杂应用拆分成多个服务，服务与服务间能够互相协作、相互配合，从而为终端用户提供业务价值。每个服务独立运行在不同的进程中，服务与服务之间通过轻量的通讯机制交互，并且每个服务可以通过自动化部署方式独立部署。</p>

<p>微服务强调的是一种独立测试、独立部署、独立运行的软件架构模式。微服务中的每个服务，都可以作为一个独立的业务单元进行测试、部署，而且每个服务都能独立运行在不同的进程中。这些微服务满足细粒度的业务需求，并使用自动化部署工具进行发布。同时，这些微服务可以使用不同的开发语言，不同框架，以及不同的数据存储技术，因此它是一种高度自治的、非集中式管理的、细粒度的服务单元。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[解析微服务架构(一)]]></title>
    <link href="http://wldandan.github.com/blog/2015/03/16/wei-fu-wu-jia-gou-she-ji-yu-shi-xian-1-dan-kuai-ying-yong-jia-gou/"/>
    <updated>2015-03-16T22:07:00+08:00</updated>
    <id>http://wldandan.github.com/blog/2015/03/16/wei-fu-wu-jia-gou-she-ji-yu-shi-xian-1-dan-kuai-ying-yong-jia-gou</id>
    <content type="html"><![CDATA[<p>[请勿转载]</p>

<h1>单块架构系统以及其面临的挑战</h1>

<h3>概述</h3>

<p>多年来，我们一直在技术的浪潮中乘风破浪，扬帆奋进，寻找更优秀的方法来构建IT系统，也一直在积极的学习并观察先进的公司如何以不同的架构方式构建或者优化其IT系统，来积极应对市场的变化，迅速做出响应，从而为客户提供更多的价值。</p>

<p>微服务架构模式（Microservice Architect Pattern）是近两年在软件架构模式领域里出现的一个新名词。虽然其诞生的时间不长，但其在各种演讲、文章、书籍上所出现的频率已经让很多人意识到它对软件领域所带来的影响。那到底什么是微服务，当我们谈论微服务时，它代表着一种什么样的含义？微服务适合应用在什么场景下，以及它有什么样的优缺点？微服务和SOA到底有没有区别？在接下来的几部分里，我将为大家揭开微服务的神秘面纱。</p>

<!-- More -->


<p>不过，在我们开始探讨微服务架构之前，让我们先回顾一下三层应用架构的发展历程并认识一下什么是单块架构应用。</p>

<h3>三层应用架构的发展</h3>

<p>对于任何一个软件应用系统而言，其构建目标都是为了满足某类用户的需求，即为用户传递价值。一直以来，软件的架构设计是决定应用系统是否能够被正确、有效实现的关键要素之一。架构设计描述了在应用系统的内部，如何根据业务、技术、组织，以及灵活性、可扩展性、可维护性等多种因素，将应用系统划分成不同的部分，并使这些部分彼此之间相互分工、相互协作，从而为用户提供某种特定价值的方式。</p>

<h4>应用的三层架构</h4>

<p>   现实生活中，“层”这个字的含义，对大家一点都不陌生。我们经常说楼房高多少层，蛋糕有几层等。通常来说，层有好几种定义，但其中最耳
熟能详的，莫过于“层”能帮助我们划分出构成某整体事物的，上下相互支撑的的不同部分。譬如说，我们喜欢吃的蛋糕，一般是由三层组成：第一层的蛋糕体、第二层的奶油，和第三层的水果。从顶部至底部，每一层依赖于下一层，从底部到顶部，每一层又支撑着上一层。</p>

<p>   在软件架构模式的领域，经过多年的发展，也有了层的概念：</p>

<ul>
<li> 层能够被单独构造；</li>
<li> 层具有区别于其他层的显著特点；</li>
<li> 层与层之间能够互相连接、互相支撑、互相作用，相互协作构成一个整体。</li>
<li> 层的内部，可以被替换成其他可工作的部分，但对整体的影响不大。</li>
</ul>


<p>   以WEB应用程序为例，在WEB应用程序开发的早期，由于受到面向过程的思维及设计方式的影响，所有的逻辑代码并没有明显的区分，因此代码
之间的调用相互交错，错综复杂。譬如，我们早期使用的ASP、JSP以及PHP，都是将所有的页面逻辑、业务逻辑以及数据库访问逻辑放在一起，这是我们通常提到的一层架构。</p>

<p><img src="http://wldandan.github.com/images/microservice-design-and-practice/chapter1/1-layer-800-600.png" /></p>

<p>   随着JAVA，.NET等高级语言的快速发展，这些语言为开发者提供了越来越方便的的数据访问机制，如Java语言的JDBC、IO流，或者.NET的ADO.NET等。这时候，数据访问部分的代码逐渐有了清晰的结构，但表示逻辑和业务逻辑依然交织在一起，我们称这个阶段为二层架构阶段。</p>

<p><img src="http://wldandan.github.com/images/microservice-design-and-practice/chapter1/2-layer-800-600.png" /></p>

<p>   随着面向对象分析、面向对象设计、面向对象原则、设计模式、企业架构模式等理念以及方法论的不断发展，从为用户提供功能、以及有效组织软件结构的角度考虑，WEB
应用中不同职责的部分逐渐被定义在了不同的层次，每一层负责的部分更趋向于具体化，细致化，于是软件的三层架构逐渐出现了。三层架构通常包括表示层、业务逻辑层以及数据访问层。</p>

<p><img src="http://wldandan.github.com/images/microservice-design-and-practice/chapter1/3-layer-800-600.png" /></p>

<ul>
<li> 表示层</li>
</ul>


<p>   表示层部分通常指当用户使用应用程序时，看见的、听见的、输入的或者交互的部分。譬如，有可能是信息的显示，音乐的的播放或者可以输
入的文本框，单选按钮以及可点击的按钮等。通过这些元素，用户同软件进行交互并获取期望的价值。目前的用户接口大部分情况下为WEB方式，当然也可以是桌面软件的形式，例如. NET的WINFORM或者Java的SWING。</p>

<ul>
<li> 业务逻辑层</li>
</ul>


<p>   业务逻辑部分是根据用户输入的信息，进行逻辑计算或者业务处理的部分。业务逻辑层则主要聚焦应用程序对业务问题的逻辑处理，以及业务
流程的操作，它是大部分软件系统区别与其他系统的核心。譬如，当用户点击一个按钮后，它可能会触发业务逻辑部分的代码进行运算，生成用户期望的结果。举例来说，在一个电子商务平台中，作为用户，当我们下单购买某个商品后，应用程序的业务逻辑层会对订单如何进行处理，如何计算折扣、如何配送等进行处理。</p>

<ul>
<li> 数据访问层</li>
</ul>


<p>  在用户同应用程序交互的过程中，会产生数据。这类数据需要通过某种机制被有效的保存，并在将来能够被重复使用，或者提供给其他系统。这
种机制或者方法就是数据访问层最关注的部分。也就是说，它关注的是应用程序是如何有效的将数据存储到数据库、文件系统或者其他存储介质中。有一点要注意的是，它关心的是对原始数据的操作（数据库或者文本文件等存放数据的形式），而非原始数据的存储介质本身。譬如，在一个电子商务平台中，商品的信息是如何存储，图片的信息是如何获取的等。</p>

<p>   三层架构的出现，一方面是为了解决应用程序中代码间调用复杂、代码职责不清的问题。其通过在各层间定义接口，并将接
口与实现分离，可以很容易的用不同的实现来替换原有层次的实现，从而有效降低层与层之间的依赖。这种方式不仅有利于帮助团队理解整个应用架构，降低后期维护成本，同时也有利于制定整个应用程序架构的标准。</p>

<p>   另一方面，三层结构的出现从某种程度上也解决了企业内部如何有效的根据技能调配人员，提高生产效率的问题。在大环境
下，有效的分层能使不同职责的人员各司其职，更聚焦与个人专业技能的发展和培养。三层结构的出现不仅标准化了复杂系统的逻辑划分，更帮助企业解决了如何有效形成技术人员组织结构的问题，因此在很长的一段时间里，它一直是软件架构的经典模式之一。</p>

<h4>非三层架构</h4>

<p>有些人认为，对于一个WEB应用程序，其被自动地分成了三层架构，因为它有三个分离的部件，如图所示：</p>

<p><img src="http://wldandan.github.com/images/microservice-design-and-practice/chapter1/not-3-layer-800-600.png" /></p>

<p>   这三个部分看起来虽然满足“层”的概念，但它并不是我们所说的软件架构的层。就像我们所说的奶油蛋糕，我们可以在蛋糕
的底部加上稳固的底座，在蛋糕的外部加上漂亮的包装盒，但仔细想想，底座可以用不同品牌的底座，可以用纸质材料的，也可以用树脂材料的；包装盒可以用红色的一次性纸袋，也可以用蓝色的带着花纹的铁盒，它们并不是我们蛋糕组成的必须一部分。</p>

<p>   浏览器可以独立存在与WEB应用程序之外，WEB应用程序也可以被不同的浏览器访问，因此浏览器不是WEB应用程序的部分
。虽然最近几年，在浏览器端，我们可以使用很多JavaScript库或者框架独立开发前端应用，但它的范畴超出了我们目前讨论的三层架构，更多的属于富客户端以及前后端分离的应用。</p>

<p>   类似的，数据库服务器也可以独立存在于应用程序之外，因此它也不是应用程序的一部分。虽然有些应用程序的逻辑代码，
被设计成必须是在数据库中运行，例如存储过程或者触发器，但这种用法并不推荐，原因是将业务逻辑放在了数据库本身，大大增加了后期维护的复杂度和数据迁移的成本。</p>

<h3>单块架构应用</h3>

<h4>什么是单块架构应用</h4>

<p>   虽然软件的三层架构帮助我们将应用在逻辑上分成了三层，但它并不是物理上的分层。这也就意味着，即便我们将应用架构分成了 所谓的三层
，经过开发团队对不同层的代码实现，经历过编译（如果非静态语言，可以跳过编译阶段）、打包、部署后，不考虑负载均衡以及水平扩展的情况，最终还是运行在同一个机器的同一个进程中。
对于这种功能集中、代码和数据中心化、一个发布包、部署后运行在同一进程的应用程序，我们通常称之为单块架构应用。典型的单块架构应用，莫过于传统的J2EE项目所构建的产品或者项目，它们存在的形态一般是WAR包或者EAR包。当部署这类应用时，通常是将整个一块都作为一个整体，部署在同一个WEB容器，如Tomcat或者Jetty中。当这类应用运行起来后，所有的功能也都运行在同一个进程中。</p>

<p>   类似的，基于Ruby On Rails的单块架构应用，一般逻辑上分为控制器层、模型层以及视图层，同时代码存放在遵循一定层级结构 的目录中
。当部署这类应用的时候，通常是使用SSH或者其他一些工具，如<a href="https://github.com/capistrano/capistrano">Capistrano</a>将整个目录部署在<a href="https://www.phusionpassenger.com/">Passenger</a>或者其他WEB容器中。当这类应用运行起来后，所有的功能也都运行在同一个进程中。</p>

<p><img src="http://wldandan.github.com/images/microservice-design-and-practice/chapter1/in-a-web-container-800-600.png" /></p>

<p>因此，对于单块架构应用的定义，其实是基于分层软件架构设计的系统基础之上，从部署模式、运行模式角度去考虑的一种定义方式。</p>

<h4>单块架构应用的优势</h4>

<ul>
<li> 易于开发</li>
</ul>


<p>   对单块架构的应用程序而言，开发方式相对较简单。首先从概念上，现有的大部分工具、应用服务器、框架都是这类单块架构应用程序，容易
理解而且为人所熟知。如果从实践角度出发，现有的集成开发工具比较适合单块架构的应用程序，像NetBeans、Eclipse、IDEA等，它们都能够有效加载并配置整个应用程序的依赖，方便开发人员开发、运行、调试等。</p>

<ul>
<li> 易于测试</li>
</ul>


<p>   单块架构应用程序也非常容易被测试，因为所有的功能都运行在一个进程中，启动集成开发环境或者将发布包部署到某一环境，一旦启动该进程，就可以立即开始系统测试或者功能测试。</p>

<ul>
<li> 易于部署</li>
</ul>


<p>   对单块架构的应用程序而言，部署也比较容易。实际上，由于所有的功能最终都会打成一个包，因此只需复制该软件包到服务器相应的位置即
可。当然，部署的方式可以有很多种，最简单的可以使用SCP远程拷贝到指定的目录下，当然也可以使用某些自动化的工具来完成。</p>

<ul>
<li> 易于水平伸缩</li>
</ul>


<p>   对单块架构的应用程序而言，水平伸缩也比较容易。实际上，由于所有的功能最终都会打成一个包，且只能运行在一个进程中，因此单块架构
的水平伸缩，更确切的理解其实是克隆，即新建一个服务器节点，配置好该节点的运行环境，复制软件包到相应的位置，运行改应用程序。当然，必须要确保负载均衡器能采取某种分发策略，有效的将请求分发到新创建的节点。</p>

<h4>单块架构面临的挑战</h4>

<p>   随着最近几年互联网行业的迅猛发展，随着公司或者组织业务的不断扩张，需求不断的增加以及用户量的不断增加，单块架构的优势已逐渐无法
适应互联网时代的快速变化，面临着越来越多的挑战。譬如说，一方面，随着业务的扩大，如何为用户提供可靠的服务，如何有效处理用户增多后导致并发请求数增多，导致的响应慢的问题，以及如何有效解决用户增多后带来的大数据量的问题等。另外一方面，随着公司或者组织业务的不断扩张，需求不断的增加，越来越多的人加入开发团队，代码库也在急剧膨胀。在这种情况下，单块架构的可维护性、灵活性在降低，而测试成本、构建成本以及维护成本却在显著增加。</p>

<p><img src="http://wldandan.github.com/images/microservice-design-and-practice/chapter1/advantages-vs-disadvantages-800-600.png" /></p>

<h5>1.维护成本增加</h5>

<p>   随着应用程序的功能越来越多，团队越来越大，相应的沟通成本、管理成本、人员协调成本必然会显著增加。譬如说，对于使
用Java编写的中型应用而言，当代码量为几万行时，可能只需要几人左右的团队维护。当代码量上升到几十万行级别时，可能需要几十人甚至是上百人的团队。</p>

<p>   另外，随着应用程序功能的增多，当出现缺陷时，有可能引起缺陷的原因组合就会比较多，这也会导致分析缺陷、定位缺陷、修复缺陷的成本相应增高，也就意味着缺陷的平均修复周期可能会花费更长时间。</p>

<p>   另外，随着代码量的增大，在开发人员对全局功能缺乏深度理解的情况下，修复一个缺陷，还有可能引入其他的缺陷，在自动
化测试机制不完善的情况下，很可能导致该过程陷入“修复越多，缺陷越多”的恶性循环。</p>

<p><img src="http://wldandan.github.com/images/microservice-design-and-practice/chapter1/complexity-increase-as-feauture-growing-800-600.png" /></p>

<h5>2.持续交付周期长</h5>

<p>   随着应用程序的功能越来越多，代码越来越复杂，构建和部署时间也会相应的增长。在现有部署流水线稳定工作的情况下，对
单块架构应用程序做任何细微的修改以及代码提交，都会触发部署流水线，对整个应用程序进行代码编译、运行单元测试、代码检查、构建并生成部署包、验证功能等，这也就意味着流水线的反馈周期变长，单位时间内构建的效率变低了。</p>

<p>   另一方面，团队人员的增多，部署流水线运行的时间增加，开发人员能够提交代码的时间窗口就相应减少，（因为流水线运行
的过程中，是禁止提交代码的），可能出现长时间等待代码提交，却无法提交的情况，极大破坏了团队的灵活性并降低了团队工作效率。几年前，我曾经工作在一个50万代码行的单块架构应用上，整个应用由一个50人左右的分布式团队负责。通常情况下，从开发人员提交代码到运行单元测试、构建发布包、运行功能测试、标记为可发布状态大概需要40分钟，时间稍微有点长，但团还能忍受。关键的问题是开发人员通常都是集中在下午3点左右，完成一定功能的情况下提交代码，结果就导致3点至5点那个时间段，成了代码提交的瓶颈，极大影响了该应用的持续集成和构建的效率。</p>

<h5>3.新人培养周期长</h5>

<p>   随着应用程序的功能越来越多，代码变得越来越复杂的同时，对于新加入团队的成员而言，了解行业背景、熟悉应用程序业
务、配置本地开发环境，这些看似简单的任务，将会花费更长的时间。我曾经有个朋友，在加入一家世界500强的知名IT公司后，被安排到了一个百万级代码的产品组里。他花了将近1个月的时间来熟悉产品文档、配置开发环境后，才在本地成功的运行起了这个应用。在他从事这份新工作的头一个月里，我们好几次聊到他的新工作，得到的答案都是一样，“看文档，装环境”。对个人而言，花一个月时间来配置本地开发环境，其中的滋味和感受大家可想而知，我估计人世间比这更痛苦的事情也没几件了。而对公司或者部门而言，本期望员工花费数天就能配置好的环境，却花了一个月才能完成，这更是极大的浪费。更有甚者，在第一次配置完开发环境后，好几年都不愿意再升级或者重装系统，真是一招被蛇咬，十年怕井绳。</p>

<p><img src="http://wldandan.github.com/images/microservice-design-and-practice/chapter1/new-employee-chanlleges-800-600.png" /></p>

<h5>4.技术选型成本高</h5>

<p>   传统的单块架构系统倾向采用统一的技术平台或方案来解决所有问题。通常，技术栈的决策是在团队开发之前经过架构师、技术经理慎重评估后选定的，每个团队成员都必须使用相同的开发语言、持久化存储及消息系统，而且要使用类似的工具。随着应用程序的复杂性逐渐增加以及功能越来越多，如果团队希望尝试引入新的框架、技术，或者对现有技术栈升级，通常会面临不小的风险。</p>

<p>   另一方面，互联网行业不仅市场变化快，而且技术变化也快。譬如，短短几年几年时间，光前端JavaScript的框架，就出现了好几十个，从早一点的<a href="http://backbonejs.org/">Backbone</a>、<a href="http://emberjs.com">Ember</a>到<a href="https://angularjs.org">AngularJS</a>、<a href="http://www.ractivejs.org/">Ractive</a>等等。类似的，后端的框架、工具等也是层出不穷，有兴趣的朋友可以参考下<a href="http://www.thoughtworks.com/radar">ThoughtWorks的技术雷达</a>(该技术雷达是ThoughtWorks对业界技术、工具、语言等发展趋势的分析以及预测报告)。因此，对单块架构的应用而言，初始的技术选型严重限制了其将来采用不同语言或框架的能力。如果想尝试新的编程语言或者框架，没有完备的功能测试集，很难平滑的完成替换，而且系统规模越大，风险越高。</p>

<h5>5.可伸缩性差</h5>

<p>  如果应用程序的所有功能代码都运行在同一个服务器上，将会导致应用程序的扩展非常困难。如果迫切的需要扩展，那么垂直扩展可能是最容
易的（钱不是问题）。在大多数情况下，如果舍得砸钱上IBM的服务器、Oracle的数据库或者来自EMC的存储设备，不用改变一行代码，整个世界都变好了。不幸的是，伴随着业务的增长，数据的增长，垂直扩展会变得越来越吃力，成本越来越高。这也是为什么在业很多公司开始尝试使用开源，放弃这些昂贵的IOE产品的原因。这下明白为什么近几年去IOE的呼声越来越高了吧。</p>

<p>  当考虑水平扩展时，通常的做法是建立一个集群，通过在集群中不断的添加新节点，然后借助前端的负载均衡器，将用户的
请求按照某种算法，譬如轮转法、散列法或者最小连接法等合理的将请求分配到不同的节点上。但是，由于所有程序代码都运行在服务器上的同一个进程中，会导致应用程序的水平扩展成本非常高。譬如说，如果应用程序某部分的功能是内存密集型的，如需要缓存大量数据，而另外一部分功能是CPU密集型的，如需要进行大量的运算，那么每次实施水平扩展，运行该应用的服务器都必须有足够的内存和强劲的CPU来满足需求。因此，鉴于每个服务器都要提供该应用系统所需要的各种资源，基础设施的整体花费可能会非常高。当然，如果某些节点保持状态，如用户登陆后的会话信息等，更增加了水平扩展的难度。</p>

<h5>6.构建全功能团队难</h5>

<p>   最后，非常微妙的是，随着应用程序的功能越来越多，代码变得越来越复杂，其应用程序的复杂结构也会逐渐映射到研发团队的
结构上。康威定律指出：一个组织的设计成果，其结构往往对应于这个组织中的沟通结构。单块架构的开发模式在分工时往往以技能为单位，比如UX团队、服务端团队和数据库团队，这样的分工可能会导致任何功能上的改变都需要跨团队沟通和协调。譬如说，用户体验工程师（UX）更专注负责用户接口部分，业务层开发者则负责建立服务器后端的业务逻辑，数据库工程师和DBA们更关注数据访问组件和数据库。鉴于这些问题，随着时间的推移，不仅代码越来越难以管理，其对团队结构的影响也越来越明显。</p>

<p><img src="http://wldandan.github.com/images/microservice-design-and-practice/chapter1/build-team-aroud-business-800-600.png" /></p>

<p>综上所述，随着业务的不断扩大，需求功能的持续增加，单块架构已经很难满足业务快速变化的需要。一方面，代码的可维护性、扩展性、灵活性在降低；而另一方面，系统的测试成本、构建成本以及维护成本却在显著增加。因此，随着项目或者产品规模的不断扩大，单块架构应用的改造与重构势在必行。</p>

<hr />

<h3>总结</h3>

<p>   互联网时代的产品通常有几类特点：创新成本低、需求变化快，用户群体庞大，它和几年前我们熟悉的单块
架构应用有着本质的不同。随着市场变化快、用户需求变化快、用户访问量增加的同时，单块架构应用的维护成本、人员的培养成本、缺陷修复成本、技术架构演进的成本、系统扩展成本等都在增加，因此单块架构曾经的优势已逐渐无法适应互联网时代的快速变化，面临着越来越多的挑战。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[基于微服务架构，改造企业核心系统之实践]]></title>
    <link href="http://wldandan.github.com/blog/2014/09/16/shi-yong-wei-fu-wu-gai-zao-qi-ye-he-xin-ye-wu-xi-tong-shi-jian/"/>
    <updated>2014-09-16T21:57:00+08:00</updated>
    <id>http://wldandan.github.com/blog/2014/09/16/shi-yong-wei-fu-wu-gai-zao-qi-ye-he-xin-ye-wu-xi-tong-shi-jian</id>
    <content type="html"><![CDATA[<p>本文已经发表于InfoQ，请参考<a href="http://www.infoq.com/cn/articles/enterprise-core-systems-transformation-practice">这里</a></p>

<h2>背景与挑战</h2>

<p>随着公司国际化战略的推行以及本土业务的高速发展，后台支撑系统已经不堪重负。</p>

<p>在吞吐量、稳定性以及可扩展性上都无法满足日益增长的业务需求。对于每10万元额度的合同，从销售团队准备材料、与客户签单、递交给合同部门，再到合同生效大概需要3.5人天。随着业务量的快速增长，签订合同的成本急剧增加。</p>

<p>合同管理系统是后台支撑系统中重要的一部分。当前的合同系统是5年前使用.NET，基于<a href="http://www.sagecrm.com/">SAGE CRM</a>二次开发的产品。
一方面，系统架构过于陈旧，性能、可靠性无法满足现有的需求。另一方面，功能繁杂，结构混乱，定制的代码与SAGE CRM系统耦合度极高。</p>

<p>由于是遗留系统，熟悉该代码的人早已离职多时，新团队对其望而却步，只能做些周边的修补工作。同时，还要承担着边补测试，边整理逻辑的工作。</p>

<p>在无法中断业务处理的情况下，为了解决当前面临的问题，团队制定了如下的策略：</p>

<p><img src="http://wldandan.github.com/images/microservice/crm-rebuild-strategy-600x400.png" /></p>

<ol>
<li>在现有合同管理系统的外围，构建功能服务接口，将系统核心的功能分离出来。</li>
<li>利用这些功能服务接口作为代理，解耦原合同系统与其调用者之间的依赖；</li>
<li>通过不断构建功能服务接口，逐渐将原有系统分解成多个独立的服务。</li>
<li>摒弃原有的合同管理系统，使用全新构建的(微)服务接口替代。</li>
</ol>


<!--more-->


<h2>什么是微服务</h2>

<p>多年来，我们一直在技术的浪潮中不断乘风破浪，扬帆奋进，寻找更好的方式构建IT系统。</p>

<p>微服务架构(Micro Service Architect)，是近一段时间在软件体架构领域里出现的一个新名词。它通过将功能分解到多个独立的服务中以实现对解决方案或者复杂系统的解耦。</p>

<p>微服务的诞生并非偶然：<a href="http://dddcommunity.org/">领域驱动设计</a>指导我们如何分析并模型化复杂的业务；<a href="http://agilemethodology.org/">敏捷方法论</a>帮助我们消除浪费，快速反馈；<a href="http://agilemethodology.org/">持续交付</a>促使我们构建更快、更可靠、更频繁的软件部署和交付能力；虚拟化和基础设施自动化(Infrasture As Code)则帮助我们简化环境的创建、安装；<a href="http://dev2ops.org/2010/02/what-is-devops/">DevOps</a>文化的流行以及特性团队的出现，使得小团队更加全功能化。这些都是推动微服务诞生的重要因素。</p>

<p>实际上，微服务本身并没有一个严格的定义。不过从业界的讨论来看，微服务通常有如下几个特征:</p>

<h3>小，且专注于做一件事情</h3>

<p>每个服务都是个很小的应用，至于有多小，是一个非常有趣的话题。有人喜欢100行以内，有人赞成1000行以内。数字并不是最重要的，仁者见仁，智者见智，只要团队觉得合适就好。</p>

<p>只关注一个业务功能。这一点和我们平常谈论的面向对象原则中的&#8221;单一原则&#8221;类似，每个服务只做一件事情，并且把它做好。</p>

<h3>运行在独立的进程中</h3>

<p>每个服务都运行在一个独立的操作系统进程，这意味着不同的服务能被部署到不同的主机上。</p>

<h3>轻量级的通信机制</h3>

<p>服务和服务之间通过轻量级的机制实现彼此间的通信。所谓轻量级通信机制，通常指基于语言无关、平台无关的这类协议，例如XML、JSON，而不是传统我们熟知的Java RMI或者.Net Remoting等。</p>

<h3>松耦合</h3>

<p>不需要改变依赖，只更改当前服务本身，就可以独立部署。这意味着该服务和其他者服务之间在部署和运行上呈现相互独立的状态。</p>

<p>综上所述，微服务架构采用多个服务间互相协作的方式构建传统应用。每个服务独立运行在不同的进程中，服务之与服务之间通过轻量的通讯机制交互，并且每个服务可以通过自动化部署方式独立部署。</p>

<h2>微服务的优势</h2>

<p>相比传统的单块架构系统(monolithic)，微服务在如下诸多方面有着显著的优势：</p>

<h4>异构性</h4>

<p>问题有其具体性，解决方案也应有其针对性。用最适合的技术方案去解决具体的问题，往往会事半功倍。传统的单块架构系统倾向采用统一的技术平台或方案来解决所有问题。而微服务的异构性，可以针对不同的业务特征选择不同的技术方案，有针对性的解决具体的业务问题。</p>

<p>对于单块架构的系统，初始的技术选型严重限制将来采用不同语言或框架的能力。如果想尝试新的编程语言或者框架，没有完备的功能测试集，很难平滑的完成替换，而且系统规模越大，风险越高。基于微服务架构，使我们更容易地在遗留系统上尝试新的技术或解决方案。譬如说，
可以先挑选风险最小的服务作为尝试，快速得到反馈后再决定是否试用于其他服务。这也意味着，即便对一项新技术的尝试失败的话，尽可以抛弃这个方案，并不会对整个产品带来风险。</p>

<p><img src="http://wldandan.github.com/images/microservice/micro-service-advantages-600x400.png" /></p>

<p>上图引用自Martin Fowler的<a href="http://martinfowler.com/articles/microservices.html">Microservices</a>一文。</p>

<h4>独立测试与部署</h4>

<p>单块架构系统运行在一个进程中，因此系统中任何程序的改变，都需要对整个系统重新测试并部署。
而对微服务架构而言，不同服务之间的打包、测试或者部署等，与其它服务都是完全独立的。对某个服务所做的改动，只需要关注该服务本身。从这个角度来说，使用微服务后，代码修改、测试、打包以及部署的成本和风险都比单块架构系统降低很多。</p>

<h4>按需伸缩</h4>

<p>单块架构系统由于单进程的局限性，水平扩展时只能基于整个系统进行扩展，无法针对某一个功能模块按需扩展。
而服务架构则可以完美的解决伸缩性的扩展问题。系统可以根据需要，实施细粒度的自由扩展。</p>

<h4>错误隔离性</h4>

<p>微服务架构同时也能提升故障的隔离性。例如，如果某个服务的内存泄露，则只会影响到自己，其他服务能够继续正常地工作。与之形成对比的是，单块架构中如果有一个不合格的组件发生异常，有可能会拖垮整个系统。</p>

<h4>团队全功能化</h4>

<p>康威定律（Conway&#8217;s law）指出：</p>

<p><code>organizations which design systems are constrained to produce designs which are copies of the communication structures of these organizations.</code></p>

<p><code>一个组织的设计成果，其结构往往对应于这个组织中的沟通结构。</code></p>

<p>传统的开发模式在分工时往往以技术为单位，比如UI团队、服务端团队和数据库团队，这样的分工可能会导致任何功能上的改变都需要跨团队沟通和协调。而微服务则倡导围绕服务来分工，团队需要具备服务设计、开发、测试到部署所需的所有技能。</p>

<h2>微服务快速开发实践</h2>

<p>随着团队对业务的理解加深和对微服务实践的尝试，数个微服务程序已经成功构建出来。不过，问题同时也出现了：对于这些不同的微服务程序而言，虽然具体实现的代码细节不同，但其结构、开发方式、持续集成环境、测试策略、部署机制以及监控和告警等，都有着类似的实现方式。那么如何满足<a href="http://programmer.97things.oreilly.com/wiki/index.php/Don't_Repeat_Yourself">DRY原则</a>并消除浪费呢？</p>

<p>带着这个问题，经过团队的努力，Stencil诞生了。
Stencil是一个帮助快速构建Ruby微服务应用的开发框架，主要包括四部分：Stencil模板、代码生成工具，持续集成模板以及一键部署工具。</p>

<p><img src="http://wldandan.github.com/images/microservice/stencil-template-structure-details-600x400.png" /></p>

<h3>Stencil模板</h3>

<p>Stencil模板是一个独立的Ruby代码工程库，主要包括代码模板以及一组配置文件模板。</p>

<p>代码模板使用<a href="https://github.com/basho/webmachine">Webmachine</a>作为Web框架，<a href="http://en.wikipedia.org/wiki/Representational_state_transfer">RESTful</a>和JSON构建服务之间的通信方式，RSpec作为测试框架。同时，代码模板还定义了一组Rake任务，譬如运行测试，查看测试报告，将当前的微服务生成RPM包，使用Koji给RPM包打标签等。</p>

<p>除此之外，该模板也提供了一组通用的URL，帮助使用者查看微服务的当前版本、配置信息以及检测该微服务程序是否健康运行等。</p>

<pre><code>[
    {
        rel: "index",
        path: "/diagnostic/"
    },
    {
        rel: "version",
        path: "/diagnostic/version"
    },
    {
        rel: "config",
        path: "/diagnostic/config"
    },
    {
        rel: "hostname",
        path: "/diagnostic/hostname"
    },
    {
        rel: "heartbeat",
        path: "/diagnostic/status/heartbeat"
    },
    {
        rel: "nagios",
        path: "/diagnostic/status/nagios"
    }
]
</code></pre>

<p>配置文件模板主要包括<a href="http://newrelic.com/">NewRelic</a>配置，<a href="https://www.phusionpassenger.com/">Passenger</a>配置、<a href="http://www.nagios.org/">Nagios</a>配置、<a href="http://httpd.apache.org/">Apache</a>配置以及<a href="http://www.splunk.com/">Splunk</a>配置。通过定义这些配置文件模板，当把新的微服务程序部署到验收环境或者产品环境时，我们立刻就可以使用Nagios、NewRelic以及Splunk等第三方服务提供的功能，帮助我们有效的监控微服务，并在超过初始阈值时获得告警。</p>

<h3>代码生成工具</h3>

<p>借助Stencil代码生成工具，我们能在很短的时间内就构建出一个可以立即运行的微服务应用程序。随着系统越来越复杂，微服务程序的不断增多，Stencil模板和代码生成工具帮助我们大大简化了创建微服务的流程，让开发人员更关注如何实现业务逻辑并快速验证。</p>

<pre><code>Create a project from the stencil template (version 0.1.27)
        --name, -n &lt;s&gt;:   New project name. eg. things-and-stuff
   --git-owner, -g &lt;s&gt;:   Git owner (default: which team or owner)
        --database, -d:   Include database connection code
  --triggered-task, -t:   Include triggered task code
        --provider, -p:   Is it a service provider? (other services use this service)
        --consumer, -c:   Is it a service consumer? (it uses other services)
      --branch, -b &lt;s&gt;:   Specify a particular branch of Stencil
       --face-palm, -f:   Overide name validation 
            --help, -h:   Show this message
</code></pre>

<p>如上图所示，通过指定不同参数，我们能创建具有数据库访问能力的微服务程序、或者是包含异步队列处理的微服务程序。同时，我们也可以标记该服务是数据消费者还是数据生产者，能帮助我们理解多个微服务之间的联系。</p>

<h3>持续集成模板</h3>

<p>基于持续集成服务器<a href="https://www.atlassian.com/software/bamboo">Bamboo</a>，团队创建了针对Stencil的持续集成模板工程，并定义了三个主要阶段：</p>

<ul>
<li>打包：运行单元测试，集成测试，等待测试通过后生成RPM包。</li>
<li>发布：将RPM包发布到<a href="http://koji.fedoraproject.org/koji/">Koji</a>服务器上，并打上相应的Tag。然后使用<a href="http://www.packer.io/">Packer</a>在亚马逊AWS云环境中创建AMI，建好的AMI上已经安装了当前微服务程序的最新RPM包。</li>
<li>部署：基于指定版本的AMI，将应用快速部署到验收环境或者产品环境上。</li>
</ul>


<p>利用持续集成模板工程，团队仅需花费很少的时间，就可以针对新建的微应用程序，在Bamboo上快速定义其对应的持续集成环境。</p>

<h3>一键部署工具</h3>

<p>所有的微服务程序都部署并运行在亚马逊AWS云环境上。同时，我们使用<a href="https://github.com/Netflix/asgard">Asgard</a>对AWS云环境中的资源进行创建、部署和管理。
Asgard是一套功能强大的基于Web的AWS云部署和管理工具，由Netflix采用<a href="http://grails.org/">Groovy on Grails</a>开发，其主要优点有：</p>

<pre><code>- 基于B/S的AWS部署及管理工具，使用户能通过浏览器直接访问AWS云资源，无需设置Secret Key和Access Key；
- 定义了`Application`以及`Cluster`等逻辑概念，更清晰、有效地描述了应用程序在AWS云环境中对应的部署拓扑结构。
- 在对应用的部署操作中，集成了AWS Elastic Load Balancer、AWS EC2以及AWS Autoscaling Group，并将这些资源自动关联起来。
- 提供RESTful接口，能够方便的与其他系统集成。
- 简洁易用的用户接口，提供可视化的方式完成一键部署以及流量切换。
</code></pre>

<p>由于Asgard对RESTful的良好支持，团队实现了一套基于Asgard的命令行部署工具，只需如下一条命令，提供应用程序的名称以及版本号，就可自动完成资源的创建、部署、流量切换、删除旧的应用等操作。</p>

<pre><code>asgard-deploy [AppName] [AppVersion]
</code></pre>

<p>同时，基于命令行的部署工具，也可以很容易的将自动化部署集成到Bamboo持续集成环境。</p>

<p>通过使用微服务框架Stencil，大大缩短了团队开发微服务的周期。同时，基于Stencil，我们定义了一套团队内部的开发流程，帮助团队的每一位成员理解并快速构建微服务。</p>

<h2>微服务架构下的新系统</h2>

<p>经过5个月的努力，我们重新构建了合同管理系统，将之前的产品、价格、销售人员、合同签署、合同审查以及PDF生成都定义成了独立的服务接口。相比之前大而全、难以维护的合同管理系统而言，新的系统由不同功能的微服务组成，每个微服务程序只关注单一的功能。每个微服务应用都有相关的负责人，通过使用<a href="http://www.pagerduty.com/">Page Duty</a>建立消息通知机制。每当有监控出现告警的时候，责任人能立即收到消息并快速做出响应。</p>

<p><img src="http://wldandan.github.com/images/microservice/micro-service-app-600x400.png" /></p>

<p>由于微服务具有高内聚，低耦合的特点，每个应用都是一个独立的个体，当出现问题时，很容易定位问题并解决问题，大大缩短了修复缺陷的周期。
另外，通过使用不同功能的微服务接口提供数据，用户接口(UI)部分变成了一个非常简洁、轻量级的应用，更关注如何渲染页面以及表单提交等交互功能。</p>

<h3>总结</h3>

<p>通过使用微服务架构，在不影响现有业务运转的情况下，我们有效的将遗留的大系统逐渐分解成不同功能的微服务接口。</p>

<p>同时，通过Stencil微服务开发框架，我们能够快速的构建不同功能的微服务接口，并能方便的将其部署到验收环境或者产品环境。</p>

<p>最后，得益于微服务架构的灵活性以及扩展性，使得我们能够快速构建低耦合、易扩展、易伸缩性的应用系统。</p>

<h3>参考文献</h3>

<p>http://martinfowler.com/articles/microservices.html <br/>
http://jaxenter.com/cracking-microservices-practices-50692.html<br/>
http://microservices.io/patterns/microservices.html</p>
]]></content>
  </entry>
  
</feed>
