<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Happy Coding, Happy Life]]></title>
  <link href="http://wldandan.github.com/atom.xml" rel="self"/>
  <link href="http://wldandan.github.com/"/>
  <updated>2016-11-15T23:18:22+08:00</updated>
  <id>http://wldandan.github.com/</id>
  <author>
    <name><![CDATA[wldandan]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[微服务实战(3) - Spring Boot 101]]></title>
    <link href="http://wldandan.github.com/blog/2016/11/15/microservices-in-action-spring-boot-101/"/>
    <updated>2016-11-15T17:57:00+08:00</updated>
    <id>http://wldandan.github.com/blog/2016/11/15/microservices-in-action-spring-boot-101</id>
    <content type="html"><![CDATA[<p>过去的几个月，我作为独立咨询师，为多个传统企业提供了微服务架构的培训、咨询以及交付工作。在这些企业中，大部分的开发者对微服务的理解，以“银弹观念”为主。实际上，传统企业在过去多年的业务积累中，由于组织架构、业务发展和市场竞争等综合因素，技术体系相对封闭，缺乏快速交付的理念。因此，微服务的出现，加之社区的热捧，导致这种现象出现也是比较能理解的。</p>

<p>经过2015年的快速普及，微服务的优势被越来越多的传统组织和企业所认可，但由于架构相关的知识本身比较抽象，虽然各大会议上有很多互联网公司的案例分享，但开发者似乎依然很难全面了解微服务架构。</p>

<p>所以，希望通过本系列的文章，以一个模拟的案例为背景，以持续交付和DevOps为主线，帮助初学者理解微服务架构，并能通过动手实验，了解相关的实践以及方法论。</p>

<!-- More -->


<h2>为什么是Spring Boot</h2>

<p>在Java开发领域，估计没有多少兄弟不知道Spring，当年的SSH组合，风靡全国，成为J2EE Web开发的标准。
加上Spring对其他企业特性的强大支持，为构建Java的企业应用提供了<code>全家桶</code>的解决方案。</p>

<p><img src="http://wldandan.github.com/images/microservice-in-action-with-spring/spring-boot/spring-io-600-450.png" /></p>

<p>对于现代Java开发，尤其是以微服务为主的应用，虽然有<a href="https://dropwizard.github.io/">DropWizard</a>、<a href="https://ee.kumuluz.com/">KumuluzEE</a>等微服务框架的诞生，但Spring Boot借助极致的Convention Over Configuration，加上对SpringFramework的无缝支持，被社区普遍看好。</p>

<p>在今年10月中旬结束的<a href="https://jaxlondon.com/jax-awards/">2016 JAX Java Innovation</a>评选中，Spring Boot一举拔得头筹，而去年Java领域的这个奖项是颁给了著名的Netflix OSS，足以证明Spring Boot在社区的影响力。</p>

<p><img src="http://wldandan.github.com/images/microservice-in-action-with-spring/spring-boot/jax-award-spring-boot-600-450.png" /></p>

<h2>Spring Boot的优势</h2>

<ul>
<li><code>快速构建</code>可运行的应用

<ul>
<li><code>无XML配置</code></li>
<li>支持<code>内嵌</code>WebServer(Tomcat/Jetty/Undertow)</li>
<li>通过<code>注解</code>的方式，一行代码启动应用</li>
</ul>
</li>
<li><code>自动配置</code>和<code>装载机制</code>

<ul>
<li>使用Starter</li>
<li>自动配置装载依赖</li>
</ul>
</li>
<li>运维接口友好

<ul>
<li><code>Metrics/health</code>显示健康监控状态</li>
<li><code>Trace/dump</code>显示调用/调试信息</li>
</ul>
</li>
</ul>


<h2>Spring Boot核心</h2>

<h3>简单的说，Spring Boot的核心，主要包括两大部分：</h3>

<blockquote><p>1.Starter</p></blockquote>

<p>各种Starter负责实现相关依赖Jar包的导入和管理，譬如Spring-Web-MVC，Spring-Data等</p>

<blockquote><p>2.AutoConfiguratioin</p></blockquote>

<p>AutoConfiguratioin则根据Conditional条件完成对Bean的创建和组装</p>

<p>所以, 我对SpringBoot的理解为</p>

<ul>
<li>Starter打包提供相关的包依赖，加载到ClassPath</li>
<li>EnableAutoConfiguration配置Bean的依赖关系</li>
</ul>


<p>二者配合起来，天下无敌啊&#8230;.</p>

<h3>另外，每个SpringBoot应用上都会加标签@SpringBootApplication</h3>

<p>这个标签是SpringBoot应用的核心标签，主要包括三部分子：</p>

<ul>
<li>@Configuration</li>
</ul>


<p>Spring3.0引入@Configuration(Java配置)，使用Java配置简化XML配置。</p>

<p>譬如以前我们通常使用类似如下XML配置Spring Bean</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;beans xmlns="http://www.springframework.org/schema/beans"
</span><span class='line'>  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
</span><span class='line'>  xsi:schemaLocation="http://www.springframework.org/schema/beans
</span><span class='line'>  http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt;
</span><span class='line'>
</span><span class='line'>  &lt;bean id="helloBean" class=“com.microservice.training.HelloWorldImpl"&gt;
</span><span class='line'>&lt;/beans&gt;</span></code></pre></td></tr></table></div></figure>


<p>通过使用Java Configuration，声明当前类是一个配置类， 相当于声明一个Spring配置的XML文件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@Configuration
</span><span class='line'>public class AppConfig {
</span><span class='line'>
</span><span class='line'>    @Bean(name="helloBean")
</span><span class='line'>    public HelloWorld helloWorld() {
</span><span class='line'>        return new HelloWorldImpl();
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ul>
<li>@EnableAutoConfiguration</li>
</ul>


<p>它帮助我们加载当前Spring Boot中META-INF/spring.factories，并使用其中的*AutoConfiguration</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>HttpEncodingAutoConfiguration
</span><span class='line'>RabbitAutoConfiguration 
</span><span class='line'>EmbeddedServletContainerAutoConfiguration
</span><span class='line'>……</span></code></pre></td></tr></table></div></figure>


<p>每个AutoConfiguration都会根据其中的Condition条件，在合适的场景完成对相关Bean的创建</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@ConditionalOnBean //容器里有指定Bean存在
</span><span class='line'>@ConditionalOnClass //类路径下有指定Class存在
</span><span class='line'>@ConditionalOnWebApplication //当前项目是Web项目
</span><span class='line'>……</span></code></pre></td></tr></table></div></figure>


<ul>
<li>@ComponentScan</li>
</ul>


<p>它定义Spring了自动加载Bean的根路径，是Spring Framwork中较早的一个标签，这里就不赘述了。</p>

<h2>快速构建Spring Boot应用</h2>

<p>Spring Boot提供了方便的项目创建方式，使得我们可以快速创建基于SpringBoot的项目：</p>

<ul>
<li>使用<a href="http://sdkman.io/">命令行CLI</a></li>
<li>使用<a href="start.spring.io">Initializr</a></li>
<li>使用IDE(IDEA，Spring Tool Suite等)</li>
</ul>


<h2>总结</h2>

<p>  通过理论+模拟+实战的方式，梳理微服务的生态系统，并以持续交付和DevOps的实施为主线，体系化的形成微服务从0到1的学习过程。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[微服务实战(2) - 目标系统]]></title>
    <link href="http://wldandan.github.com/blog/2016/11/15/microservices-in-action-simulation/"/>
    <updated>2016-11-15T14:28:00+08:00</updated>
    <id>http://wldandan.github.com/blog/2016/11/15/microservices-in-action-simulation</id>
    <content type="html"><![CDATA[<p>过去的几个月，我作为独立咨询师，为多个传统企业提供了微服务架构的培训、咨询以及交付工作。在这些企业中，大部分的开发者对微服务的理解，以“银弹观念”为主。实际上，传统企业在过去多年的业务积累中，由于组织架构、业务发展和市场竞争等综合因素，技术体系相对封闭，缺乏快速交付的理念。因此，微服务的出现，加之社区的热捧，导致这种现象出现也是比较能理解的。</p>

<p>经过2015年的快速普及，微服务的优势被越来越多的传统组织和企业所认可，但由于架构相关的知识本身比较抽象，虽然各大会议上有很多互联网公司的案例分享，但开发者似乎依然很难全面了解微服务架构。</p>

<p>所以，希望通过本系列的文章，以一个模拟的案例为背景，以持续交付和DevOps为主线，帮助初学者理解微服务架构，并能通过动手实验，了解相关的实践以及方法论。</p>

<!-- More -->


<h2>目标系统</h2>

<blockquote><p>构建一个用户查看活动、报名活动、接收通知的系统</p>

<ul>
<li>匿名用户可查看活动列表</li>
<li>匿名用户可以查看活动详情</li>
<li>匿名用户可以查看相关活动推荐和评论</li>
<li>用户登陆成功后完成报名</li>
<li>报名成功，用户获取通知</li>
</ul>
</blockquote>

<h2>服务定义</h2>

<blockquote><p>关于服务的划分，是一个非常有深度的话题，与业务场景、技术实现、团队能力有着密不可分的关系。
从方法论上有：</p>

<ul>
<li>根据<a href="https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215">DDD</a>，包括业务上下文、事件驱动、读写分离等</li>
<li>根据名词类对象，譬如商品、订单等</li>
<li>根据动词类行为，譬如支付，预订等</li>
<li>其他切入点</li>
</ul>


<p>在这个模拟场景中，为了保持简洁，我假定使用名词和动词进行划分，包括如下：</p></blockquote>

<ul>
<li><code>活动服务Event-service</code>(提供活动的列表和活动详情的相关数据）</li>
<li><code>推荐服务Recommendation-service</code>(提供与某个活动相关的推荐信息)</li>
<li><code>评论服务Review-service</code>(提供与某个活动相关的评论信息)</li>
<li><code>活动聚合服务Event-composite-service</code>(聚合服务 - 提供某个活动及其相关的推荐、评论信息</li>
<li><code>报名服务Enroll-service</code>(为登录用户提供报名)</li>
<li><code>通知服务Notification-service</code>(用户报名成功后获取通知)</li>
</ul>


<blockquote><p>该活动报名系统的应用架构图如下：</p></blockquote>

<p><img src="http://wldandan.github.com/images/microservice-in-action-with-spring/events-system-architecture-600-450.png" /></p>

<h2>服务实现</h2>

<ul>
<li>Java 8/Gradle 2.13</li>
<li>SpringBoot 1.4.2 / SpringCloud Camden.SR2</li>
<li>MongoDB 使用Document存储活动数据</li>
<li>REST/HAL/HAL-Browser 定义服务之间通信的接口</li>
<li>JVM-Pact 实现契约测试,服务间接口的测试</li>
</ul>


<h2>服务支撑组件</h2>

<ul>
<li>Netflix OSS Eureka 实现服务注册</li>
<li>Spring Cloud Config 实现服务的配置</li>
<li>Hystrix/Turbine 实现断路器</li>
<li>Zuul 实现API网关</li>
<li>Spring Cloud Security 实现安全</li>
</ul>


<h2>基础设施</h2>

<ul>
<li>ELK 提供服务的日志的聚合服务</li>
<li>Prometheus 提供服务的监控与告警</li>
<li>Jenkins 2.0搭建系统的持续交付流水线</li>
<li>Docker提供服务的打包以及发布</li>
<li>Rancher提供Docker的轻量级管理方案</li>
</ul>


<blockquote><p>该活动报名系统的微服务生态系统图如下：</p></blockquote>

<p><img src="http://wldandan.github.com/images/microservice-in-action-with-spring/microservices-eco-system-adoption-600-450.png" /></p>

<h2>总结</h2>

<p>  通过理论+模拟+实战的方式，梳理微服务的生态系统，并以持续交付和DevOps的实施为主线，体系化的形成微服务从0到1的学习过程。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[微服务实战(1) - 内容大纲]]></title>
    <link href="http://wldandan.github.com/blog/2016/11/11/microservices-in-action-outline/"/>
    <updated>2016-11-11T14:28:00+08:00</updated>
    <id>http://wldandan.github.com/blog/2016/11/11/microservices-in-action-outline</id>
    <content type="html"><![CDATA[<script src="https://cdn1.lncld.net/static/js/av-mini-0.6.10.js"></script>


<script src="http://jerry-cdn.b0.upaiyun.com/hit-kounter/hit-kounter-lc-0.2.0.js"></script>


<p>过去的几个月，我作为独立咨询师，为多个传统企业提供了微服务架构的培训、咨询以及交付工作。在这些企业中，大部分的开发者对微服务的理解，以“银弹观念”为主。实际上，传统企业在过去多年的业务积累中，由于组织架构、业务发展和市场竞争等综合因素，技术体系相对封闭，缺乏快速交付的理念。因此，微服务的出现，加之社区的热捧，导致这种现象出现也是比较能理解的。</p>

<p>经过2015年的快速普及，微服务的优势被越来越多的传统组织和企业所认可，但由于架构相关的知识本身比较抽象，虽然各大会议上有很多互联网公司的案例分享，但开发者似乎依然很难全面了解微服务架构。</p>

<p>所以，希望通过本系列的文章，以一个模拟的案例为背景，以持续交付和DevOps为主线，帮助初学者理解微服务架构，并能通过动手实验，了解相关的实践以及方法论。</p>

<!-- More -->


<h2>核心思路</h2>

<ul>
<li>以<code>微服务生态系统</code>和<code>持续交付</code>为指导原则</li>
<li>以<code>模拟案例实战</code>为主，并使<code>用SpringBoot</code>和<code>Spring Cloud</code>实现服务</li>
<li>分为<code>服务构建</code>与<code>服务实施</code>两个专题，包括<code>应用架构</code>，<code>部署模型</code>和<code>交付流水线</code></li>
</ul>


<h2>主要亮点</h2>

<h4>1.全面了解微服务架构的理论基础</h4>

<ul>
<li>微服务的定义与认识误区</li>
<li>微服务的核心原则以及同SOA的关系</li>
<li>微服务的<code>持续交付体系</code></li>
</ul>


<h4>2.基于微服务生态系统，搭建模拟案例</h4>

<ul>
<li>通过案例理解<code>微服务架构生态系统</code></li>
<li>掌握<code>REST &amp; HAL &amp; HAL Browser</code>的使用方式</li>
<li>掌握<code>Spring Boot</code>的核心与使用</li>
<li>熟悉<code>Spring Cloud</code>的服务支撑组件</li>
</ul>


<blockquote><p>微服务生态系统</p></blockquote>

<p><img src="http://wldandan.github.com/images/microservice-in-action-with-spring/microservices-eco-system-600-450.png" /></p>

<h4>3.理解微服务的高级话题</h4>

<ul>
<li>使用<code>PACT契约测试</code>验证服务接口</li>
<li>使用<code>OAuth</code>与<code>JWT</code>实现服务的安全</li>
<li><code>RESTful API</code>设计相关</li>
</ul>


<blockquote><p>基于消费者驱动的契约测试</p></blockquote>

<p><img src="http://wldandan.github.com/images/microservice-in-action-with-spring/pact-600-450.png" /></p>

<h4>4.理解实施微服务与DevOps(基于Docker)</h4>

<ul>
<li>建立<code>Docker私有仓库</code>，并将服务发布成Docker镜像</li>
<li>使用<code>Docker搭建Jenkins</code>持续交付流水线</li>
<li>以<code>Pipeline as Code</code>的方式管理流水线</li>
<li>使用<code>ELK实现日志聚合</code>的实践</li>
<li>使用<code>Prometheus</code>实现监控告警的实践</li>
<li>使用<code>Rancher</code>完成服务Docker镜像的部署</li>
</ul>


<blockquote><p>部署模型图</p></blockquote>

<p><img src="http://wldandan.github.com/images/microservice-in-action-with-spring/events-system-deployment-600-450.png" /></p>

<blockquote><p>持续交付流水线</p></blockquote>

<p><img src="http://wldandan.github.com/images/microservice-in-action-with-spring/events-system-cd-600-450.png" /></p>

<h2>总结</h2>

<p>  通过理论+模拟+实战的方式，梳理微服务的生态系统，并以持续交付和DevOps的实施为主线，体系化的形成微服务从0到1的学习过程。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[微服务实战(0) - 聊聊开篇]]></title>
    <link href="http://wldandan.github.com/blog/2016/11/03/microservices-in-action-introduction/"/>
    <updated>2016-11-03T14:28:00+08:00</updated>
    <id>http://wldandan.github.com/blog/2016/11/03/microservices-in-action-introduction</id>
    <content type="html"><![CDATA[<p>过去的几个月，我作为独立咨询师，为多个传统企业提供了微服务架构的培训、咨询以及交付工作。在这些企业中，大部分的开发者对微服务的理解，以“银弹观念”为主。实际上，传统企业在过去多年的业务积累中，由于组织架构、业务发展和市场竞争等综合因素，技术体系相对封闭，缺乏快速交付的理念。因此，微服务的出现，加之社区的热捧，导致这种现象出现也是比较能理解的。</p>

<p>经过2015年的快速普及，微服务的优势被越来越多的传统组织和企业所认可，但由于架构相关的知识本身比较抽象，虽然各大会议上有很多互联网公司的案例分享，但开发者似乎依然很难全面了解微服务架构。</p>

<p>所以，希望通过本系列的文章，以一个模拟的案例为背景，以持续交付和DevOps为主线，帮助初学者理解微服务架构，并能通过动手实验，了解相关的实践以及方法论。</p>

<!-- More -->


<h2>为什么搞这么个系列</h2>

<h4>1.微服务涉及内容广泛，学习成本高</h4>

<p>微服务架构提倡将单一应用程序划分成一组小的服务，每个服务运行在独立的进程中，服务间采用轻量级的通信机制互相协作(通常是基于 HTTP 协议的 RESTful API )，每个服务都围绕着具体业务进行构建，并且能被独立的开发、测试、构建、部署和交付。</p>

<p>客观来说，微服务架构所涉及的内容，已经不仅仅是架构本身，还包括了持续集成、持续交付、自动化、部署/运维、监控以及DevOps等多个方面，这些方面互相配合、相辅相成，才能在微服务实施的过程中展现威力。</p>

<p>一个完整的微服务系统，在实施的过程中，可能还要考虑服务的公共支撑部分，包括但不限于：</p>

<ul>
<li>日志聚合(将不同服务实例上的日志聚合起来，便于分析、统计和定位问题)</li>
<li>监控和告警(监控每个服务的状态，必要时产生告警)</li>
<li>服务的注册和发现机制</li>
<li>服务的认证和鉴权</li>
<li>服务构建和打包机制</li>
<li>服务间的接口测试</li>
<li>持续集成/持续交付流水线</li>
<li>服务依赖关系管理</li>
<li>&#8230;&#8230;</li>
</ul>


<p>对于这么多的内容，如果能基于特定场景的理解与练习，再借鉴互联网公司的微服务实施案例，能够快速理解核心。</p>

<h3>2.《微服务与实践》一书，该更新更新了</h3>

<p>2015年4月，我开始撰写《微服务架构与实践》一书，当时国内微服务架构的概念还谈的比较少，所以《微服务架构与实践》侧重讲了微服务的理论基础和诞生背景，并分享了我在ThoughtWorks就职期间，实现微服务的工作方式（我们以持续交付和DevOps为核心，构建服务开发模板，并基于AWS实现快速发布，快速监控，快速反馈）。同时，也探讨了我们如何将遗留系统改造成微服务架构的策略和步骤，但由于精力有限，很多细节无法一一展开讨论。</p>

<p>另外，书中的大部分例子都是以Ruby和AWS为主，很多读者也提出了建议，希望给出采用Java实现的例子，容易理解和使用。</p>

<p>当今时代，技术发展的速度越来越快，诞生的框架、工具越来越多，虽然有心更新书的内容，但时间和精力都无法快速更新并发布新版，所以，这次希望能通过这个系列，能将过去的一些实践细化，包括DevOps、持续集成、持续交付以及使用Pact等实践，并采用Java(基于Spring Boot/Spring Cloud的快速发展)实现一个模拟的案例。</p>

<h3>3. 为感兴趣的传统开发者提供可用的案例</h3>

<p>过去两年微服务的快速发展，已经有很多传统企业开始尝试使用微服务解耦业务系统。传统企业和互联网企业的业务形态不一样，互联网公司业务变化快，响应速度快，组织愿意积极尝试开源的工具和方法论，降低交付成本和缩短交付周期。互联网领域中，大部分的产品，本身就是基于分布式系统构建，所以微服务的概念只是新瓶装旧酒。</p>

<p>而传统企业在过去多年的业务运作积累中，综合多种因素（组织结构、业务发展等），技术体系相对封闭，缺乏持续交付的理念。如果光有微服务的理论基础，和业界的成功案例，不动手尝试持续交付、DevOps等，很难有深刻的理解。</p>

<p>Github上微服务相关的实现Repo蛮多，但作为完整系列的不多，而且大部分也很难完整运行起来。</p>

<p>所以，基于这些原因，也希望能够总结之前的经验，结合为企业实施微服务架构培训的内容，系统化梳理并输出这个系列。</p>

<h2>总结</h2>

<p>最后，看看微服务发展的相关数据，🔥。</p>

<p><img src="http://wldandan.github.com/images/microservice-in-action-with-spring/google_trends.png" /></p>

<blockquote><p>上面是Google Trends上关于“Microservice”的增长趋势</p>

<p>左下是“Microservice”相关关键字的增长速度</p>

<p>右下是Indeed.com中对于microservice的市场招聘需求增长</p></blockquote>

<p>好吧，准备进入正题&#8230;..</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[微服务实践 - 使用HAL设计REST API]]></title>
    <link href="http://wldandan.github.com/blog/2016/10/09/wei-fu-wu-jia-gou-yu-shi-jian-apiwen-dang-hua/"/>
    <updated>2016-10-09T23:45:00+08:00</updated>
    <id>http://wldandan.github.com/blog/2016/10/09/wei-fu-wu-jia-gou-yu-shi-jian-apiwen-dang-hua</id>
    <content type="html"><![CDATA[<p>REST API通常作为服务间协作的轻量级通信协议(语言无关、平台无关)被广泛采用。</p>

<p>在微服务架构的中，如何有效的设计REST API，如何处理API响应中资源的依赖关系，服务规模化后如何提高服务团队间的协作效率&#8230;..这些都成为微服务实践中REST API设计的挑战。</p>

<p>本篇结合我在微服务项目中的实践，谈谈如何使用HAL优雅的设计REST API</p>

<!-- More -->


<h3>REST 101</h3>

<p>REST（Representational State Transfer，表述性状态传递）是近几年使用广泛的架构风格之一。在微服务架构的实践中，REST经常作为服务间协作的轻量级通信协议(语言无关、平台无关)被采用。</p>

<p>REST从语义层面将响应结果定义为资源，并使用HTTP协议的标准动词映射为对资源的操作，形成了一种以资源为核心、以HTTP协议为操作方式的，与语言无关、平台无关的服务间的通信机制。</p>

<p>通过资源表述、状态转移以及统一接口，REST将客户端的请求、服务器端的响应基于资源联系起来，形成一种以资源为核心、以HTTP协议为操作方式的，与语言无关、平台无关的通信机制。</p>

<p>同时，由于HTTP协议本身的无状态性，使用REST，能够有效保持服务应用的无状态型，并利于水平伸缩。</p>

<h3>REST不是银弹</h3>

<p>随着组织业务的不断增长，服务规模化的实施，以及响应内容复杂度的增加，REST的使用面临如下两个挑战：</p>

<ul>
<li>如何标准化资源结构</li>
</ul>


<p>使用REST，需要将业务场景的响应抽象为资源，并基于JSON或者XML的格式，返回给客户端。随着业务复杂度的增加，响应的内容会愈发复杂。</p>

<p>REST架构风格，并没有定义响应结构应该遵循什么标准。这也就意味着，在企业内部，不同的部门，不同的开发团队，对同一类资源，所定义的结构可能不尽相同；</p>

<p>譬如，如下是服务器端对客户端获取产品请求的的响应结果，两种结构都是合理的，但存在着差异</p>

<pre><code>GET http://bookstore.com/books/12 
Accept: application/json
</code></pre>

<hr />

<pre><code>响应结构一
{  
    "name":"Spring Boot In Action",  
    "category": "Book",  
    "price":69.00,  
    "ref": "http://bookstore.com/books/12",
    "created_at": "2015-05-01 10:00:00",
    "updated_at": "2015-06-01 11:00:00"
}  
</code></pre>

<hr />

<pre><code>响应结构二
{
  "basic_info":
  {
    "name":"Spring Boot In Action",
    "category":"Book"
    "price":69.00,
  },

  "ref":{
    "self": "http://bookstore.com/books/12”,
    “list": "http://bookstore.com/books"
  },

  "timestamp":{
    "created_at": "2015-05-01 10:00:00",
    "updated_at": "2015-06-01 11:00:00"
  }
}
</code></pre>

<p>因此，如何定义一套标准的资源响应结构，成为服务规模化后使用REST面临的一个挑战。</p>

<ul>
<li>如何处理资源的跳转链接</li>
</ul>


<p>在<a href="http://martinfowler.com/articles/richardsonMaturityModel.html">《Richardson Maturity Model》</a>模型中，定义了REST API不同成熟度应该具备的特征。</p>

<p>对于REST API Level 3，明确提出了&#8221;资源跳转的重要性&#8221;。</p>

<p>对于实际情况而言，大部分REST的实现，都是基于JSON作为传输格式，不过JSON最大的遗憾，正如W3C所描述的：</p>

<blockquote><p>JSON has no built-in support for hyperlinks, which are a fundamental building block on the Web.</p>

<p>没有对超链接处理做内建的支持，是JSON最大的遗憾。而这部分却恰恰是互联网的基石。</p></blockquote>

<p>这带来的潜在问题是，对于调用接口的Consumer而言，需要通过查看相关文档，才能了解如何获取相关的资源信息。譬如，某些社交系统可能会提供类似如下的接口文档，来帮助Consumer了解如何使用其提供的接口。</p>

<pre><code>https://api.example.com/users/1234567890      GET 获取用户明细
https://api.example.com/users/[ID]/friends    GET 获取用户相关的好友
https://api.example.com/users/[ID]/posts      GET 获取用户相关的文章
</code></pre>

<h3>HAL 101</h3>

<p>HAL（Hypertext Application Language）是一种轻量级超文本应用描述协议。HAL的实现基于REST，并对REST中资源结构无法标准化和不支持资源间跳转链接做了有效的互补。</p>

<p>目前，越来越多的企业和组织开始使用HAL提供标准化的服务接口，譬如</p>

<ul>
<li><p><a href="http://docs.aws.amazon.com/appstream/latest/developerguide/rest-api-application.html">AWS APP Stream API</a></p></li>
<li><p><a href="https://smxemail.com">SMXEmail API</a></p></li>
<li><p><a href="http://api.m.ox.ac.uk/browser/#/">牛津大学官方数据API</a></p></li>
</ul>


<p>更多案例请可以参考<a href="http://stateless.co/hal_specification.html">HAL官方网站</a>。</p>

<h3>HAL核心</h3>

<p>在HAL中，任何响应都被定义成一种资源（Resource），这是遵循REST原则对资源的定义标准。
同REST不同的是，在每个资源中，HAL又将其分成了如下三个标准的部分：</p>

<ul>
<li>状态(Resource State) - 通常指资源本身固有的属性，如之前提到的book的title、price等</li>
<li>链接(Links) - 定义了与当前资源相关的资源链接的集合</li>
<li>子资源(Embedded Resource) - 描述在当前资源的内部，其嵌套的资源。</li>
</ul>


<p><img src="http://wldandan.github.com/images/microservice-design-and-practice/rest-api-design/hal-model-400-300.png" /></p>

<h4>使用HAL定义单一资源(Resource)</h4>

<p>对于单一资源而言，如果没有使用HAL，通常我们会定义成这样：</p>

<pre><code>GET - /api/users/wldandan
Content-Type: application/json

{
    "id": "wldandan",
    "name": "Wang Lei",
    "email": "useremail@email.com",
    "wechat": "abcdefg"
}   
</code></pre>

<p>如果要访问用户相关的联系人资源，可以查看文档获取其他的API接口，如下所示：</p>

<pre><code>GET - /api/contacts/wldandan
Content-Type: application/json
.......
</code></pre>

<p>或者将相关信息放在之前返回的结果里：</p>

<pre><code>{
    "id": "wldandan",
    "name": "Wang Lei",
    "email": "useremail@email.com",
    "wechat": "abcdefg",
    "contacts": [
        {
            "id": "chenyue",
            "name": "Chen Yue"
            "link": "/api/users/chenyue"
        },
        {
            "id": "kouxi",
            "name": "Kou Xi"
            "link": "/api/users/chenyue"
        }
    ]
}   
</code></pre>

<p>如果基于HAL，则使用<em>links描述相关链接，同时使用</em>embedded描述嵌套资源，也就是：</p>

<pre><code>{
    "_links": {
        "self": {
            "href": "http://example.org/api/users/wldandan"
        }
    },
    "id": "wldandan",
    email: 'useremail@email.com',
    "name": "Wang Lei"
    wechat: 'abcdefg',

    "_embedded": {
        "contacts": [
        {
            "_links": {
                "self": {
                    "href": "http://example.org/api/users/chenyue"
                }
            },
            "id": "chenyue",
            "name": "Chen Yue"
        },
        {
            "_links": {
                "self": {
                    "href": "http://example.org/api/users/kouxi"
                }
            },
            "id": "kouxi",
            "name": "Kou Xi"
        }
        ]
    }
}
</code></pre>

<h4>使用HAL定义集合资源(Collection Resource)</h4>

<p>对于集合资源而言，如果没有使用HAL，通常我们会定义成这样：</p>

<pre><code>GET - /api/users
Content-Type: application/json

{
    total: 10
    page: 5
    page_size: 2
    users: [
    {
        id: 'wldandan',
        name: 'Wang Lei'
    },
    {
        id: 'chenyue',
        name: 'Chen Yue'
    },
    ]
}
</code></pre>

<p>基于HAL，则使用<em>links描述相关链接，同时使用</em>embedded描述嵌套资源，则如下所示：</p>

<pre><code>{
    "_links": {
        "self": {
            "href": "http://example.org/api/users?page=3"
        },
        "first": {
            "href": "http://example.org/api/users"
        },
        "prev": {
            "href": "http://example.org/api/users?page=2"
        },
        "next": {
            "href": "http://example.org/api/users?page=4"
        },
        "last": {
            "href": "http://example.org/api/users?page=5"
        }
    },
    "page_size": 2,
    "total": 10,
    "page": 5,
    "_embedded": {
        "users": [
            {
                "_links": {
                    "self": {
                        "href": "http://example.org/api/users/wldandan"
                    }
                },
                "id": "wldandan",
                "name": "Wang Lei"
            },
            {
                "_links": {
                    "self": {
                        "href": "http://example.org/api/user/chenyue"
                    }
                },
                "id": "chenyue",
                "name": "Chen Yue"
            }
        ]
    }
}
</code></pre>

<h3>在微服务实现中使用HAL</h3>

<h4>使用Spring-Data-Rest实现HAL</h4>

<h4>在Spring Boot中定制HAL</h4>

<h3>HAL与HATEOAS</h3>

<h3>参考资料</h3>

<p><a href="https://apigility.org/documentation/api-primer/halprimer">Hypertext Application Language</a>
<a href="http://blog.stateless.co/post/13296666138/json-linking-with-hal">JSON Linking with HAL</a>
<a href="Creating%20Service%20Contract%20with%20AutoRest,%20Swagger%20and%20HAL">Creating Service Contract with AutoRest, Swagger and HAL</a>
<a href="https://opencredo.com/hal-hypermedia-api-spring-hateoas/">Implementing HAL hypermedia REST API using Spring HATEOAS</a>
<a href="http://stateless.co/hal_specification.html">HAL Specification</a>
<a href="https://groups.google.com/forum/#!forum/hal-discuss">hal-discuss@google groups</a>
<a href="http://hyperschema.org/mediatypes/hal">HAL+JSON</a>
<a href="https://opencredo.com/rest-api-tooling-review/">Documenting REST APIs – a tooling review</a>
<a href="http://phlyrestfully.readthedocs.io/en/latest/halprimer.html">HAL Primer</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[解析微服务架构]]></title>
    <link href="http://wldandan.github.com/blog/2015/03/17/microservice-design-and-implementation/"/>
    <updated>2015-03-17T11:13:00+08:00</updated>
    <id>http://wldandan.github.com/blog/2015/03/17/microservice-design-and-implementation</id>
    <content type="html"><![CDATA[<p>过去的1年多，一直在助力澳洲最大的房地产互联网门户，研究并使用微服务架构改造其复杂的遗留系统。鉴于此，准备开个系列，讲讲我个人眼中的微服务是神马样的，它的概念，优缺点，为什么我们要使用它，以及在使用微服务的实践过程中，从开发、测试、部署、运维等几个方面相比以前方式有什么不同；同时，分享一下我们在微服务实践过程中的经验和踩过的那些坑。</p>

<!-- More -->


<p>目录大概如下</p>

<ul>
<li><h3>理论篇</h3>

<ul>
<li><h5>单块架构应用以及挑战</h5></li>
<li><h5>什么是微服务</h5></li>
<li><h5>微服务的核心特征</h5></li>
<li><h5>微服务的优缺点</h5></li>
<li><h5>微服务的适用场景</h5></li>
<li><h5>微服务与SOA</h5></li>
<li><h5>微服务诞生的催化剂</h5></li>
</ul>
</li>
<li><h3>实践篇</h3>

<ul>
<li><h5>麻雀虽小，五脏俱全</h5></li>
<li><h5>实现一个服务</h5></li>
<li><h5>微服务开发模板的重要性</h5></li>
<li><h5>不仅仅是REST</h5></li>
<li><h5>消费者驱动的契约测试</h5></li>
<li><h5>如何划分微服务</h5></li>
<li><h5>微服务的依赖管理</h5></li>
<li><h5>微服务与DevOPS</h5></li>
<li><h5>微服务与监控</h5></li>
</ul>
</li>
<li><h3>案例篇</h3>

<ul>
<li><h5>合同管理系统</h5></li>
<li><h5>市场定价系统</h5></li>
<li><h5>信息搜索系统</h5></li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[解析微服务架构(四)]]></title>
    <link href="http://wldandan.github.com/blog/2015/03/16/wei-fu-wu-jia-gou-she-ji-yu-shi-xian-4-wei-fu-wu-jia-gou-de-you-que-dian/"/>
    <updated>2015-03-16T22:07:00+08:00</updated>
    <id>http://wldandan.github.com/blog/2015/03/16/wei-fu-wu-jia-gou-she-ji-yu-shi-xian-4-wei-fu-wu-jia-gou-de-you-que-dian</id>
    <content type="html"><![CDATA[<p>[请勿转载]</p>

<h1>微服务架构的优缺点</h1>

<p>将单块架构应用分解为一系列相对独立的微服务，其中每个服务都运行在自己的进程中，并且通过轻量级的机制实现彼此间的通信，这通常是HTTP资源的微服务。这些服务是围绕着业务功能构建的，并且可以通过完全自动化的部署机制进行独立部署。这些服务的集中式管理做到了最小化，每一种服务都可以通过不同的编程语言进行编写，并且可以使用不同的数据存储技术。</p>

<!-- More -->


<p>从上面的定义可以看出，微服务的优势是显而易见的：</p>

<ul>
<li>每个服务都很简单，只关注于一个业务功能。</li>
<li>每个微服务可以由不同的团队独立开发。</li>
<li>微服务是松散耦合的。</li>
<li>微服务可以通过不同的编程语言与工具进行开发。</li>
</ul>


<p>这些优势使得微服务看起来是非常完美的解决方案，不过微服务难道就没有缺点么？下面我们就来探讨一下微服务在其实施过程中所遇到的问题和一些缺点。</p>

<h5>运维成本过高</h5>

<h5>DevOps是必须的</h5>

<h5>接口不匹配</h5>

<h5>代码重复</h5>

<h5>分布式系统的复杂性</h5>

<p>总而言之，微服务架构有很多吸引人的地方，不过在拥抱微服务之前，你需要认清它所带来的挑战。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[解析微服务架构(三)]]></title>
    <link href="http://wldandan.github.com/blog/2015/03/16/wei-fu-wu-jia-gou-she-ji-yu-shi-xian-3-wei-fu-wu-jia-gou-de-he-xin-te-zhen/"/>
    <updated>2015-03-16T22:07:00+08:00</updated>
    <id>http://wldandan.github.com/blog/2015/03/16/wei-fu-wu-jia-gou-she-ji-yu-shi-xian-3-wei-fu-wu-jia-gou-de-he-xin-te-zhen</id>
    <content type="html"><![CDATA[<p>[请勿转载]</p>

<h1>微服务架构的核心特征</h1>

<p>   什么是核心特征，就是当我们谈论同一件事情的时候，那些不同的人们所关注的相同的部分。从业界的讨论来看，微服务通
常有如下几个显著特征:</p>

<ul>
<li><h5>服务与组件</h5></li>
</ul>


<p>  一直以来，我们都比较提倡使用组件（Component）的方式，模块化应用系统。它类似生活中的汽车，由不同的零件组成，每个零件都是可以独立替换的。因此，这类通常都有很好的灵活性和替换性。</p>

<p>  在软件领域，我们也将组件定义为应用软件构建中独立的单元，它的最大特点是，对整个应用软件而言，组件能够被容易的替代或者更新。</p>

<p>   传统实现组件的方式是采用和应用程序一样的的编程语言，构建独立的共享库（Libaray），从而达到解耦和复用的效果。对于共享库而言，我们知道它是语言相关、平台相关，并且是和应用程序运行在同一个进程中的，因此，任何共享库的变化都意味着整个应用程序也要被更新，并且需要被重新部署。换句话说，如果应用由多个共享库组件组成，那么任何库的变更都将导致整体应用的重新发布。</p>

<!-- More -->


<p>   其实，微服务也可以作为组件。把微服务当成应用程序中的组件，其中一个最主要的好处是微
服务可以独立部署。如果应用由多个共享库组成，那么其只能跑在一个进程中，那么任何库的变更都将导致整体应用的重新发布。</p>

<p><img src="http://wldandan.github.com/images/microservice-design-and-practice/chapter3/library-as-component-800-600.png" /></p>

<p>但是如果应用程序由多个服务构成，我们可以想像，大部分情况下，每个服务的变更仅需要重新部署相应的服务。当然，这也不是绝对的，比如某些对服务接口的变更就需要其相关服务也发生变化，但微服务架构的目的，是尽量避免这种服务间的耦合并完善服务的交互接口。换句话说，通过服务来实现组件，将应用拆散为一系列的服务，运行在不同的进程中时，任何一个服务的局部变化只需重新部署对应的服务本身。同时，将服务作为组件也可以帮助我们明确的定义出组件的边界，因为服务之间的调用是跨进程的，清晰的边界和职责定义应该是在设计阶段时必须考虑的。</p>

<p><img src="http://wldandan.github.com/images/microservice-design-and-practice/chapter3/service-as-component-800-600.png" /></p>

<p>   把服务当成组件的另外一个优点是在组件和组件之间、或者组件和应用程序之间定义了清晰的、跨语言、跨平台的接口。许
多开发语言虽然定义了良好的公共调用接口的机制，也提供了详尽的文档和规范说明，但由于共享库其本身的特性，充分依赖于特定平台、特定语言，因此组件间的耦合度较高。同共享库相比，微服务是通过语言无关、平台无关的远程接口调用，因此不存在这个问题。当然，使用微服务也有它的不足之处，那就是远程调用比进制内部调用更消耗性能，而且远程的接口由于是分布式调用，无疑增加了维护的复杂度。</p>

<ul>
<li><h5>围绕业务组织团队</h5></li>
</ul>


<p>  在单块应用架构的时代，为了节省成本、快速实现目标，企业或者组织一般都会根
据技能类型的差异化来划分团队。例如用户体验设计师一般都被划分到用户体验设计团队，而懂服务器端的开发人员，一般都被归类为后端业务逻辑开发团队；对于那些精通数据库技能的开发者，一般会在DBA团队中找到他们的身影。实际上，当团队被按照这个策略或者维度划分后，即便是某些简单的需求变更，都有可能导致不同团队之间跨组织、跨团队的协作，耗费很高的跨团队的沟通和协作成本。</p>

<p>  正如<a href="http://en.wikipedia.org/wiki/Conway's_law">康威定律（Conway’s law)</a>提出的，一个组织的设计成果，其
结构往往对应于这个组织中的沟通和组织结构。另外，《敏捷宣言》的一个核心理念是“个体与交互高于过程和工具”。</p>

<p>如果仔细想想，我们发现康威定律从正反两方面支持了这一理念。有些公司受困于垂直、等级化的管理结构，这给工程师们带来了完成工作时不必要的阻力。更多的互联网公司则放手，让团队找到自组织的管理结构。我们既看到“漠视”康威定律所造成的危害，也看到了“拥抱”该定律所带来的好处。</p>

<p><img src="http://wldandan.github.com/images/microservice-design-and-practice/chapter3/build-team-aroud-business-800-600.png" /></p>

<p>   而微服务架构的开发模式不同于传统方式，它倡导围绕应用程序为核心，按业务能力来划分为不同的团队。每个团队都要求能
够对每个服务，将其对应的业务领域的全部功能实现，譬如对于某业务需求的更改，从用户体验界面到业务逻辑实现，再到数据的存储和迁移等。因此团队的组织是跨职能的，会包含实现该业务所需功能的所有技能。近年兴起的全栈工程师正是因为架构和开发模式的转变而出现，当然具备全栈的工程师其实很少，但将不同领域的工程师组织为一个全栈的团队就容易的多。</p>

<ul>
<li><h5>关注产品而不是项目</h5></li>
</ul>


<p>   传统的应用开发大部分都是基于项目模式的。什么是项目模式？就是当项目启动后，企业或者组织会从开发
团队中抽出一部分资源、从测试团队中抽出一部分资源，同时也从其他不同的技能团队中抽出不同的资源，组成一个项目团队，然后设置一个时间期限，让大家完成项目。当项目结束后，所有的资源都会被释放，所有人在项目中的职责结束。</p>

<p><img src="http://wldandan.github.com/images/microservice-design-and-practice/chapter3/team-by-skills-800-600.png" /></p>

<p>   但服务架构倡导的是避免采用这种项目模式，更倾向于让开发团队负责整个产品的生命周期。大家熟知的亚
马逊CTO Werner Vogels，曾经说过一句经典的名言，“You build it, you run it”。即对于开发产品的团队而言，产品就是团队的，也是每个成员的。团队中的每个人都有责任、有义务确保产品的快速发展以及演进。</p>

<ul>
<li><h5>去中心化</h5></li>
</ul>


<p>   在第二章我们提到，传统的单块应用架构，倾向于采用统一的技术平台或方案来解决所有问题。其实，我们
知道，在现实生活中，并不是每个问题都是钉子，也不是每个解决方案都是一个锤子。
问题有其具体性，解决方案也应有其针对性。用最适合的技术方案去解决具体的问题，往往会事半功倍。传统的单块架构系统倾向采用统一的技术平台或方案来解决所有问题，而微服务的架构意味着，可以针对不同的业务特征选择不同的技术方案，有针对性的解决具体的业务问题。</p>

<p>   对于单块架构系统，初始的技术选型严重限制将来采用不同语言或框架的能力。如果想尝试新的编程语言
或者框架，没有完备的功能测试集，很难平滑的完成替换，而且系统规模越大，风险越高。</p>

<p>  而基于微服务架构，使我们更容易在系统上尝试新的技术或解决方案。譬如说，可以先挑选风险最小的服务作为尝试，快速得到
反馈后再决定是否试用于其他服务。这也意味着，即便对一项新技术的尝试失败，也可以抛弃这个方案，并不会对整个产品带来风险。</p>

<ul>
<li><h5>独立业务数据</h5></li>
</ul>


<p>  传统的单块应用架构，倾向于采用统一的数据存储平台来存储所有的数据。随着业务的快速发展，需求的不断变化，一方面，数
据变得越来越复杂，难以管理；另一方面，随着应用系统的业务逻辑不断更新和发展，数据库不仅承担着数据存储的作用，还承担着不同系统之间的集成作用。同时，传统的数据库大多是关系型数据库，存储的数据都是以结构化信息为主，但随着互联网的快速发展，数据的结构并不具有确定性，或者说结构发生变化的频率非常快，因此，对于如何有效维护业务数据，也成了一个难题，相应的维护成本越来越高。</p>

<p>  微服务架构，提倡具有业务属性的独立单元或者服务自身维护其相关的业务数据。这样的话，有几个非常明显的优势：首先具有
业务属性的服务单元能够有权利管理其相关的数据，同时能够随着业务的发展，不断更新业务数据。其次，每个业务单元只关心自己的业务数据，因此可以选择最合适的工具或者产品来存储以及管理数据。譬如可以根据具体业务场景，使用MySQL、PostgreSQL等关系型数据库，也可以使用文档类型的MongoDB、键值类型的Riak等NoSQL数据库。譬如，在一个复杂的电商系统中，产品数据的种类繁多，更新也比较频繁，如果使用类似MongoDB这种文档数据库，能灵活的根据需求动态调整结构。而像当用户访问系统时产生的会话信息，则可以使用Redis等键值系统进行存储；通常来说，报表数据的结构变化不大，而且要求数据的高一致性，因此可以使用熟悉的关系型数据库。</p>

<p><img src="http://wldandan.github.com/images/microservice-design-and-practice/chapter3/polyglot-persistence-800-600.png" /></p>

<ul>
<li><h5>基础设施自动化</h5></li>
</ul>


<p>随着云技术的大规模推广与使用，部署和运维的复杂度在大幅度降低。利用云，我们可以快速的创建系统需要的资源，降低应用的交付周期。同时，由于持续集成、持续交付等实践的深入人心，很多团队都开始在构建软件的过程中，使用持续交付提倡的基础设施自动化技术（更多关于持续交付的知识，请参考《持续交付-发布可靠软件的系统方法》一书）。</p>

<p>这也就意味着，如果微服务架构将应用程序本身分成多个小的服务，每个服务都是一个独立的部署单元。因此，微服务的实践，对持续交付和部署流
水线要求非常高。微服务的粒度越细，就意味着需要部署的业务单元就越多，业务单元越多，就需要更稳定的基础设置自动化机制，能够创建运行环境，安装依赖，部署应用等。</p>

<p><img src="http://wldandan.github.com/images/microservice-design-and-practice/chapter2/loose-decouple-microservice-800-600.png" /></p>

<ul>
<li><h5>演进式架构设计</h5></li>
</ul>


<p>  在过去十年中，敏捷方法论以及其实践已经被越来越多的组织尝试并认可。敏捷方法论正在帮助组织以拥抱变化的心
态，去不断尝试，不断获取反馈，从而以高效的方式构建正确的应用系统。实际上，敏捷并不是一种静止的状态，它是组织一直在拥抱变化，尝试改变、获取反馈的演进式发展的一个动态过程。</p>

<p>  类似的，架构设计也应该是随着业务的发展而不断发展，随着需求的变化而不断变化的。当我们试图构建一个单块应用架构系统
时，我们会面临非常艰难的技术选型。哪种方案才是合理的？那种方案才是最正确的？在传统的单块设计中，企业或者组织通常是希望构建一个大而全、无所不能的平台，但是在技术发展如此之快的今天，单一的技术平台已经无法适应市场的快速变化，组织应该随着业务的发展，随着企业的发展，不断尝试并改进架构设计，真正做到业务驱动架构，架构服务于业务。</p>

<hr />

<h3>总结</h3>

<p>微服务强调的是一种独立测试、独立部署、独立运行的软件架构模式，是一种更灵活、更开放、更松散的演进式架构。通过本章所介绍的微服务的核心特征，帮助我们更清晰、深刻的理解了微服务其概念背后所蕴含的思想。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[解析微服务架构(二)]]></title>
    <link href="http://wldandan.github.com/blog/2015/03/16/wei-fu-wu-jia-gou-she-ji-yu-shi-xian-2-shen-me-shi-wei-fu-wu-jia-gou/"/>
    <updated>2015-03-16T22:07:00+08:00</updated>
    <id>http://wldandan.github.com/blog/2015/03/16/wei-fu-wu-jia-gou-she-ji-yu-shi-xian-2-shen-me-shi-wei-fu-wu-jia-gou</id>
    <content type="html"><![CDATA[<p>[请勿转载]</p>

<h1>什么是微服务架构</h1>

<p>在上一章中，我们认识了什么是单块架构应用，并分析了随着互联网时代的快速发展，随着市场变化快，用户需求变化快以及用户访问量的增加，单块架构应用的维护成本、人员的培养成本、缺陷修复成本以及技术架构演进的成本和系统扩展成本等都在增加，因此单块架构曾经的优势已逐渐无法适应互联网时代的快速变化，面临着越来越多的挑战。</p>

<p>在本章中，我们来了解到底什么是微服务架构，以及为什么微服务架构能有效解决单块架构在互联网时代所面临的挑战。</p>

<h3>概述</h3>

<p>   微服务架构一词在过去几年里，得到了广泛的讨论和关注。微服务架构提倡通过对特定业务领域的分析与建模，将复杂的、
集中的、耦合度高的应用系统分解成小而专、耦合度低并且高度自治的一组服务。这些服务与服务之间相互协作、相互配合，从而为最终用户或其他系统提供相应的功能。微服务将每个独立的业务逻辑划分出来，运行在它们自己的进程中，然后通过分布式的网络互相通信与协作，从而为终端用户或其他调用者提供灵活的接口。</p>

<!-- More -->


<p>   与传统IT行业的&#8217;服务架构&#8217;概念不一样的是，微服务更强调的是一种独立测试、独立部署、独立运行的软件架构模式。微服
务中的每个服务，都可以作为一个独立的业务单元进行测试、部署，而且每个服务都能独立运行在不同的进程中。这些微服务满足细粒度的业务需求，并使用自动化部署工具进行发布。同时，这些微服务可以使用不同的开发语言，不同框架，以及不同的数据存储技术，因此相比与&#8217;服务架构&#8217;，它是一种高度自治的、非集中式管理的、细粒度的业务单元。</p>

<p>   实际上，微服务架构并不是一个全新的概念。早在二十几年前，面向服务架构（SOA）概念的提出，就已经阐述了类似的思
想，“对于复杂的企业IT系统，应按照不同的、可重用的粒度划分，将功能相关的一组提供者组织在一起为消费者提供服务”。
仔细分析SOA的概念，就会发现，其在服务的定义上和我们今天所谈到的微服务定义大致类似，那为什么在SOA的概念提出这么多年后，又诞生了这个貌似是新瓶装旧酒的微服务架构呢？其实，鉴于过去十几年互联网行业的高速发展，以及敏捷、持续集成、持续交付、DevOPS，云技术等的深入人心，服务架构的开发、测试、部署以及监控等，相比我们提到的传统的SOA，已经大相径庭。相比SOA，微服务要更具有独立性、灵活性、可实施性以及可扩展性。换句话说，微服务架构可以被认为是一种更接地气的面向服务架构，是一种更容易帮助企业或组织构建演进式架构的方法和实践。关于更多SOA与微服务的区别，请参考[X部分]。</p>

<h3>微服务架构的定义</h3>

<p>   其实，即便了解了上面的介绍，还是很难对微服务下一个准确的定义。就像NoSQL，我们谈论了好几年的NoSQL，知道NoSQ
L代表着什么样的含义，也可以根据不同的应用场景选择不同的NoSQL数据库，但是我们还是很难对它下一个准确的定义。类似的，关于什么是‘函数式编程’，也或多或少存在同样的窘境。我们可以轻松的选择不同的函数式编程语言，可以轻松的写出函数式编程风格的代码，但很难对什么是函数式编程下一个准确的定义。</p>

<p>   实际上，从业界的讨论来看, 微服务本身并没有一个严格的定义。不过，ThoughtWorks的首席科学家，马丁-
福勒先生对微服务的这段描述，似乎更加具体、贴切，通俗易懂：</p>

<blockquote><p>  The microservice architectural style is an approach to developing a single application as a
suite of small services, each running in its own process and communicating with lightweight
mechanisms, often an HTTP resource API. These services are built around business capabilities and independently deployable by fully automated deployment machinery. There is a bare minimum of centralized management of these services, which may be written in different programming languages and use different data storage technologies.</p></blockquote>

<p>  微服务架构是一种架构模式，它提倡将单一应用程序划分成一组小的服务，服务之间互相协调、互相配合，为用户提供最终价值
。每个服务运行在其独立的进程中，服务与服务间采用轻量级的通信机制互相沟通（通常是基于HTTP协议的RESTful API）。每个服务都围绕着具体业务进行构建，并且能够被独立的部署到生产环境、类生产环境等。另外，应当尽量避免统一的、集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具对其进行构建。</p>

<p>  如果我们仔细分析这段话，不难发现，对于微服务的定义，我们可以从以下几个方面考虑：</p>

<h4>小，且专注于做一件事情</h4>

<p>   微服务架构通过对特定业务领域的分析与建模，将复杂的应用分解成小而专一、耦合度低并且高度自治的一组服务。每个服务都
是很小的应用。那么，微服务中提到的‘微’或者‘小’，到底是多‘微’、多‘小’呢？</p>

<p><img src="http://wldandan.github.com/images/microservice-design-and-practice/chapter2/confuse-how-small-800-600.png" /></p>

<p>实际上，关于多小的服务才合适，是一个非常有趣的话题。有人觉得使用代码行数来作为‘微’的衡量标准比较合适，而有些人认为，既然是微服务，就应该简单。就应该在很短的时间内，譬如2周内，能够非常容易的重写该服务，这样才符合小和微的概念。</p>

<p>关于代码行数，我们知道，不同的语言有不同的特点。静态类型语言的主要优点在于其结构非常规范，存在编译期的语法检查、便于调试，类型安全性高，通常其继承关系简洁明了，IDE对其支持也更加友好；但缺点是为此需要写更多的类型相关代码。因此如果实现同样的功能，代码量相对稍多，这类语言的典型代表有Java、C#等；动态语言，其灵活性较高，运行时可以改变内存的结构，无类型检查，不需要写非常多的类型相关的代码；缺点自然就是不方便调试，命名不规范时会造成不易理解等，典型的代表如JavaScript、Ruby或者Python等。另外，还有一些数学类计算语言，能够使用非常简洁的公式实现其逻辑。</p>

<p>譬如说，对于经典的<a href="http://zh.wikipedia.org/wiki/%E5%BA%B7%E5%A8%81%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F">康威生命游戏</a>而言，游戏开始时，细胞随机的被指定为存活或者死亡状态（黑色表示存活，白色表示死亡），每个细胞都会不断的演进，并且在演进的过程中，每个细胞下一代的状态由该细胞当前周围8个细胞的状态所决定，</p>

<p>其具体的规则如下图所示：</p>

<ul>
<li><p>规则1，如果一个细胞周围有少于2个存活细胞，则该细胞无论存活或者死亡，下一代将死亡；</p></li>
<li><p>规则2，如果一个细胞周围有多于3个存活细胞，则该细胞无论存活或者死亡，下一代将死亡；</p></li>
<li><p>规则3，如果一个细胞周围有3个存活细胞，则该细胞下一代将存活；</p></li>
<li><p>规则4，如果一个细胞周围且仅有2个存活细胞，则该细胞下一代状态保持不变；</p></li>
</ul>


<p><img src="http://wldandan.github.com/images/microservice-design-and-practice/chapter2/conwey-problem-description-800-600.png" /></p>

<p>对于这个问题，各位如果感兴趣的话，可以尝试使用自己最擅长的语言来试试。</p>

<p>但这里，我想说的是，有一种语言叫APL（<a href="http://en.wikipedia.org/wiki/APL_(programming_language)">A Programing Language</a>），如果我们使用它来实现，需要如下一行代码就可以解决该问题。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>life←{↑1 ⍵∨.∧3 4=+/,¯1 0 1∘.⊖¯1 0 1∘.⌽⊂⍵}
</span></code></pre></td></tr></table></div></figure>


<p>因此，对于实现同样的功能，选择不同的语言，代码的行数会有千差万别。因此代码行数这种量化的数字显然无法成为衡量微服务是否够‘微’的决定因素。</p>

<p>另外，有些人认为，既然是微服务，就应该简单。譬如说，就应该在固定时间内（譬如2周），能够非常容易的重写，这样才符合微的概念。实际上，2周时间，对不同的个体而言 ，其服务重写的结果可能大相径庭。我们知道，对于重写这种情况，很大部分取决于个体的工作经验、擅长的语言、对业务背景的了解等等。譬如说，工作年限长的开发者通常情况下可能对其擅长的技术更熟练，而对业务熟悉程度较好的开发者，如果重写可能完成的更快。因此，多长时间能够重写该服务也不能作为衡量其是否小的重要因素。</p>

<p>因此，我个人认为，微服务的“微”并不是一个真正可衡量、看得见、摸得着的“微”。这个“微”所表达的，是一种设计思想和指导方针，是需要团队或者组织共同努力找到的一个平衡点。因此，微服务到底有多微，是个仁者见仁，智者见智的问题，最重要的是团队觉得合适就好。但注意，当考虑微服务的“微”时，至少应该遵循两个原则：业务独立性和团队自主性。首先，应该保证微服务是具有业务独立性的单元，在这个前提下，由团队来判断当前的服务大小是否合适，考虑到团队的沟通成本，一般不建议超过10个人，或者在超过10个人的团队中，可以再划分子团队。在这种情况下，当团队中大部分成员认为当前的服务是能够容易维护的、容易理解的，这就是我们认为适合团队的、有意义的“微”。</p>

<p>   专注于做一件事情。从我们接触编程的第一天起，老师就教授我们，写出来的代码要符合“高内聚、低耦合”的原则，作为曾经似懂非懂的学生而言，我们也一直在朝
着这个方向努力着；另外，在面向对象设计的领域中，有几条放之四海而皆准的重要原则，那就是“SOLID原则”。大家请注意，在SOLID原则中的的第一条，叫单一职责原则（SRP-Single responsibility principle），其实描述的也是类似的事情。具体点说，单一职责原则的核心思想是：一个类，应该只有一个职责，也只有一个引起它变化的原因。如果一个类承担的职责过多，就等于把多个不同的职责耦合在了一起。这种耦合会导致当其中的某一职责发生变化时，可能会导致原本运行正常的其他职责或者功能发生故障。另外职责过多，也会导致引起该类变化的原因增多，多个职责之间相互依赖，容易产生影响，从而极大的损伤其内聚性和耦合度。Unix/Linux便是这一原则的完美体现者：在Unix中，各个程序都独立负责一个单一的事，我们可以通过管道将它们容易的连接起来。而Windows，则是这一原则的典型的反面示例：Windows中几乎所有的程序代码都交织耦合在一起，并没有做到一个类，只关注一个职责并把它做好。因此，如果希望避免这种现象的发生，就要尽可能的遵守单一职责原则，增强应用程序或者代码的内聚性以及降低耦合性。</p>

<h4>运行在独立的进程中</h4>

<p>  在传统的单块架构应用中，我们通常将应用程序的代码分成逻辑上的三层、四层甚至更多层，但它并不是物理上的分层。这也
就意味着，经过开发团队对不同层的代码实现，经历过编译（如果非静态语言，可以跳过编译阶段）、打包、部署后，不考虑负载均衡以及水平扩展的情况，应用程序会运行在同一个机器的同一个进程中。</p>

<p>另外，为了提高代码的重用率以及可维护性，在应用开发中，我们有时也会将重复的代码提取出来，封装成组件。注意，这里所说的组件，指的是可以独立升级、独立替换掉的这一部分。在传统的单块架构中，组件通常的形态叫共享库，譬如JVM平台下的jar包、或者Windows下的DLL等，它们都是组件的一种形态。当应用程序在运行期时，所有的组件最终也会被加载到同一个进程中运行。如下图所示：</p>

<p><img src="http://wldandan.github.com/images/microservice-design-and-practice/chapter2/run-in-one-process-800-600.png" /></p>

<p>但在微服务的架构里，应用程序有多个服务组成，每个服务都是一个具有高度自治性的独立业务实体，通常情况下，每个服务都能够运行在一个独立的操作系统进程中，这就意味着不同的服务能非常容易的被部署到不同的主机上。</p>

<p><img src="http://wldandan.github.com/images/microservice-design-and-practice/chapter2/run-in-multiple-process-800-600.png" /></p>

<p>理论上，虽然我们能够将多个服务部署到同一台节点上，并让它们运行在不同的进程中，这种方式是可行的，但并不推荐这么做。作为微服务运行的环境，我们希望它能够保持高度的自治性和隔离性。如果多个服务运行在同一个服务器节点上，虽然省去了节点的开销，但是增加了部署和伸缩的复杂度。譬如，当部署某个新的服务时，如果当前节点正在运行的多个进程的多个服务，则必然会对这些服务造成影响。另一方面，如果运行在某个阶段的多个服务中，某些服务随着业务的发展需要伸缩，某些服务却不需要，如何有效的组织这些服务？会给服务的水平伸缩带来不必要的麻烦。</p>

<h4>轻量级的通信机制</h4>

<p>  服务和服务之间通过轻量级的通信机制，实现彼此间的互通互联，互相协作。所谓轻量级通信机制，通常指基于语言无关、平
台无关、代码无关的这类协议，例如我们熟悉的XML或者JSON，他们的解析和使用与语言无关、平台无关。另外，基于HTTP协议，能让服务间的通信变得无状态化，目前大家所熟悉的REST(Representational State Transfer)就是服务之间互相协作常用的轻量级通信机制之一。
  对于传统我们所熟知的Java RMI或者.Net Remoting等，虽然这类协议能够使用RPC的方式简化客户端的调用，使其像调用
本地接口一样调用远端的接口，但其最大的劣势在于，这类协议和语言、平台有非常强的耦合性，灵活性和扩展性较差。譬如说，如果使用了RMI作为通信协议，就意味着我们必须采用运行在JVM之上的语言才能完成互相协作。</p>

<p>  对于微服务而言，通过使用语言无关、平台无关的轻量级通信机制，使服务与服务之间的协作变得更加简单、标准化。同时，服
务内部则可以选择任何语言、工具或者平台。</p>

<h4>松耦合，独立部署</h4>

<p>  在传统的单块架构应用里，由于所有的功能都存在同一个代码库里。因此，当修改了该代码库的某个功能，在后续的测试过程中
都需要做回归测试，才能保证当前功能的修改不会影响其他已经工作的功能。也就是说，功能和功能之间存在着强耦合关系。</p>

<p>  当测试完成后，通过持续集成或者其他机制，会构建新版本的部署包。这个大而全的部署包里，自然包括了应用的所有功能。当
将该部署包部署到生产环境或者类生产环境时，由于所有功能都运行在同一个进程中。因此，必须要停掉当前正在运行的进程，完成部署，然后再启动进程，相信这个部署的过程对大家都不陌生。</p>

<p><img src="http://wldandan.github.com/images/microservice-design-and-practice/chapter2/loose-decouple-tradition-800-600.png" /></p>

<p>  但是，如果当前应用程序里包含类似定时任务的功能，则要考虑什么时间窗口适合部署，是否需要先停掉原有的数据访问源，以
防止数据被读入应用程序内存，但未处理完而导致的数据不一致性。多年前，我曾经接触过一个JAVA项目，应用程序本身是个含有定时任务的系统，每隔5秒都会从数据库读入数据，然后将其转换成JMS的消息传给不同的内部组件。每次部署时候，我们都需要先关掉相关的消息队列，以防止数据被读入到应用，但还未被处理完，进程就被关闭而导致的数据不一致性。</p>

<p>  微服务架构中，每个服务都是一个独立的业务单元，服务和服务之间是松耦合的。当对某个服务进行改变时，对其他的服务并不
会产生影响。</p>

<p>  对于每个服务，最好能使用独立的代码库。这样的话，当我们对前服务的代码进行修改后，并不会影响其他服务。也就是说，从
代码库的层面，服务与服务是松耦合、高度解耦的。类似的，对于每个服务，都有独立的测试机制，因此，对当前服务代码的修改，也并不需要担心代码改动而导致的大范围的回归测试。因此，从测试的角度而言，服务和服务之间也是松耦合、高度解耦的。另外，由于构建包是独立的，部署流程也是独立的，服务的运行也是在不同的进程中。因此，从部署和运行的角度考虑，服务和服务之间同样是松耦合、高度解耦的。</p>

<p><img src="http://wldandan.github.com/images/microservice-design-and-practice/chapter2/loose-decouple-microservice-800-600.png" /></p>

<p> 因此，对于每个服务而言，与其他服务高度解耦，同时不需要改变其依赖，只改变当前服务本身，就可以完成部署。</p>

<hr />

<h3>总结</h3>

<p>综上所述，微服务架构将一个复杂应用拆分成多个服务，服务与服务间能够互相协作、相互配合，从而为终端用户提供业务价值。每个服务独立运行在不同的进程中，服务与服务之间通过轻量的通讯机制交互，并且每个服务可以通过自动化部署方式独立部署。</p>

<p>微服务强调的是一种独立测试、独立部署、独立运行的软件架构模式。微服务中的每个服务，都可以作为一个独立的业务单元进行测试、部署，而且每个服务都能独立运行在不同的进程中。这些微服务满足细粒度的业务需求，并使用自动化部署工具进行发布。同时，这些微服务可以使用不同的开发语言，不同框架，以及不同的数据存储技术，因此它是一种高度自治的、非集中式管理的、细粒度的服务单元。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[解析微服务架构(一)]]></title>
    <link href="http://wldandan.github.com/blog/2015/03/16/wei-fu-wu-jia-gou-she-ji-yu-shi-xian-1-dan-kuai-ying-yong-jia-gou/"/>
    <updated>2015-03-16T22:07:00+08:00</updated>
    <id>http://wldandan.github.com/blog/2015/03/16/wei-fu-wu-jia-gou-she-ji-yu-shi-xian-1-dan-kuai-ying-yong-jia-gou</id>
    <content type="html"><![CDATA[<p>[请勿转载]</p>

<h1>单块架构系统以及其面临的挑战</h1>

<h3>概述</h3>

<p>多年来，我们一直在技术的浪潮中乘风破浪，扬帆奋进，寻找更优秀的方法来构建IT系统，也一直在积极的学习并观察先进的公司如何以不同的架构方式构建或者优化其IT系统，来积极应对市场的变化，迅速做出响应，从而为客户提供更多的价值。</p>

<p>微服务架构模式（Microservice Architect Pattern）是近两年在软件架构模式领域里出现的一个新名词。虽然其诞生的时间不长，但其在各种演讲、文章、书籍上所出现的频率已经让很多人意识到它对软件领域所带来的影响。那到底什么是微服务，当我们谈论微服务时，它代表着一种什么样的含义？微服务适合应用在什么场景下，以及它有什么样的优缺点？微服务和SOA到底有没有区别？在接下来的几部分里，我将为大家揭开微服务的神秘面纱。</p>

<!-- More -->


<p>不过，在我们开始探讨微服务架构之前，让我们先回顾一下三层应用架构的发展历程并认识一下什么是单块架构应用。</p>

<h3>三层应用架构的发展</h3>

<p>对于任何一个软件应用系统而言，其构建目标都是为了满足某类用户的需求，即为用户传递价值。一直以来，软件的架构设计是决定应用系统是否能够被正确、有效实现的关键要素之一。架构设计描述了在应用系统的内部，如何根据业务、技术、组织，以及灵活性、可扩展性、可维护性等多种因素，将应用系统划分成不同的部分，并使这些部分彼此之间相互分工、相互协作，从而为用户提供某种特定价值的方式。</p>

<h4>应用的三层架构</h4>

<p>   现实生活中，“层”这个字的含义，对大家一点都不陌生。我们经常说楼房高多少层，蛋糕有几层等。通常来说，层有好几种定义，但其中最耳
熟能详的，莫过于“层”能帮助我们划分出构成某整体事物的，上下相互支撑的的不同部分。譬如说，我们喜欢吃的蛋糕，一般是由三层组成：第一层的蛋糕体、第二层的奶油，和第三层的水果。从顶部至底部，每一层依赖于下一层，从底部到顶部，每一层又支撑着上一层。</p>

<p>   在软件架构模式的领域，经过多年的发展，也有了层的概念：</p>

<ul>
<li> 层能够被单独构造；</li>
<li> 层具有区别于其他层的显著特点；</li>
<li> 层与层之间能够互相连接、互相支撑、互相作用，相互协作构成一个整体。</li>
<li> 层的内部，可以被替换成其他可工作的部分，但对整体的影响不大。</li>
</ul>


<p>   以WEB应用程序为例，在WEB应用程序开发的早期，由于受到面向过程的思维及设计方式的影响，所有的逻辑代码并没有明显的区分，因此代码
之间的调用相互交错，错综复杂。譬如，我们早期使用的ASP、JSP以及PHP，都是将所有的页面逻辑、业务逻辑以及数据库访问逻辑放在一起，这是我们通常提到的一层架构。</p>

<p><img src="http://wldandan.github.com/images/microservice-design-and-practice/chapter1/1-layer-800-600.png" /></p>

<p>   随着JAVA，.NET等高级语言的快速发展，这些语言为开发者提供了越来越方便的的数据访问机制，如Java语言的JDBC、IO流，或者.NET的ADO.NET等。这时候，数据访问部分的代码逐渐有了清晰的结构，但表示逻辑和业务逻辑依然交织在一起，我们称这个阶段为二层架构阶段。</p>

<p><img src="http://wldandan.github.com/images/microservice-design-and-practice/chapter1/2-layer-800-600.png" /></p>

<p>   随着面向对象分析、面向对象设计、面向对象原则、设计模式、企业架构模式等理念以及方法论的不断发展，从为用户提供功能、以及有效组织软件结构的角度考虑，WEB
应用中不同职责的部分逐渐被定义在了不同的层次，每一层负责的部分更趋向于具体化，细致化，于是软件的三层架构逐渐出现了。三层架构通常包括表示层、业务逻辑层以及数据访问层。</p>

<p><img src="http://wldandan.github.com/images/microservice-design-and-practice/chapter1/3-layer-800-600.png" /></p>

<ul>
<li> 表示层</li>
</ul>


<p>   表示层部分通常指当用户使用应用程序时，看见的、听见的、输入的或者交互的部分。譬如，有可能是信息的显示，音乐的的播放或者可以输
入的文本框，单选按钮以及可点击的按钮等。通过这些元素，用户同软件进行交互并获取期望的价值。目前的用户接口大部分情况下为WEB方式，当然也可以是桌面软件的形式，例如. NET的WINFORM或者Java的SWING。</p>

<ul>
<li> 业务逻辑层</li>
</ul>


<p>   业务逻辑部分是根据用户输入的信息，进行逻辑计算或者业务处理的部分。业务逻辑层则主要聚焦应用程序对业务问题的逻辑处理，以及业务
流程的操作，它是大部分软件系统区别与其他系统的核心。譬如，当用户点击一个按钮后，它可能会触发业务逻辑部分的代码进行运算，生成用户期望的结果。举例来说，在一个电子商务平台中，作为用户，当我们下单购买某个商品后，应用程序的业务逻辑层会对订单如何进行处理，如何计算折扣、如何配送等进行处理。</p>

<ul>
<li> 数据访问层</li>
</ul>


<p>  在用户同应用程序交互的过程中，会产生数据。这类数据需要通过某种机制被有效的保存，并在将来能够被重复使用，或者提供给其他系统。这
种机制或者方法就是数据访问层最关注的部分。也就是说，它关注的是应用程序是如何有效的将数据存储到数据库、文件系统或者其他存储介质中。有一点要注意的是，它关心的是对原始数据的操作（数据库或者文本文件等存放数据的形式），而非原始数据的存储介质本身。譬如，在一个电子商务平台中，商品的信息是如何存储，图片的信息是如何获取的等。</p>

<p>   三层架构的出现，一方面是为了解决应用程序中代码间调用复杂、代码职责不清的问题。其通过在各层间定义接口，并将接
口与实现分离，可以很容易的用不同的实现来替换原有层次的实现，从而有效降低层与层之间的依赖。这种方式不仅有利于帮助团队理解整个应用架构，降低后期维护成本，同时也有利于制定整个应用程序架构的标准。</p>

<p>   另一方面，三层结构的出现从某种程度上也解决了企业内部如何有效的根据技能调配人员，提高生产效率的问题。在大环境
下，有效的分层能使不同职责的人员各司其职，更聚焦与个人专业技能的发展和培养。三层结构的出现不仅标准化了复杂系统的逻辑划分，更帮助企业解决了如何有效形成技术人员组织结构的问题，因此在很长的一段时间里，它一直是软件架构的经典模式之一。</p>

<h4>非三层架构</h4>

<p>有些人认为，对于一个WEB应用程序，其被自动地分成了三层架构，因为它有三个分离的部件，如图所示：</p>

<p><img src="http://wldandan.github.com/images/microservice-design-and-practice/chapter1/not-3-layer-800-600.png" /></p>

<p>   这三个部分看起来虽然满足“层”的概念，但它并不是我们所说的软件架构的层。就像我们所说的奶油蛋糕，我们可以在蛋糕
的底部加上稳固的底座，在蛋糕的外部加上漂亮的包装盒，但仔细想想，底座可以用不同品牌的底座，可以用纸质材料的，也可以用树脂材料的；包装盒可以用红色的一次性纸袋，也可以用蓝色的带着花纹的铁盒，它们并不是我们蛋糕组成的必须一部分。</p>

<p>   浏览器可以独立存在与WEB应用程序之外，WEB应用程序也可以被不同的浏览器访问，因此浏览器不是WEB应用程序的部分
。虽然最近几年，在浏览器端，我们可以使用很多JavaScript库或者框架独立开发前端应用，但它的范畴超出了我们目前讨论的三层架构，更多的属于富客户端以及前后端分离的应用。</p>

<p>   类似的，数据库服务器也可以独立存在于应用程序之外，因此它也不是应用程序的一部分。虽然有些应用程序的逻辑代码，
被设计成必须是在数据库中运行，例如存储过程或者触发器，但这种用法并不推荐，原因是将业务逻辑放在了数据库本身，大大增加了后期维护的复杂度和数据迁移的成本。</p>

<h3>单块架构应用</h3>

<h4>什么是单块架构应用</h4>

<p>   虽然软件的三层架构帮助我们将应用在逻辑上分成了三层，但它并不是物理上的分层。这也就意味着，即便我们将应用架构分成了 所谓的三层
，经过开发团队对不同层的代码实现，经历过编译（如果非静态语言，可以跳过编译阶段）、打包、部署后，不考虑负载均衡以及水平扩展的情况，最终还是运行在同一个机器的同一个进程中。
对于这种功能集中、代码和数据中心化、一个发布包、部署后运行在同一进程的应用程序，我们通常称之为单块架构应用。典型的单块架构应用，莫过于传统的J2EE项目所构建的产品或者项目，它们存在的形态一般是WAR包或者EAR包。当部署这类应用时，通常是将整个一块都作为一个整体，部署在同一个WEB容器，如Tomcat或者Jetty中。当这类应用运行起来后，所有的功能也都运行在同一个进程中。</p>

<p>   类似的，基于Ruby On Rails的单块架构应用，一般逻辑上分为控制器层、模型层以及视图层，同时代码存放在遵循一定层级结构 的目录中
。当部署这类应用的时候，通常是使用SSH或者其他一些工具，如<a href="https://github.com/capistrano/capistrano">Capistrano</a>将整个目录部署在<a href="https://www.phusionpassenger.com/">Passenger</a>或者其他WEB容器中。当这类应用运行起来后，所有的功能也都运行在同一个进程中。</p>

<p><img src="http://wldandan.github.com/images/microservice-design-and-practice/chapter1/in-a-web-container-800-600.png" /></p>

<p>因此，对于单块架构应用的定义，其实是基于分层软件架构设计的系统基础之上，从部署模式、运行模式角度去考虑的一种定义方式。</p>

<h4>单块架构应用的优势</h4>

<ul>
<li> 易于开发</li>
</ul>


<p>   对单块架构的应用程序而言，开发方式相对较简单。首先从概念上，现有的大部分工具、应用服务器、框架都是这类单块架构应用程序，容易
理解而且为人所熟知。如果从实践角度出发，现有的集成开发工具比较适合单块架构的应用程序，像NetBeans、Eclipse、IDEA等，它们都能够有效加载并配置整个应用程序的依赖，方便开发人员开发、运行、调试等。</p>

<ul>
<li> 易于测试</li>
</ul>


<p>   单块架构应用程序也非常容易被测试，因为所有的功能都运行在一个进程中，启动集成开发环境或者将发布包部署到某一环境，一旦启动该进程，就可以立即开始系统测试或者功能测试。</p>

<ul>
<li> 易于部署</li>
</ul>


<p>   对单块架构的应用程序而言，部署也比较容易。实际上，由于所有的功能最终都会打成一个包，因此只需复制该软件包到服务器相应的位置即
可。当然，部署的方式可以有很多种，最简单的可以使用SCP远程拷贝到指定的目录下，当然也可以使用某些自动化的工具来完成。</p>

<ul>
<li> 易于水平伸缩</li>
</ul>


<p>   对单块架构的应用程序而言，水平伸缩也比较容易。实际上，由于所有的功能最终都会打成一个包，且只能运行在一个进程中，因此单块架构
的水平伸缩，更确切的理解其实是克隆，即新建一个服务器节点，配置好该节点的运行环境，复制软件包到相应的位置，运行改应用程序。当然，必须要确保负载均衡器能采取某种分发策略，有效的将请求分发到新创建的节点。</p>

<h4>单块架构面临的挑战</h4>

<p>   随着最近几年互联网行业的迅猛发展，随着公司或者组织业务的不断扩张，需求不断的增加以及用户量的不断增加，单块架构的优势已逐渐无法
适应互联网时代的快速变化，面临着越来越多的挑战。譬如说，一方面，随着业务的扩大，如何为用户提供可靠的服务，如何有效处理用户增多后导致并发请求数增多，导致的响应慢的问题，以及如何有效解决用户增多后带来的大数据量的问题等。另外一方面，随着公司或者组织业务的不断扩张，需求不断的增加，越来越多的人加入开发团队，代码库也在急剧膨胀。在这种情况下，单块架构的可维护性、灵活性在降低，而测试成本、构建成本以及维护成本却在显著增加。</p>

<p><img src="http://wldandan.github.com/images/microservice-design-and-practice/chapter1/advantages-vs-disadvantages-800-600.png" /></p>

<h5>1.维护成本增加</h5>

<p>   随着应用程序的功能越来越多，团队越来越大，相应的沟通成本、管理成本、人员协调成本必然会显著增加。譬如说，对于使
用Java编写的中型应用而言，当代码量为几万行时，可能只需要几人左右的团队维护。当代码量上升到几十万行级别时，可能需要几十人甚至是上百人的团队。</p>

<p>   另外，随着应用程序功能的增多，当出现缺陷时，有可能引起缺陷的原因组合就会比较多，这也会导致分析缺陷、定位缺陷、修复缺陷的成本相应增高，也就意味着缺陷的平均修复周期可能会花费更长时间。</p>

<p>   另外，随着代码量的增大，在开发人员对全局功能缺乏深度理解的情况下，修复一个缺陷，还有可能引入其他的缺陷，在自动
化测试机制不完善的情况下，很可能导致该过程陷入“修复越多，缺陷越多”的恶性循环。</p>

<p><img src="http://wldandan.github.com/images/microservice-design-and-practice/chapter1/complexity-increase-as-feauture-growing-800-600.png" /></p>

<h5>2.持续交付周期长</h5>

<p>   随着应用程序的功能越来越多，代码越来越复杂，构建和部署时间也会相应的增长。在现有部署流水线稳定工作的情况下，对
单块架构应用程序做任何细微的修改以及代码提交，都会触发部署流水线，对整个应用程序进行代码编译、运行单元测试、代码检查、构建并生成部署包、验证功能等，这也就意味着流水线的反馈周期变长，单位时间内构建的效率变低了。</p>

<p>   另一方面，团队人员的增多，部署流水线运行的时间增加，开发人员能够提交代码的时间窗口就相应减少，（因为流水线运行
的过程中，是禁止提交代码的），可能出现长时间等待代码提交，却无法提交的情况，极大破坏了团队的灵活性并降低了团队工作效率。几年前，我曾经工作在一个50万代码行的单块架构应用上，整个应用由一个50人左右的分布式团队负责。通常情况下，从开发人员提交代码到运行单元测试、构建发布包、运行功能测试、标记为可发布状态大概需要40分钟，时间稍微有点长，但团还能忍受。关键的问题是开发人员通常都是集中在下午3点左右，完成一定功能的情况下提交代码，结果就导致3点至5点那个时间段，成了代码提交的瓶颈，极大影响了该应用的持续集成和构建的效率。</p>

<h5>3.新人培养周期长</h5>

<p>   随着应用程序的功能越来越多，代码变得越来越复杂的同时，对于新加入团队的成员而言，了解行业背景、熟悉应用程序业
务、配置本地开发环境，这些看似简单的任务，将会花费更长的时间。我曾经有个朋友，在加入一家世界500强的知名IT公司后，被安排到了一个百万级代码的产品组里。他花了将近1个月的时间来熟悉产品文档、配置开发环境后，才在本地成功的运行起了这个应用。在他从事这份新工作的头一个月里，我们好几次聊到他的新工作，得到的答案都是一样，“看文档，装环境”。对个人而言，花一个月时间来配置本地开发环境，其中的滋味和感受大家可想而知，我估计人世间比这更痛苦的事情也没几件了。而对公司或者部门而言，本期望员工花费数天就能配置好的环境，却花了一个月才能完成，这更是极大的浪费。更有甚者，在第一次配置完开发环境后，好几年都不愿意再升级或者重装系统，真是一招被蛇咬，十年怕井绳。</p>

<p><img src="http://wldandan.github.com/images/microservice-design-and-practice/chapter1/new-employee-chanlleges-800-600.png" /></p>

<h5>4.技术选型成本高</h5>

<p>   传统的单块架构系统倾向采用统一的技术平台或方案来解决所有问题。通常，技术栈的决策是在团队开发之前经过架构师、技术经理慎重评估后选定的，每个团队成员都必须使用相同的开发语言、持久化存储及消息系统，而且要使用类似的工具。随着应用程序的复杂性逐渐增加以及功能越来越多，如果团队希望尝试引入新的框架、技术，或者对现有技术栈升级，通常会面临不小的风险。</p>

<p>   另一方面，互联网行业不仅市场变化快，而且技术变化也快。譬如，短短几年几年时间，光前端JavaScript的框架，就出现了好几十个，从早一点的<a href="http://backbonejs.org/">Backbone</a>、<a href="http://emberjs.com">Ember</a>到<a href="https://angularjs.org">AngularJS</a>、<a href="http://www.ractivejs.org/">Ractive</a>等等。类似的，后端的框架、工具等也是层出不穷，有兴趣的朋友可以参考下<a href="http://www.thoughtworks.com/radar">ThoughtWorks的技术雷达</a>(该技术雷达是ThoughtWorks对业界技术、工具、语言等发展趋势的分析以及预测报告)。因此，对单块架构的应用而言，初始的技术选型严重限制了其将来采用不同语言或框架的能力。如果想尝试新的编程语言或者框架，没有完备的功能测试集，很难平滑的完成替换，而且系统规模越大，风险越高。</p>

<h5>5.可伸缩性差</h5>

<p>  如果应用程序的所有功能代码都运行在同一个服务器上，将会导致应用程序的扩展非常困难。如果迫切的需要扩展，那么垂直扩展可能是最容
易的（钱不是问题）。在大多数情况下，如果舍得砸钱上IBM的服务器、Oracle的数据库或者来自EMC的存储设备，不用改变一行代码，整个世界都变好了。不幸的是，伴随着业务的增长，数据的增长，垂直扩展会变得越来越吃力，成本越来越高。这也是为什么在业很多公司开始尝试使用开源，放弃这些昂贵的IOE产品的原因。这下明白为什么近几年去IOE的呼声越来越高了吧。</p>

<p>  当考虑水平扩展时，通常的做法是建立一个集群，通过在集群中不断的添加新节点，然后借助前端的负载均衡器，将用户的
请求按照某种算法，譬如轮转法、散列法或者最小连接法等合理的将请求分配到不同的节点上。但是，由于所有程序代码都运行在服务器上的同一个进程中，会导致应用程序的水平扩展成本非常高。譬如说，如果应用程序某部分的功能是内存密集型的，如需要缓存大量数据，而另外一部分功能是CPU密集型的，如需要进行大量的运算，那么每次实施水平扩展，运行该应用的服务器都必须有足够的内存和强劲的CPU来满足需求。因此，鉴于每个服务器都要提供该应用系统所需要的各种资源，基础设施的整体花费可能会非常高。当然，如果某些节点保持状态，如用户登陆后的会话信息等，更增加了水平扩展的难度。</p>

<h5>6.构建全功能团队难</h5>

<p>   最后，非常微妙的是，随着应用程序的功能越来越多，代码变得越来越复杂，其应用程序的复杂结构也会逐渐映射到研发团队的
结构上。康威定律指出：一个组织的设计成果，其结构往往对应于这个组织中的沟通结构。单块架构的开发模式在分工时往往以技能为单位，比如UX团队、服务端团队和数据库团队，这样的分工可能会导致任何功能上的改变都需要跨团队沟通和协调。譬如说，用户体验工程师（UX）更专注负责用户接口部分，业务层开发者则负责建立服务器后端的业务逻辑，数据库工程师和DBA们更关注数据访问组件和数据库。鉴于这些问题，随着时间的推移，不仅代码越来越难以管理，其对团队结构的影响也越来越明显。</p>

<p><img src="http://wldandan.github.com/images/microservice-design-and-practice/chapter1/build-team-aroud-business-800-600.png" /></p>

<p>综上所述，随着业务的不断扩大，需求功能的持续增加，单块架构已经很难满足业务快速变化的需要。一方面，代码的可维护性、扩展性、灵活性在降低；而另一方面，系统的测试成本、构建成本以及维护成本却在显著增加。因此，随着项目或者产品规模的不断扩大，单块架构应用的改造与重构势在必行。</p>

<hr />

<h3>总结</h3>

<p>   互联网时代的产品通常有几类特点：创新成本低、需求变化快，用户群体庞大，它和几年前我们熟悉的单块
架构应用有着本质的不同。随着市场变化快、用户需求变化快、用户访问量增加的同时，单块架构应用的维护成本、人员的培养成本、缺陷修复成本、技术架构演进的成本、系统扩展成本等都在增加，因此单块架构曾经的优势已逐渐无法适应互联网时代的快速变化，面临着越来越多的挑战。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[基于微服务架构，改造企业核心系统之实践]]></title>
    <link href="http://wldandan.github.com/blog/2014/09/16/shi-yong-wei-fu-wu-gai-zao-qi-ye-he-xin-ye-wu-xi-tong-shi-jian/"/>
    <updated>2014-09-16T21:57:00+08:00</updated>
    <id>http://wldandan.github.com/blog/2014/09/16/shi-yong-wei-fu-wu-gai-zao-qi-ye-he-xin-ye-wu-xi-tong-shi-jian</id>
    <content type="html"><![CDATA[<p>本文已经发表于InfoQ，请参考<a href="http://www.infoq.com/cn/articles/enterprise-core-systems-transformation-practice">这里</a></p>

<h2>背景与挑战</h2>

<p>随着公司国际化战略的推行以及本土业务的高速发展，后台支撑系统已经不堪重负。</p>

<p>在吞吐量、稳定性以及可扩展性上都无法满足日益增长的业务需求。对于每10万元额度的合同，从销售团队准备材料、与客户签单、递交给合同部门，再到合同生效大概需要3.5人天。随着业务量的快速增长，签订合同的成本急剧增加。</p>

<p>合同管理系统是后台支撑系统中重要的一部分。当前的合同系统是5年前使用.NET，基于<a href="http://www.sagecrm.com/">SAGE CRM</a>二次开发的产品。
一方面，系统架构过于陈旧，性能、可靠性无法满足现有的需求。另一方面，功能繁杂，结构混乱，定制的代码与SAGE CRM系统耦合度极高。</p>

<p>由于是遗留系统，熟悉该代码的人早已离职多时，新团队对其望而却步，只能做些周边的修补工作。同时，还要承担着边补测试，边整理逻辑的工作。</p>

<p>在无法中断业务处理的情况下，为了解决当前面临的问题，团队制定了如下的策略：</p>

<p><img src="http://wldandan.github.com/images/microservice/crm-rebuild-strategy-600x400.png" /></p>

<ol>
<li>在现有合同管理系统的外围，构建功能服务接口，将系统核心的功能分离出来。</li>
<li>利用这些功能服务接口作为代理，解耦原合同系统与其调用者之间的依赖；</li>
<li>通过不断构建功能服务接口，逐渐将原有系统分解成多个独立的服务。</li>
<li>摒弃原有的合同管理系统，使用全新构建的(微)服务接口替代。</li>
</ol>


<!--more-->


<h2>什么是微服务</h2>

<p>多年来，我们一直在技术的浪潮中不断乘风破浪，扬帆奋进，寻找更好的方式构建IT系统。</p>

<p>微服务架构(Micro Service Architect)，是近一段时间在软件体架构领域里出现的一个新名词。它通过将功能分解到多个独立的服务中以实现对解决方案或者复杂系统的解耦。</p>

<p>微服务的诞生并非偶然：<a href="http://dddcommunity.org/">领域驱动设计</a>指导我们如何分析并模型化复杂的业务；<a href="http://agilemethodology.org/">敏捷方法论</a>帮助我们消除浪费，快速反馈；<a href="http://agilemethodology.org/">持续交付</a>促使我们构建更快、更可靠、更频繁的软件部署和交付能力；虚拟化和基础设施自动化(Infrasture As Code)则帮助我们简化环境的创建、安装；<a href="http://dev2ops.org/2010/02/what-is-devops/">DevOps</a>文化的流行以及特性团队的出现，使得小团队更加全功能化。这些都是推动微服务诞生的重要因素。</p>

<p>实际上，微服务本身并没有一个严格的定义。不过从业界的讨论来看，微服务通常有如下几个特征:</p>

<h3>小，且专注于做一件事情</h3>

<p>每个服务都是个很小的应用，至于有多小，是一个非常有趣的话题。有人喜欢100行以内，有人赞成1000行以内。数字并不是最重要的，仁者见仁，智者见智，只要团队觉得合适就好。</p>

<p>只关注一个业务功能。这一点和我们平常谈论的面向对象原则中的&#8221;单一原则&#8221;类似，每个服务只做一件事情，并且把它做好。</p>

<h3>运行在独立的进程中</h3>

<p>每个服务都运行在一个独立的操作系统进程，这意味着不同的服务能被部署到不同的主机上。</p>

<h3>轻量级的通信机制</h3>

<p>服务和服务之间通过轻量级的机制实现彼此间的通信。所谓轻量级通信机制，通常指基于语言无关、平台无关的这类协议，例如XML、JSON，而不是传统我们熟知的Java RMI或者.Net Remoting等。</p>

<h3>松耦合</h3>

<p>不需要改变依赖，只更改当前服务本身，就可以独立部署。这意味着该服务和其他者服务之间在部署和运行上呈现相互独立的状态。</p>

<p>综上所述，微服务架构采用多个服务间互相协作的方式构建传统应用。每个服务独立运行在不同的进程中，服务之与服务之间通过轻量的通讯机制交互，并且每个服务可以通过自动化部署方式独立部署。</p>

<h2>微服务的优势</h2>

<p>相比传统的单块架构系统(monolithic)，微服务在如下诸多方面有着显著的优势：</p>

<h4>异构性</h4>

<p>问题有其具体性，解决方案也应有其针对性。用最适合的技术方案去解决具体的问题，往往会事半功倍。传统的单块架构系统倾向采用统一的技术平台或方案来解决所有问题。而微服务的异构性，可以针对不同的业务特征选择不同的技术方案，有针对性的解决具体的业务问题。</p>

<p>对于单块架构的系统，初始的技术选型严重限制将来采用不同语言或框架的能力。如果想尝试新的编程语言或者框架，没有完备的功能测试集，很难平滑的完成替换，而且系统规模越大，风险越高。基于微服务架构，使我们更容易地在遗留系统上尝试新的技术或解决方案。譬如说，
可以先挑选风险最小的服务作为尝试，快速得到反馈后再决定是否试用于其他服务。这也意味着，即便对一项新技术的尝试失败的话，尽可以抛弃这个方案，并不会对整个产品带来风险。</p>

<p><img src="http://wldandan.github.com/images/microservice/micro-service-advantages-600x400.png" /></p>

<p>上图引用自Martin Fowler的<a href="http://martinfowler.com/articles/microservices.html">Microservices</a>一文。</p>

<h4>独立测试与部署</h4>

<p>单块架构系统运行在一个进程中，因此系统中任何程序的改变，都需要对整个系统重新测试并部署。
而对微服务架构而言，不同服务之间的打包、测试或者部署等，与其它服务都是完全独立的。对某个服务所做的改动，只需要关注该服务本身。从这个角度来说，使用微服务后，代码修改、测试、打包以及部署的成本和风险都比单块架构系统降低很多。</p>

<h4>按需伸缩</h4>

<p>单块架构系统由于单进程的局限性，水平扩展时只能基于整个系统进行扩展，无法针对某一个功能模块按需扩展。
而服务架构则可以完美的解决伸缩性的扩展问题。系统可以根据需要，实施细粒度的自由扩展。</p>

<h4>错误隔离性</h4>

<p>微服务架构同时也能提升故障的隔离性。例如，如果某个服务的内存泄露，则只会影响到自己，其他服务能够继续正常地工作。与之形成对比的是，单块架构中如果有一个不合格的组件发生异常，有可能会拖垮整个系统。</p>

<h4>团队全功能化</h4>

<p>康威定律（Conway&#8217;s law）指出：</p>

<p><code>organizations which design systems are constrained to produce designs which are copies of the communication structures of these organizations.</code></p>

<p><code>一个组织的设计成果，其结构往往对应于这个组织中的沟通结构。</code></p>

<p>传统的开发模式在分工时往往以技术为单位，比如UI团队、服务端团队和数据库团队，这样的分工可能会导致任何功能上的改变都需要跨团队沟通和协调。而微服务则倡导围绕服务来分工，团队需要具备服务设计、开发、测试到部署所需的所有技能。</p>

<h2>微服务快速开发实践</h2>

<p>随着团队对业务的理解加深和对微服务实践的尝试，数个微服务程序已经成功构建出来。不过，问题同时也出现了：对于这些不同的微服务程序而言，虽然具体实现的代码细节不同，但其结构、开发方式、持续集成环境、测试策略、部署机制以及监控和告警等，都有着类似的实现方式。那么如何满足<a href="http://programmer.97things.oreilly.com/wiki/index.php/Don't_Repeat_Yourself">DRY原则</a>并消除浪费呢？</p>

<p>带着这个问题，经过团队的努力，Stencil诞生了。
Stencil是一个帮助快速构建Ruby微服务应用的开发框架，主要包括四部分：Stencil模板、代码生成工具，持续集成模板以及一键部署工具。</p>

<p><img src="http://wldandan.github.com/images/microservice/stencil-template-structure-details-600x400.png" /></p>

<h3>Stencil模板</h3>

<p>Stencil模板是一个独立的Ruby代码工程库，主要包括代码模板以及一组配置文件模板。</p>

<p>代码模板使用<a href="https://github.com/basho/webmachine">Webmachine</a>作为Web框架，<a href="http://en.wikipedia.org/wiki/Representational_state_transfer">RESTful</a>和JSON构建服务之间的通信方式，RSpec作为测试框架。同时，代码模板还定义了一组Rake任务，譬如运行测试，查看测试报告，将当前的微服务生成RPM包，使用Koji给RPM包打标签等。</p>

<p>除此之外，该模板也提供了一组通用的URL，帮助使用者查看微服务的当前版本、配置信息以及检测该微服务程序是否健康运行等。</p>

<pre><code>[
    {
        rel: "index",
        path: "/diagnostic/"
    },
    {
        rel: "version",
        path: "/diagnostic/version"
    },
    {
        rel: "config",
        path: "/diagnostic/config"
    },
    {
        rel: "hostname",
        path: "/diagnostic/hostname"
    },
    {
        rel: "heartbeat",
        path: "/diagnostic/status/heartbeat"
    },
    {
        rel: "nagios",
        path: "/diagnostic/status/nagios"
    }
]
</code></pre>

<p>配置文件模板主要包括<a href="http://newrelic.com/">NewRelic</a>配置，<a href="https://www.phusionpassenger.com/">Passenger</a>配置、<a href="http://www.nagios.org/">Nagios</a>配置、<a href="http://httpd.apache.org/">Apache</a>配置以及<a href="http://www.splunk.com/">Splunk</a>配置。通过定义这些配置文件模板，当把新的微服务程序部署到验收环境或者产品环境时，我们立刻就可以使用Nagios、NewRelic以及Splunk等第三方服务提供的功能，帮助我们有效的监控微服务，并在超过初始阈值时获得告警。</p>

<h3>代码生成工具</h3>

<p>借助Stencil代码生成工具，我们能在很短的时间内就构建出一个可以立即运行的微服务应用程序。随着系统越来越复杂，微服务程序的不断增多，Stencil模板和代码生成工具帮助我们大大简化了创建微服务的流程，让开发人员更关注如何实现业务逻辑并快速验证。</p>

<pre><code>Create a project from the stencil template (version 0.1.27)
        --name, -n &lt;s&gt;:   New project name. eg. things-and-stuff
   --git-owner, -g &lt;s&gt;:   Git owner (default: which team or owner)
        --database, -d:   Include database connection code
  --triggered-task, -t:   Include triggered task code
        --provider, -p:   Is it a service provider? (other services use this service)
        --consumer, -c:   Is it a service consumer? (it uses other services)
      --branch, -b &lt;s&gt;:   Specify a particular branch of Stencil
       --face-palm, -f:   Overide name validation 
            --help, -h:   Show this message
</code></pre>

<p>如上图所示，通过指定不同参数，我们能创建具有数据库访问能力的微服务程序、或者是包含异步队列处理的微服务程序。同时，我们也可以标记该服务是数据消费者还是数据生产者，能帮助我们理解多个微服务之间的联系。</p>

<h3>持续集成模板</h3>

<p>基于持续集成服务器<a href="https://www.atlassian.com/software/bamboo">Bamboo</a>，团队创建了针对Stencil的持续集成模板工程，并定义了三个主要阶段：</p>

<ul>
<li>打包：运行单元测试，集成测试，等待测试通过后生成RPM包。</li>
<li>发布：将RPM包发布到<a href="http://koji.fedoraproject.org/koji/">Koji</a>服务器上，并打上相应的Tag。然后使用<a href="http://www.packer.io/">Packer</a>在亚马逊AWS云环境中创建AMI，建好的AMI上已经安装了当前微服务程序的最新RPM包。</li>
<li>部署：基于指定版本的AMI，将应用快速部署到验收环境或者产品环境上。</li>
</ul>


<p>利用持续集成模板工程，团队仅需花费很少的时间，就可以针对新建的微应用程序，在Bamboo上快速定义其对应的持续集成环境。</p>

<h3>一键部署工具</h3>

<p>所有的微服务程序都部署并运行在亚马逊AWS云环境上。同时，我们使用<a href="https://github.com/Netflix/asgard">Asgard</a>对AWS云环境中的资源进行创建、部署和管理。
Asgard是一套功能强大的基于Web的AWS云部署和管理工具，由Netflix采用<a href="http://grails.org/">Groovy on Grails</a>开发，其主要优点有：</p>

<pre><code>- 基于B/S的AWS部署及管理工具，使用户能通过浏览器直接访问AWS云资源，无需设置Secret Key和Access Key；
- 定义了`Application`以及`Cluster`等逻辑概念，更清晰、有效地描述了应用程序在AWS云环境中对应的部署拓扑结构。
- 在对应用的部署操作中，集成了AWS Elastic Load Balancer、AWS EC2以及AWS Autoscaling Group，并将这些资源自动关联起来。
- 提供RESTful接口，能够方便的与其他系统集成。
- 简洁易用的用户接口，提供可视化的方式完成一键部署以及流量切换。
</code></pre>

<p>由于Asgard对RESTful的良好支持，团队实现了一套基于Asgard的命令行部署工具，只需如下一条命令，提供应用程序的名称以及版本号，就可自动完成资源的创建、部署、流量切换、删除旧的应用等操作。</p>

<pre><code>asgard-deploy [AppName] [AppVersion]
</code></pre>

<p>同时，基于命令行的部署工具，也可以很容易的将自动化部署集成到Bamboo持续集成环境。</p>

<p>通过使用微服务框架Stencil，大大缩短了团队开发微服务的周期。同时，基于Stencil，我们定义了一套团队内部的开发流程，帮助团队的每一位成员理解并快速构建微服务。</p>

<h2>微服务架构下的新系统</h2>

<p>经过5个月的努力，我们重新构建了合同管理系统，将之前的产品、价格、销售人员、合同签署、合同审查以及PDF生成都定义成了独立的服务接口。相比之前大而全、难以维护的合同管理系统而言，新的系统由不同功能的微服务组成，每个微服务程序只关注单一的功能。每个微服务应用都有相关的负责人，通过使用<a href="http://www.pagerduty.com/">Page Duty</a>建立消息通知机制。每当有监控出现告警的时候，责任人能立即收到消息并快速做出响应。</p>

<p><img src="http://wldandan.github.com/images/microservice/micro-service-app-600x400.png" /></p>

<p>由于微服务具有高内聚，低耦合的特点，每个应用都是一个独立的个体，当出现问题时，很容易定位问题并解决问题，大大缩短了修复缺陷的周期。
另外，通过使用不同功能的微服务接口提供数据，用户接口(UI)部分变成了一个非常简洁、轻量级的应用，更关注如何渲染页面以及表单提交等交互功能。</p>

<h3>总结</h3>

<p>通过使用微服务架构，在不影响现有业务运转的情况下，我们有效的将遗留的大系统逐渐分解成不同功能的微服务接口。</p>

<p>同时，通过Stencil微服务开发框架，我们能够快速的构建不同功能的微服务接口，并能方便的将其部署到验收环境或者产品环境。</p>

<p>最后，得益于微服务架构的灵活性以及扩展性，使得我们能够快速构建低耦合、易扩展、易伸缩性的应用系统。</p>

<h3>参考文献</h3>

<p>http://martinfowler.com/articles/microservices.html <br/>
http://jaxenter.com/cracking-microservices-practices-50692.html<br/>
http://microservices.io/patterns/microservices.html</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java 8 - First impression of Lambda Expression]]></title>
    <link href="http://wldandan.github.com/blog/2014/06/19/java-8-functional-programming-and-lambda-expressions/"/>
    <updated>2014-06-19T04:56:00+08:00</updated>
    <id>http://wldandan.github.com/blog/2014/06/19/java-8-functional-programming-and-lambda-expressions</id>
    <content type="html"><![CDATA[<p>One of the most prominent and widely used languages in the world has <strong>Evolved</strong>.</p>

<p>Java ever gave us power on object oriented progrmming and we did the best we could with it.</p>

<p>Now there’s another new elegant way changing the java world-Lambda Expression, that will make our code more expressive, easier to write, less error prone, and easier to parallelize than has been the case with Java.</p>

<h3>Lambda Expression</h3>

<p>Let&#8217;s start from a simple example:</p>

<p><code>Suppose we’re asked to total the prices greater than $20, discounted by 10%. Let’s do that in the habitual Java way first.</code></p>

<h4>Old way</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>final List&lt;BigDecimal&gt; prices = Arrays.asList(
</span><span class='line'>  new BigDecimal("10"), new BigDecimal("30"), new BigDecimal("17"), 
</span><span class='line'>  new BigDecimal("20"), new BigDecimal("15"), new BigDecimal("18"), 
</span><span class='line'>  new BigDecimal("45"), new BigDecimal("12"));
</span><span class='line'>
</span><span class='line'>  BigDecimal totalOfDiscountedPrices = BigDecimal.ZERO;   
</span><span class='line'>  for(BigDecimal price : prices) { 
</span><span class='line'>          if(price.compareTo(BigDecimal.valueOf(20)) &gt; 0)
</span><span class='line'>                  totalOfDiscountedPrices = totalOfDiscountedPrices.add(price.multiply(BigDecimal.valueOf(0.9)));
</span><span class='line'>              }
</span><span class='line'>      System.out.println("Total of discounted prices: " + totalOfDiscountedPrices);</span></code></pre></td></tr></table></div></figure>


<h4>A Better way</h4>

<p>Now we can do better, a lot better. Our code can resemble the requirement specification. This will help reduce the gap between the business needs and the code that implements it, further reducing the chances of the requirements being misinterpreted.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>final BigDecimal totalOfDiscountedPrices = 
</span><span class='line'>prices.stream()
</span><span class='line'>  .filter(price -&gt; price.compareTo(BigDecimal.valueOf(20)) &gt; 0)
</span><span class='line'>  .map(price -&gt; price.multiply(BigDecimal.valueOf(0.9)))
</span><span class='line'>  .reduce(BigDecimal.ZERO, BigDecimal::add);
</span><span class='line'>  
</span><span class='line'>System.out.println("Total of discounted prices: " + totalOfDiscountedPrices);</span></code></pre></td></tr></table></div></figure>


<p>Instead of explicitly iterating through the prices list, we’re using a few special methods:</p>

<ul>
<li>Using filter() to get the record we are interested</li>
<li>Using map() to transfer to another result set</li>
<li>Using reduce() to compute the total on the result</li>
</ul>


<h3>Summary</h3>

<p>It’s a whole new world in Java. We can now program in an elegant and fluent functional style, with higher-order functions. This can lead to concise code that has fewer errors and is easier to understand, maintain, and parallelize.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Asgard - Handy tool for AWS management & deployment]]></title>
    <link href="http://wldandan.github.com/blog/2014/05/27/asgard-awesome-tool-for-aws-deployment/"/>
    <updated>2014-05-27T20:55:00+08:00</updated>
    <id>http://wldandan.github.com/blog/2014/05/27/asgard-awesome-tool-for-aws-deployment</id>
    <content type="html"><![CDATA[<p>Asgard is named for the home of the Norse god of thunder and lightning.
As the words described, it is closely relevant to the management and control in cloud.</p>

<p>Netflix build a tool named Asgard, which is used to control and manage their AWS cloud.  In 2012, Netflix announced that Asgard was open-sourced.</p>

<p>Then&#8230;&#8230; it is time to start the story.</p>

<h2>What is Asgard</h2>

<p>Asgard is a web-based tool for managing cloud-based applications and infrastructure.</p>

<ul>
<li>Built on the top of <a href="https://grails.org/">grails</a>.</li>
<li>By introducing <code>Application</code> and <code>Cluster</code> terminology, enable users understand their cloud objets clearly.</li>
<li>Keep track cloud objects from the view of one application</li>
</ul>


<!-- More -->


<h2>Why needs Asgard</h2>

<p>The AWS Management Console has its uses for someone with your Amazon account password who needs to configure something Asgard does not provide. However, for everyday large-scale operations, the AWS Management Console has not yet met the needs of the Netflix cloud usage model, so we built Asgard instead. Here are some of the reasons.</p>

<ul>
<li><p>Hide the Amazon keys</p>

<p>Asgard provides an internal console allows us to grant users access to our Amazon accounts without telling too many employees the shared cloud passwords. This strategy also saves us from needing to assign and revoke hundreds of Identity and Access Management (IAM) cloud accounts for employees.</p></li>
<li><p>Auto Scaling Groups</p>

<p>  AWS Management Console lacks support for Auto Scaling Groups (ASGs). ASGs are good scaling features to provide reliability, redundancy, cost savings, clustering, discoverability, ease of deployment, and the ability to roll back a bad deployment quickly.</p></li>
<li><p>Logging</p>

<p>  AWS console does not expose a log of recent user actions on an account. This makes it difficult to determine whom to call when a problem starts, and what recent changes might relate to the problem. Lack of logging is also a non-starter for any sensitive subsystems that legally require auditability.</p></li>
<li><p>Simplify REST API</p>

<p>  For common operations that other systems need to perform, we can expose and publish our own REST API to do exactly what we want in a way that hides some of the complex steps from the user.</p></li>
<li><p>Naming Conventions</p>

<p>  Like any growing collection of things users are allowed to create, the cloud can easily become a confusing place full of expensive, unlabeled clutter. Asgard is using registered services associated with cloud objects by naming convention. Asgard enforces these naming conventions in order to keep the cloud a saner place that is possible to audit and clean up regularly as things get stale, messy, or forgotten.</p></li>
</ul>


<h2>What Asgard can do</h2>

<p><img src="http://2.bp.blogspot.com/-bn3mWGhb7Zo/T-S2bKpJZDI/AAAAAAAACnw/0xH5-M7oboc/s1600/cloud-model-diagram-625.png" /></p>

<p>Here’s a quick summary of the relationships of these cloud objects.</p>

<ul>
<li>An Auto Scaling Group (ASG) can attach zero or more Elastic Load Balancers (ELBs) to new instances.</li>
<li>An ELB is used to send user traffic to instances.</li>
<li>An ASG can launch and terminate instances.</li>
<li>For each instance launch, an ASG uses a Launch Configuration.</li>
<li>The Launch Configuration specifies which Amazon Machine Image (AMI) and which Security Groups to use when launching an instance.</li>
<li>Security Groups can restrict the traffic sources and ports to the instances.</li>
</ul>


<p>More functionality, please check the <a href="https://github.com/Netflix/asgard/wiki/Quick-Start-Guide">documentation</a></p>

<h2>Summary</h2>

<p>As the AWS is becoming more common for deployment, as the infrasutre of web site is becoming more complex, Asgard would be star to make our life easier to manage and deploy our product.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Splunk - Receive logs from distributed Windows machine]]></title>
    <link href="http://wldandan.github.com/blog/2014/05/21/collect-log-of-windows-machine-into-splunk/"/>
    <updated>2014-05-21T20:56:00+08:00</updated>
    <id>http://wldandan.github.com/blog/2014/05/21/collect-log-of-windows-machine-into-splunk</id>
    <content type="html"><![CDATA[<h3>Why do I need Splunk</h3>

<p>Recently, our team is moving several legacy components running in Windows server from data-center to AWS. The transformation itself is not hard, but the eco-system like monitoring, alerting, troubleshooting is most important before getting started the transofrmation.</p>

<p>The article would talk about how to setup and config Splunk Universal Forwarder in Windows machine where the component is running.</p>

<p>Bying using SUF, Splunk central server can easily collect logs from different distributed machines, so that the OPS guy can query and analyze the logs from one portal rather than login on different distributed machines.</p>

<!--More-->


<h3>Terminology</h3>

<p><strong>SCS</strong> (Splunk Central Server)</p>

<pre><code>It is the splunk server that OPS can access this machine and query or analyze the logs from distributed nodes.
</code></pre>

<p><strong>SUF </strong>(Splunk Universal Forwarder)</p>

<pre><code>It is the component running in application server, which can forward log to Splunk Central Server.
</code></pre>

<h3>How to install SUF</h3>

<ol>
<li><p>Download <a href="http://download.splunk.com/products/splunk/releases/6.1.1/universalforwarder/windows/splunkforwarder-6.1.1-207789-x64-release.msi">Universal Forwarder</a></p></li>
<li><p>Run Universal Forwarder Wizard, following the <a href="http://docs.splunk.com/Documentation/WindowsApp/5.0.2/User/InstallauniversalforwarderonaWindowsserver">guide</a></p>

<ul>
<li>Click &#8216;Next&#8217; until &#8220;Receiving Indexer&#8221; dialog appears</li>
<li>In[&#8220;Receiving Indexer&#8221; dialog] page, enter hostname with splunk central server and port with &#8220;9997&#8221;.</li>
<li>Click &#8216;Next&#8217; and finish the installation.</li>
</ul>
</li>
<li><p>Config Universal Forwarder</p>

<ul>
<li>Open file &#8220;C:\Program Files\SplunkUniversalForwarder\etc\system\local\inputs.conf&#8221;</li>
<li>Append the following content into the file
<pre>
  [monitor://C:\inetpub\logs\OnlinePayment*.log]
  ignoreOlderThan = 10d
  disabled = 0
  followTail = 0
  //logs will be grouped by index in splunk central server
  index = "listing"<br/>
  //<a href="http://docs.splunk.com/Documentation/Storm/Storm/User/Sourcesandsourcetypes">Pre-defined source type</a>, or you can specify any value as you like
  sourcetype = "YOUR-SOURCE-TYPE"
</pre></li>
</ul>


<p> Please check the <a href="http://docs.splunk.com/Documentation/Splunk/6.1/admin/Inputsconf">doc</a> to understand the meaning of each item above.</p></li>
<li><p>Restart Universal Forwarder</p>

<ul>
<li>Execute <code>cd "C:\Program Files\SplunkUniversalForwarder\bin"</code> in command line.</li>
<li>Execute <code>splunk restart</code> in command line.</li>
</ul>
</li>
</ol>


<h4>Create new index in SCS</h4>

<p>Right now, there is no index named &#8216;listing&#8217;, so we need to create a new index in splunk central server.</p>

<p>The step is as below:</p>

<ol>
<li>Login Splunk central server</li>
<li>Click &#8220;Manager&#8221; menu at top right navigator and go to &#8220;Manager&#8221; page.</li>
<li>Click &#8220;Indexes&#8221; and go to &#8220;Indexes&#8221; page.</li>
<li>Click &#8220;New&#8221; and input &#8220;bs&#8221; as &#8216;index name&#8217;</li>
<li>Keep others blank and Click &#8220;Save&#8221;</li>
</ol>


<h3>Summary</h3>

<p>It is time to cheer!
Your log should appear in Splunk Central Server, and you can enjoy it now.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to setup mongo shard]]></title>
    <link href="http://wldandan.github.com/blog/2014/04/23/how-to-setup-mongo-shard/"/>
    <updated>2014-04-23T09:44:00+08:00</updated>
    <id>http://wldandan.github.com/blog/2014/04/23/how-to-setup-mongo-shard</id>
    <content type="html"><![CDATA[<p>To simulate the process of production deployment of MongoDB, I used Vagrant to create a couples of VMs, and exprienced the journey of deployment mongo step by step as follow mentioned.</p>

<h3>Mongo Shard Concepts</h3>

<p>Before dived into the code, we can review the concepts related to Mongo Shard, it needs 3 components logically at least.</p>

<h4>a) Config Server</h4>

<p>The config server processes are mongod instances that   store the cluster’s metadata. You designate a mongod as a config server using the &#8211;configsvr option. Each config server stores a complete copy of the cluster’s metadata.</p>

<h4>b) Query Server</h4>

<p>The query server are lightweight mongos instances and   do not require data directories. You can run a mongos   instance on a system that runs other cluster    components, such as on an application server or a   server running a mongod process. By default, a mongos   instance runs on port 27017.</p>

<!--More-->


<h4>c) Shard Server</h4>

<p>The shard server is a component which can consist of    a repicaSet(multiple machines).</p>

<h3>Mongo Shard Setup</h3>

<h4>a) Create mongo box</h4>

<pre><code>vagrant box add precise64 http://files.vagrantup.com/precise64.box  
setup mongo as [Mongo GUide](http://example.net/) mentioned
vagrant package --base default --output mongo_vm.box
</code></pre>

<h4>b) Create several VMs</h4>

<p>Please check the vagrant config file from here
3 config servers
2 query servers
2 replicaSet and each replica has 2 instances.</p>

<h4>c) Setup the shard</h4>

<pre><code>1) start config servers
    (ssh to 192.168.2.21 config1): mongod --configsvr --dbpath /home/vagrant/mongo-config --port 27020
    (ssh to 192.168.2.22 config2): mongod --configsvr --dbpath /home/vagrant/mongo-config --port 27020
    (ssh to 192.168.2.23 config3): mongod --configsvr --dbpath /home/vagrant/mongo-config --port 27020

2) start query servers
    (ssh to 192.168.2.31 router1): mongos --configdb 192.168.2.21:27020,192.168.2.22:27020,192.168.2.23:27020 --port 27017 --chunkSize 2
    (ssh to 192.168.2.32 router2): mongos --configdb 192.168.2.21:27020,192.168.2.22:27020,192.168.2.23:27020 --port 27017 --chunkSize 2

3) start replicaSet1
    (ssh to 192.168.2.41 rep1a): mongod --dbpath /home/vagrant/mongo-data --port 27040 --replSet rep1 --oplogSize 200 --rest
    (ssh to 192.168.2.42 rep1b): mongod --dbpath /home/vagrant/mongo-data --port 27040 --replSet rep1 --oplogSize 200 --rest

4) start replicaSet2
    (ssh to 192.168.2.51 rep2a): mongod --dbpath /home/vagrant/mongo-data --port 27040 --replSet rep2 --oplogSize 200 --rest
    (ssh to 192.168.2.52 rep2b): mongod --dbpath /home/vagrant/mongo-data --port 27040 --replSet rep2 --oplogSize 200 --rest
</code></pre>

<h3>Config the shard</h3>

<pre><code>use mongo clien access any one of query server, and then execute 

    db.runCommand({addshard:'rep1/192.168.2.41:27040,192.168.2.42:27040'})
    db.runCommand({addshard:'rep2/192.168.2.51:27040,192.168.2.52:27040'})
    db.runCommand({listshards:1});

    You will see the shard server has been configured.
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to setup mongo repliSet]]></title>
    <link href="http://wldandan.github.com/blog/2014/04/17/how-to-setup-mongo-repliset-in-one-machine/"/>
    <updated>2014-04-17T09:24:00+08:00</updated>
    <id>http://wldandan.github.com/blog/2014/04/17/how-to-setup-mongo-repliset-in-one-machine</id>
    <content type="html"><![CDATA[<h3>Create one mongo repliSet</h3>

<pre><code>mkdir -p /srv/mongodb/rs0-0 /srv/mongodb/rs0-1 /srv/mongodb/rs0-2
</code></pre>

<h3>Run instances</h3>

<pre><code>mongod --port 27017 --dbpath /srv/mongodb/rs0-0 --replSet rs0 --smallfiles --oplogSize 128
mongod --port 27018 --dbpath /srv/mongodb/rs0-1 --replSet rs0 --smallfiles --oplogSize 128
mongod --port 27019 --dbpath /srv/mongodb/rs0-2 --replSet rs0 --smallfiles --oplogSize 128
</code></pre>

<h3>Enable replicaSet</h3>

<pre><code>mongo --port 27017
rs.initiate()
rs.conf()
rs.status()
</code></pre>

<!--More-->


<h3>Add other instances as repliSet</h3>

<pre><code>* Login to 'primary' node by mongo client

rs.add("&lt;hostname&gt;:27018")
rs.add("&lt;hostname&gt;:27019")
</code></pre>

<h3>Check ReplicatSet config</h3>

<pre><code>* Login to any replicaSet instance

rs.conf()
rs.status()
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dora诞生记]]></title>
    <link href="http://wldandan.github.com/blog/2014/02/14/the-story-about-dora/"/>
    <updated>2014-02-14T23:32:00+08:00</updated>
    <id>http://wldandan.github.com/blog/2014/02/14/the-story-about-dora</id>
    <content type="html"><![CDATA[<p>趁着在墨尔本和西安Office上Hackday获奖的喜悦劲，赶紧来一篇Dora诞生记。  <br/>
提醒偶记住这个特殊的日子，同时也感谢在过去两个月，牺牲个人时间，奋斗在Dora(X-Robot)上的Casa的兄弟姐妹们。</p>

<h5>-2013年10月20</h5>

<p>和Charley午餐的时候，无意间谈论起了各自想做但没时间做的idea。</p>

<p>幸运乎，找到一个我俩都认为不错但又没被完全实现的一个想法&lt;&lt;公交来了>>(<strong>旨在帮助等车族们准确的掌握公交将来的时间，为既不想迟到又想多赖几分钟在床上的兄弟提供福音</strong>)。</p>

<!--More-->


<h5>-2013年10月25</h5>

<p>借着Team Retro, 抛出了这个话题，“<strong>是不是应该每周抽出点业余时间，让大家坐在一起，实现自己想实现但却一直没时间实现的Idea</strong>”。</p>

<p>为了保证大家能够集中火力在一个项目上，于是每个人都做了自己Idea的present，然后团队集体投票选出一个可以一起做的idea，并开工。</p>

<p>为这个活动起了个洋气的名字<strong>LBS</strong> (Let&#8217;s Build Something)，并且暂定为每周一晚6:00~8:00是我们的官方活动时间。</p>

<h5>-2013年11月18</h5>

<p>LBS有条不紊的进行着，&lt;&lt;公交来了>>也有了点小眉目。</p>

<p>客户Enrico来访，茶余饭后闲聊之际，他提到了构建可远端操控的小车的想法，目的让更多的Casa guy们知道西安的团队如何工作，例如站会，Rero，Piar，以及如何敏捷的交付等等。</p>

<p>我自然也聊到了我们的LBS以及正在做的 &lt;&lt;公交来了>>。</p>

<h5>-2013年11月24</h5>

<p>邀请Enrico参加了我们的LBS，X-Robot的火花被果断擦出，旨在构建一个能控制其移动并回传视频的机器人，方便Italia和Xi&#8217;an Office更加随意的沟通。</p>

<h5>-2013年12月10</h5>

<p>经过几天的探索，技术选型基本确定:  <br/>
* 使用<strong>NodeJS</strong>构建服务器端应用。 <br/>
* 使用<strong>WebRTC</strong>处理视频部分。 <br/>
* 使用<strong>Arduino</strong>作为X-Robot的控制芯片。  <br/>
* 构建<strong>Android Native App</strong>控制Arduino。  <br/>
* 使用<strong>WebSocket</strong>为用户提供UI的控制接口。</p>

<h5>-2013年12月22</h5>

<p>淘宝上买的Arduino到货。在Team掀起了一阵研究Arduino的热潮。  <br/>
同时，被告知卖家发的小车出了点问题，需要再等，捉急。</p>

<h5>-2014年1月7</h5>

<p>超级无敌高大上的小车到了，立马组装之。  <br/>
Android的Native APP有了雏形，使用USB将手机连接到Arduino，能够发出控制信号了。  <br/>
使用Arduino可以控制X-Robot的<strong>前进</strong>，<strong>后退</strong>了。</p>

<h5>-2014年1月20</h5>

<p>集成WebRTC，WebSocket到Android Native APP。  <br/>
<strong>前进、后退、优雅的转弯、视频传输</strong>都没问题啦。</p>

<h5>-2014年2月7</h5>

<p>小伙伴卿带着X-Robot踏上了去Melboune的HackDay之路。</p>

<h5>-2014年2月14</h5>

<p>X-Robot有了一双迷人的大眼睛并正式命名为&#8221;<strong>Dora</strong>&#8220;。  <br/>
小家伙不负众望，为我们赢得了“<strong>The ‘Marvin‘ Winners for innovation</strong>”奖项。</p>

<p>至此，Dora诞生了。接下来，我们会为Dora提供更多有意思的功能，敬请期待 :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[WebRTC - Understand the PeerConnection]]></title>
    <link href="http://wldandan.github.com/blog/2014/01/07/webrtc-understand-the-peerconnection/"/>
    <updated>2014-01-07T18:55:00+08:00</updated>
    <id>http://wldandan.github.com/blog/2014/01/07/webrtc-understand-the-peerconnection</id>
    <content type="html"><![CDATA[<p>在上篇文章里，我们已经了解了MediaStream。那么这篇文章里，我们就来重点了解RTCPeerConnection。</p>

<p>RTCPeerConnection表示浏览器之间点对点的连接。只有当连接建立后，浏览器的两端才能真正完成流媒体数据的传输。</p>

<p>还记得之前讨论过的WebRTC架构图吗？
实际上，虽然RTCPeerConnection是一个暴露的连接接口，
但其内部封装了大量WebRTC编解码和协议处理的工作，因此使浏览器之间点到点的即时通讯变得简单。</p>

<!--More-->


<h4>什么是信令处理(Signaling)</h4>

<p>WebRTC使得浏览器之间能够点对点通信，但是作为浏览器的一端，茫茫大海，如何知道另一端在哪里？怎么能通过网络连接到对端？如何知道是否能够连接成功？</p>

<p>所以，即便是点对点通信，依然需要服务器协助双方建立连接。不过此时的服务器，其职责更多的是 交换元数据，如编解码机制、数据加密、流量控制等信息。</p>

<p>对于这些看似不重要但却必要的信息交换过程，我们称之为信令处理。</p>

<p><img src="http://wldandan.github.com/images/webrtc/webrtc-signaling.png" /></p>

<h4>NAT、防火墙和现实的网络世界</h4>

<p>NAT(Net Address Translation)是负责网络地址转换的一个协议。通俗的说，它负责把私网内的的IP和端口转换成公网的IP和端口，也即使我们所说的IP地址映射。</p>

<p>由于IPv4地址的数量有限，大多数企业或者团体通常都使用局域网地址，并通过NAT转换，连接到互联网上。另外，
许多企业内部网络都存在防火墙，因此这就为点对点通信带来寻址问题。</p>

<p><img src="http://wldandan.github.com/images/webrtc/nat.png" /></p>

<p><a href="http://en.wikipedia.org/wiki/STUN">STUN</a>,TURN,ICE是由IETF提出的处理网络中NAT穿越问题的协议族。
STUN能够为NAT后的终端定位公网地址，因此它可以被用来在两个同时处于NAT之后的终端建立UDP通信。
TURN是STUN协议的一个增强版，能够通过中继的方式帮助处于NAT之后的终端建立TCP连接。ICE则是综合STUN及TURN的产物，是一个框架。</p>

<p>使用STUN服务器后，通信双方能够完成NAT穿透，从而建立连接，如下图所示：</p>

<p><img src="http://wldandan.github.com/images/webrtc/stun.png" /></p>

<p>使用TURN服务器后，通信双方需要通过中继完成NAT穿透，从而建立连接，如下图所示。从某种角度而言，这种方式已经不是传统意义上的点对点连接了，因为它依赖于中继服务器完成数据的传输。</p>

<p><img src="http://wldandan.github.com/images/webrtc/turn.png" /></p>

<h4>建立RTCPeerConnection</h4>

<p>了解了STUN，TURN的相关概念后，是深入了解PeerConnection的时候了。</p>

<p>当创建RTCPeerConnection时，需要指定两个参数：</p>

<ul>
<li>包括STUN或者TURN服务器的列表。</li>
<li>对于协议元数据的参数设置。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  var SERVER = {
</span><span class='line'>    iceServers: [
</span><span class='line'>        {url: "stun:23.21.150.121"},
</span><span class='line'>        {url: "stun:stun.l.google.com:19302"},
</span><span class='line'>        {url: "turn:numb.viagenie.ca", credential: "xxxx", username: "xxx"}
</span><span class='line'>    ]
</span><span class='line'>  };
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>  var OPTIONS = {
</span><span class='line'>        optional: [
</span><span class='line'>          {DtlsSrtpKeyAgreement: true},
</span><span class='line'>          {RtpDataChannels: true}
</span><span class='line'>        ]
</span><span class='line'>  };
</span><span class='line'>  peerConnection = new RTCPeerConnection(SERVER, OPTIONS);
</span></code></pre></td></tr></table></div></figure>


<p>注意，当RTCPeerConnection执行连接时，首先会尝试使用STUN服务器来协助完成，如果失败，则使用TURN中继服务器完成通信。</p>

<h4>开始通信</h4>

<p>通信的过程如下如所示:
<img src="http://wldandan.github.com/images/webrtc/peerconnection-process.png" /></p>

<h5>主动发起者将使用createOffer发起连接，并设置SDP(Session Description Protocol)相关信息.</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  navigator.getUserMedia({video: true}, function(stream) {
</span><span class='line'>    var video = document.getElementById("video");
</span><span class='line'>    video.srcObject = stream;
</span><span class='line'>    video.play();
</span><span class='line'>    pc.addStream(stream);
</span><span class='line'>
</span><span class='line'>    pc.createOffer(function(offer) {
</span><span class='line'>      pc.setLocalDescription(new RTCSessionDescription(offer), function() {
</span><span class='line'>        // send the offer to a server to be forwarded the friend you're calling.
</span><span class='line'>      }, error);
</span><span class='line'>    }, error);
</span><span class='line'>  }</span></code></pre></td></tr></table></div></figure>


<h5>对端接受者，收到setRemoteDescription并使用createAnswer回复连接请求。</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  navigator.getUserMedia({video: true}, function(stream) {
</span><span class='line'>    var video = document.getElementById("video");
</span><span class='line'>    video.srcObject = stream;
</span><span class='line'>    video.play();
</span><span class='line'>    pc.addStream(stream);
</span><span class='line'>
</span><span class='line'>    pc.setRemoteDescription(offer, function() {
</span><span class='line'>      pc.createAnswer(function(answer) {
</span><span class='line'>        pc.setLocalDescription(new RTCSessionDescription(answer), function() {
</span><span class='line'>          // send the offer to a server to be forwarded to the caller
</span><span class='line'>        }, error);
</span><span class='line'>      }, error);
</span><span class='line'>    }, error);
</span><span class='line'>  }</span></code></pre></td></tr></table></div></figure>


<h5>主动发起者，处理对端发回的响应，并设置setRemoteDescription信息。</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  var offer = getResponseFromFriend();
</span><span class='line'>  pc.setRemoteDescription(new RTCSessionDescription(offer), function() { }, error);</span></code></pre></td></tr></table></div></figure>


<h5>总结:</h5>

<ul>
<li>创建RTCPeerConnection对象, 指定相关的STUN、TURN服务器。</li>
<li>每个RTCPeerConnection对象都关联一个ICE agent。当创建该对象时，ICE agent的相关状态会被初始化。</li>
<li>每个RTCPeerConnection对象关联两个流媒体集合。</li>
<li>本地流媒体集合(Local stream set), 本地流媒体集合代表当前发送的数据流，</li>
<li>远程流集合(Remote stream set), 远程流媒体集合代表RTCPeerConnection对象接收到的流</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[WebRTC - Understand the MediaStream]]></title>
    <link href="http://wldandan.github.com/blog/2014/01/06/webrtc-understand-the-media-stream/"/>
    <updated>2014-01-06T23:59:00+08:00</updated>
    <id>http://wldandan.github.com/blog/2014/01/06/webrtc-understand-the-media-stream</id>
    <content type="html"><![CDATA[<p>WebRTC从设计之初，目的就是为开发人员提供更加简便的方式构建基于Web的视频、音频应用。对于任何的WebRTC应用程序，只需要做如下几件事情：</p>

<ul>
<li>1）获取本地媒体流(音频、视频)。</li>
<li>2）与对端建立连接(包括防火墙和NAT的穿透)。</li>
<li>3）初始化双方通信信道。</li>
<li>4）交换通信元数据信息，比如分辨率、编解码方案、网络地址等。</li>
<li>5）开始音频，视频或数据的通信。</li>
</ul>


<!--More-->


<p>为了完成这个过程，WebRTC提供了三个主要的对象接口：</p>

<ul>
<li>MediaStream</li>
<li>RTCPeerConnection</li>
<li>RTCDataChannel</li>
</ul>


<p>在这篇文章里，我们先来看看如何使用MediaStream。</p>

<p>MediaStream代表一个抽象的流媒体对象，通常是音频或视频的内容。每个媒体流对象中，包含零个或多个轨道（MediaStreamTrack)，用来显示并控制该流媒体对象的输入源名称，如音频还是视频，特征或者状态，同时也能控制如静音、开始或者结束等。</p>

<p>每个MediaStream都有输入和输出，输入一般由navigator.getUserMedia()（下面会详细介绍）生成，而输出则可以控制该流媒体对象如何被使用，例如存储到文件，显示在在video元素中，或者绑定到RTCPeerConnection的连接上。</p>

<p><img src="http://wldandan.github.com/images/webrtc/media-stream.png" /></p>

<p>getUserMedia()是浏览器提供的获取音频和视频媒体流的API。对于捕获到的流媒体，其和信号源是紧密相关的，如麦克风只能发出音频流，摄像头只能发出视频流。对于某些高清摄像头，可以产生高清的视频流。</p>

<p>当使用getUserMedia() 获取视频或音频的媒体流时，需要指定三个参数：</p>

<ul>
<li>设置流媒体的配置参数</li>
<li>获取视频成功的回调函数</li>
<li><p>获取视频失败的回调函数</p>

<pre><code>  &lt;video autoplay&gt;&lt;/video&gt;
  &lt;script&gt;
      var constraints = {
          audio: true,
          video: { 
              mandatory: {  
                  width: { min: 320 },
                  height: { min: 180 }},          
              optional: [{                 
                  width: { max: 1280 }, 
                  height: { max: 720 }},          
                  { frameRate: 30 }]
          }
      }

      function successCallback(stream) {
          window.stream = stream; 
          var video = document.querySelector("video");
          video.src = window.URL.createObjectURL(stream);
          video.play();
      }

      function errorCallback(error){
          console.log("navigator.getUserMedia error: ", error);
      }

      navigator.getUserMedia(constraints, gotStream, logError);  
  &lt;/script&gt;
</code></pre></li>
</ul>


<p>在如上所示的Javascript代码中，
首先定义了对象constraints，包括容许获取视频、音频，以及获取视频时，可接受的最小分辨率以及可选最大分辨率。<br/>
然后定义了获取媒体流成功时的处理函数successCallback和失败的处理函数errorCallback。<br/>
最后，使用navigator.getUserMedia()获取视频和音频的媒体流。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[WebRTC - The revolution of media communication]]></title>
    <link href="http://wldandan.github.com/blog/2014/01/02/webrtc-the-revolution-of-media-communication/"/>
    <updated>2014-01-02T19:29:00+08:00</updated>
    <id>http://wldandan.github.com/blog/2014/01/02/webrtc-the-revolution-of-media-communication</id>
    <content type="html"><![CDATA[<h3>什么是WebRTC</h3>

<p>如今，互联网主流的音频、视频通信服务产品，如Skype, QQ, GTalk等， 都是各自厂商私有的技术。用户需要安装插件或者桌面客户端，才能使用其提供的音频或者视频通信功能。
如果某天，不使用任何插件，只通过浏览器，就能实现手机、平板、电视和电脑的视频或者音频通信；那会是什么场景？ 而这正是WebRTC的愿景。</p>

<p>WebRTC（Web Real-Time Communication）由一套开放的标准、协议和一组JavaScript API构成。2010年，谷歌收购了VoIP软件开发商GIPS(Global IP Solutions)，并获得了视频采集、编解码、网络传输、回音消除等RTC相关技术。2011年6月，谷歌开放了该部分源码，并积极推动该项技术，这奠定了RTC在Web领域发展的基础。</p>

<p>WebRTC使浏览器之间能够通过点对点的通信方式，直接完成视频、音频以及数据的实时传输。同时，WebRTC容许开发人员通过调用浏览器支持的API，使用HTML5标签和JavaScript轻松的实现基于Web的音频、视频应用。</p>

<p>目前，WebRTC的标准还在不断完善中，W3C、IETF和其他一些浏览器厂商正在积极的推动WebRTC的发展。WebRTC开创了浏览器之间能够直接通信并完成视频或者音频传输的新时代。对于构建开放的、标准的，无插件，免费的视频音频通信应用，迈出了划时代的一步。</p>

<!--More-->


<h3>WebRTC的架构</h3>

<p>WebRTC的架构如下图所示
<img src="http://wldandan.github.com/images/webrtc/webrtc-architecture.png" /></p>

<p>其中主要包括如下几部分:</p>

<ul>
<li><p>紫色部分是面向Web开发者的API层。该部分API由浏览器提供。</p></li>
<li><p>蓝色实线部分是面向浏览器厂商的API层。</p></li>
<li><p>蓝色虚线部分是浏览器厂商可以自定义实现的部分。</p></li>
<li><p>绿色部分是WebRTC的引擎部分，当前主要包括视频引擎、音频引擎以及传输协议。</p></li>
</ul>


<p>a) 视频引擎  <br/>
包含从视频采集、编解码(I420/VP8)、加密、媒体文件、图像处理、显示、网络传输等功能。
提供VP8作为视频图像编解码器。降低由于视频抖动和视频信息包丢失带来的不良影响。另外，对采集到的图像进行增强处理，包括明暗度检测、颜色增强、降噪处理等，提升视频质量。</p>

<p>b) 音频引擎  <br/>
包含从音频采集、编解码(iLIBC/iSAC)、抖动处理(NetEQ)、加密、输出、同步、音量控制、网络传输。
提供iSAC/iLBC两种处理音频的解码方案。同时，使用NetEQ算法有效的处理由于网络抖动和语音包丢失时候对语音质量产生的影响。另外，还提供了回声消除和降噪等机制。</p>

<p>c) 传输协议<br/>
采用成熟的RTP/RTCP协议栈，支持多路复用，并通过STUN、TURN以及ICE保证网络间的通信。</p>

<p>截止目前，整个WebRTC的标准还在不断完善中。W3C的WebRTC工作组负责浏览器API的标准化，IETF的 WebRTC工作组则主要负责通信协议、数据格式、安全等方面的标准化。</p>
]]></content>
  </entry>
  
</feed>
