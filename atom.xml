<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Happy Coding, Happy Life]]></title>
  <link href="http://wldandan.github.com/atom.xml" rel="self"/>
  <link href="http://wldandan.github.com/"/>
  <updated>2020-01-26T18:27:28+08:00</updated>
  <id>http://wldandan.github.com/</id>
  <author>
    <name><![CDATA[wldandan]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[读书笔记 - 《深度思考》]]></title>
    <link href="http://wldandan.github.com/blog/2020/01/26/shen-du-si-kao-du-shu-bi-ji/"/>
    <updated>2020-01-26T11:34:05+08:00</updated>
    <id>http://wldandan.github.com/blog/2020/01/26/shen-du-si-kao-du-shu-bi-ji</id>
    <content type="html"><![CDATA[<h2>背景</h2>

<p>本书的作者是香奈儿前CEO莫琳·希凯，书名《深度思考》，<code>副标题 - 不断逼近问题的本质</code>。</p>

<p><img src="http://wldandan.github.com/images/readings/shendusikao.jpg" /></p>

<!--More-->


<p>原以为这是一本思考类或者实践类的书籍，读完后，感觉有一点意外，其实是作者的自传。
书中描述了作者在职场三十年的缩影，讲述了真实的经历，从欧莱雅、GAP到香奈儿，从中规中矩的袜子、皮带销售到敢于突破传统，创新的老海军女裤，从十几人的小团队到200多人的高管，再到香奈儿全球的CEO，这背后的成长有运气，但更多体现的是作者的睿智以及对信念的追求、思考以及坚持。</p>

<blockquote><p>莫林·希凯，2007年加入香奈儿担任全球CEO，2016年离职。加入法国香奈儿品牌之前在美国大众品牌GAP有15年的工作经验，从小职员成长到CEO，从法国欧莱雅开始第一份工作。</p></blockquote>

<h2>主要内容：</h2>

<h3>1. 大脑走的越远，现实走的越稳</h3>

<p>从孩童时期法国寄宿的不适开始，逐渐放下先见之明，拥抱陌生地域和文化体验的影响，并帮助她意识到在最能派上用场的地方发挥感染力。一个文科生眼中的新浪潮电影，将电影课完美的融入到文学专业中，提高观察力，感受电影对情绪和感觉的影响，以及如何通过细节触动他人。</p>

<h3>2. 时刻思考自己的未来</h3>

<p>工作后，作为产品经理加入欧莱雅，同商学院毕业的营销同事相比，并非仅依赖于市场调查或传统的评估模式，重要的是观察和感受顾客是如何理解营销背后的符号的。顾客不会研究广告图像，更多的会用心感受，感觉其与自身的情感、生活、理想的关系。</p>

<h3>3. 激情让你更加优秀</h3>

<p>几年后加入GAP，因推动的新品与传统GAP的定位不一样，想尽办法并通过自身的试穿赢得了机会，并因为出色的能力升到了高管。</p>

<blockquote><p>Leader心中都有预想好的“愿景、使命和战略”，但不管初衷设计的如何精美，一旦员工阅读并阐述时，这些“意愿”都会被杀死 &mdash;《作者之死》。
任何Leader都必须有一个“我”的定位(我们是谁，什么是重要的)
如果强加自己的观点，团队不是沉默地反抗，高声的否定，就是盲目的遵循，每种反应都是灾难性的。
人文科学的每个领域，其实是教我们反思如何理解世界的方式</p></blockquote>

<p>在巴黎居住的时间里，舍友菲勒让她感受了到了<strong>超越约束、回归真我、追求实用</strong>的重要性，这也成为成她日后生活工作的根基</p>

<h3>4.打破传统，重新定义自己</h3>

<p><strong>你需要了解那些仅占市场份额少的竞争对手吗？我们可以超出社会的审美标准想象美吗？我们从未认真观察过的东西，它们存在的独特之处你想过吗?</strong></p>

<p>到法国北部地区的推销，并作为培训计划的第一部分，让莫琳感受到压力。第一次参加执行总裁例会，不论人们的立场，经验，教育和年龄如何不同，从新位置开始是不容易的：
尴尬的时刻、新手的无知、奇异的规则和仪式、新奇的行话、有形无形的考验，微妙的社交细节&hellip;..这些元素都是意料之中的。</p>

<blockquote><p>无论你的职业发展到哪个阶段，“学习”和“反学习”(忘记你所学到的，重新学习)的循环是不可避免的。</p></blockquote>

<h3>5.扭转规则，创造新事物</h3>

<p>你的标签是什么？你如何能扭转规则，创造重要的事物？什么独特才能让你成功？什么“音乐”能撩动你内心的心扉，启发你的工作? 什么特长能让你在职业中“出类拔萃”？透过谁的视觉能让你“高瞻远瞩”？</p>

<h3>6.重要的不是决定，是决定背后的动机</h3>

<h3>7. 找到新视角，新愿景，新的充满启发的观点</h3>

<p>无论角色多么细小，我也可以有着自己的影响力。我学到的一切东西，甚至最微不足道的细节，都能建立我的能力和信心，争取自己的权利，必要时作出超出常规的抉择。</p>

<p>坚持自己的立场，提出自己的主张并不是为了挑战权威或证明自己的价值。坚持自己的立场的意义在于，你能作出贡献：贡献新的视角，新的愿景，新的充满启发的观点。</p>

<p>简而言之，无论多么微小的机会都能发挥你的才能，无论多么苛刻的老板你都能从她们身上学到东西。即使她们一无是处，你也可以学到什么是错误的领导方式，张开双眼，重塑所见，你会看到无线资源等你挖掘。</p>

<h3>8. 比勤奋更重要的是深度思考的能力</h3>

<p>如果想在事业和生活上取得成功，必须练习倾听的技能。米奇教会了她如何倾听，不要总是一味的去展示自己的意见，要听听别人的声音，会对自己的想法有新的补充，完全坚持自己就会变成独裁者。
严于自律是一种优秀品质，但讨好每个人会让我疲惫不堪，也会使我质疑自己的每个决定，最终限制了领导力。</p>

<h3>9. 大胆的怀疑自己，坚定的肯定自己</h3>

<h3>10. 有些问题永远找不到答案，但值得去思考</h3>

<p>为什么香奈儿最终雇佣了我？除了在GAP获得的成就，其他一些特征非常重要：
* 相信创意的力量驱动商业
* 放弃曾经的总裁身份，从头学起
* 等待3年，再担任CEO</p>

<h3>11. 同时遵守规则，打破规则</h3>

<p>创意往往源于悖论。将两个看似相反的想法、品质、设计或物体结合起来，发明出令人惊讶、超乎所料的美。打破任何强加在你身上的标签，拥抱自己的悖论，重新审视所学的知识，发展出强大的观点，在世界中留下足迹。打破标签，返璞归真。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[k8s之Deployment]]></title>
    <link href="http://wldandan.github.com/blog/2019/04/06/k8s-deployment/"/>
    <updated>2019-04-06T14:48:00+08:00</updated>
    <id>http://wldandan.github.com/blog/2019/04/06/k8s-deployment</id>
    <content type="html"><![CDATA[<p>之前我们了解了如何打包，作为Pod中的容器运行，使用临时或者永久存储机制，设置配置项，接下来我们探讨如何部署和升级。</p>

<h5>应用更新的方式</h5>

<p>假定在K8S中存在这样的应用：
* Service
* 3个Pod
* 使用ReplicaSet
* Clients</p>

<p>初始情况，运行V1版本的应用。接下来，我们希望生成V2版本的镜像，并使用V2版本的Pod/容器进行升级。
存在两种方式：
* 先删除V1版本的应用，然后部署V2版本。
* 先新增V2版本的应用，然后删除V1版本。（对于V2版本的新增，可以选择 <code>一次新增全部数量</code>，<code>多次新增，每次部分数量</code>）</p>

<blockquote><p>对于第一种方式：简单，但是存在部署的停机时间<br/>
  对于第二种方式：系统需要同时处理两个版本的应用，尤其是数据Schema需要兼容新旧两个版本</p></blockquote>

<h6>ttt</h6>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[K8s之configmap]]></title>
    <link href="http://wldandan.github.com/blog/2019/04/06/k8s-concept-configmap/"/>
    <updated>2019-04-06T14:48:00+08:00</updated>
    <id>http://wldandan.github.com/blog/2019/04/06/k8s-concept-configmap</id>
    <content type="html"><![CDATA[<p>几乎所有的应用程序都需要配置（实例的配置信息，外部系统的访问信息等），而这些配置显然不应该被打包到应用程序本身中。</p>

<p>本篇文章看看如何在Kubernetes中配置应用程序的信息。</p>

<h4>1.配置容器应用的方式</h4>

<ul>
<li><p>命令行
最简单的应用配置方式，是使用命令行。</p></li>
<li><p>配置文件</p></li>
</ul>


<p>随着配置信息增多，考虑到维护成本，可以将配置信息存储到配置文件中。但对于容器而言，使用配置文件的方式需要将配置项打包到镜像中，而且每次配置信息的变更都会导致重新生成镜像，重新部署，维护和变更成本较高。</p>

<ul>
<li>环境变量</li>
</ul>


<p>在容器应用中，使用环境变量来实现配置，也是较普遍的一种做法，通过将参数传递给容器中的应用，变更容器运行期的配置信息，如MySQL官方的镜像就使用环境变量<code>MYSQL_ROOT_PASSWORD</code> 来修改超级用户root的密码。</p>

<ul>
<li>volume</li>
</ul>


<p>另外，基于volume的方式获取配置信息也是一种可行的方式，如使用Git Repo存储配置信息，能有效的做到版本化管理会随时回退。</p>

<p>在K8S中，存储配置信息的资源被称ConfigMap，本部分将介绍ConfigMap、Secret的使用。</p>

<h4>2.从命令行传递参数</h4>

<p>在Docker容器中，通常使用如下方式传递参数：</p>

<ul>
<li>使用<code>ENTRYPOINT</code>定义可执行命令</li>
<li>使用<code>CMD</code>传递参数</li>
</ul>


<p>在ENTRYPOINT中，可以使用如下两种方式启动应用：</p>

<ul>
<li>Shell方式，如<code>ENTRYPOINT node app.js</code></li>
<li>exec方式，如<code>ENTRYPOINT ["node", "app.js"]</code></li>
</ul>


<blockquote><p>注意: 这两种方式的区别在于前者是先启动Shell，由Shell调用node，而后者直接启动node应用。</p></blockquote>

<p>在K8S中，可以通过配置文件中的<code>command</code>和<code>args</code>来设置容器中的<code>ENTRYPOINT</code>和<code>CMD</code>
譬如</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='yaml'><span class='line'><span class="l-Scalar-Plain">kind</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">Pod</span>
</span><span class='line'><span class="l-Scalar-Plain">spec</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="l-Scalar-Plain">containers</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">image</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">some/image</span>
</span><span class='line'>    <span class="l-Scalar-Plain">command</span><span class="p-Indicator">:</span> <span class="p-Indicator">[</span><span class="s">&quot;/bin/command&quot;</span><span class="p-Indicator">]</span>
</span><span class='line'>    <span class="l-Scalar-Plain">args</span><span class="p-Indicator">:</span> <span class="p-Indicator">[</span><span class="s">&quot;arg1&quot;</span><span class="p-Indicator">,</span> <span class="s">&quot;arg2&quot;</span><span class="p-Indicator">,</span> <span class="s">&quot;arg3&quot;</span><span class="p-Indicator">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>它们之间的区别如下图所示：</p>

<table>
<thead>
<tr>
<th>Docker</th>
<th>Kubernetes</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>ENTRYPOINT</td>
<td>command</td>
<td>在容器中执行命令</td>
</tr>
<tr>
<td>CMD</td>
<td>args</td>
<td>给命令传递参数</td>
</tr>
</tbody>
</table>


<h4>3.使用环境变量</h4>

<p>在K8S中，使用<code>env</code>设置镜像中定义的环境变量。
譬如，容器中存在如下脚本，其中的<code>INTERVAL</code>使用环境变量进行设置：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c">#!/bin/bash</span>
</span><span class='line'><span class="k">while</span> :
</span><span class='line'><span class="k">do</span>
</span><span class='line'><span class="k">  </span><span class="nb">echo</span> <span class="k">$(</span>date<span class="k">)</span>
</span><span class='line'>  sleep <span class="nv">$INTERVAL</span>
</span><span class='line'><span class="k">done</span>
</span></code></pre></td></tr></table></div></figure>


<p>在K8S中，其配置文件类似如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='yaml'><span class='line'><span class="l-Scalar-Plain">kind</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">Pod</span>
</span><span class='line'><span class="l-Scalar-Plain">spec</span><span class="p-Indicator">:</span>
</span><span class='line'> <span class="l-Scalar-Plain">containers</span><span class="p-Indicator">:</span>
</span><span class='line'> <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">image</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">xxxxx</span>
</span><span class='line'>   <span class="l-Scalar-Plain">env</span><span class="p-Indicator">:</span>
</span><span class='line'>   <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">INTERVAL</span>
</span><span class='line'>     <span class="l-Scalar-Plain">value</span><span class="p-Indicator">:</span> <span class="s">&quot;30&quot;</span>
</span><span class='line'><span class="nn">...</span>
</span></code></pre></td></tr></table></div></figure>


<h4>4.使用CONFIGMAP解耦配置</h4>

<p>Kubernetes允许将配置项分离到一个称为<code>ConfigMap</code>的单独对象中，它包含若干键/值对，并且值的范围可以从文本到整个配置文件。</p>

<p>应用程序不需要直接读取ConfigMap，甚至不需要知道它的存在。Map的内容可以作为环境变量或者卷传递给容器。</p>

<p>使用<code>kubectl</code>创建ConfigMap的过程中，可以指定多样化的配置机制，类似如下所示：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>kubectl create configmap my-config
</span><span class='line'>  --from-file<span class="o">=</span>foo.json                     //导入JSON文件
</span><span class='line'>  --from-file<span class="o">=</span><span class="nv">bar</span><span class="o">=</span>foobar.conf              //导入配置文件
</span><span class='line'>  --from-file<span class="o">=</span>config-opts/                 //导入目录
</span><span class='line'>  --from-literal<span class="o">=</span><span class="nv">some</span><span class="o">=</span>thing                //导入文本配置
</span></code></pre></td></tr></table></div></figure>


<h5>4.1 使用ConfigMap Entry设置环境变量的值</h5>

<p>接下来， 在如上环境变量的例子中，我们使用ConfigMap配置环境变量<code>$INTERVAL</code>的值。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='yaml'><span class='line'><span class="l-Scalar-Plain">apiVersion</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">v1</span>
</span><span class='line'><span class="l-Scalar-Plain">kind</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">Pod</span>
</span><span class='line'><span class="l-Scalar-Plain">metadata</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">env-from-configmap</span>
</span><span class='line'><span class="l-Scalar-Plain">spec</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="l-Scalar-Plain">containers</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">image</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">xxxx</span>
</span><span class='line'>    <span class="l-Scalar-Plain">env</span><span class="p-Indicator">:</span>
</span><span class='line'>    <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">INTERVAL                 //环境变量名</span>
</span><span class='line'>      <span class="l-Scalar-Plain">valueFrom</span><span class="p-Indicator">:</span>
</span><span class='line'>        <span class="l-Scalar-Plain">configMapKeyRef</span><span class="p-Indicator">:</span>             <span class="l-Scalar-Plain">//使用ConfigMap</span>
</span><span class='line'>          <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">fortune-config       //ConfigMap的名称</span>
</span><span class='line'>          <span class="l-Scalar-Plain">key</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">sleep-interval        //ConfigMap的key</span>
</span><span class='line'><span class="nn">...</span>
</span></code></pre></td></tr></table></div></figure>


<p>在如上的例子中，读取ConfigMap<code>fortune-config</code>中Key<code>sleep-interval</code>对应的值，作为<code>$INTERVAL</code>的值。</p>

<h5>4.2 使用ConfigMap Entry作为环境变量</h5>

<p>譬如有个ConfigMap，它有两个键，分别是foo、bar。您可以使用envFrom属性将它们全部公开为环境变量，而不是像在前面的示例中那样依次使用env。</p>

<p>如下所示：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='yaml'><span class='line'><span class="l-Scalar-Plain">spec</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="l-Scalar-Plain">containers</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">image</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">some-image</span>
</span><span class='line'>    <span class="l-Scalar-Plain">envFrom</span><span class="p-Indicator">:</span>                      <span class="l-Scalar-Plain">//使用envFrom代替Env</span>
</span><span class='line'>    <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">prefix</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">CONFIG_             //使用前缀</span>
</span><span class='line'>      <span class="l-Scalar-Plain">configMapRef</span><span class="p-Indicator">:</span>               <span class="l-Scalar-Plain">//引用ConfigMap</span>
</span><span class='line'>        <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">my-config-map</span>
</span><span class='line'><span class="nn">...</span>
</span></code></pre></td></tr></table></div></figure>


<p>CONFIG_作为前缀，将导出如下环境变量CONFIG_foo和CONFIG_bar。当然，前缀是可选的，如不设置，则容器中的环境变量为foo和bar。</p>

<h5>4.3 使用ConfigMap Entry作为命令行参数</h5>

<p>接下来，让我们看看如何将ConfigMap中的值作为参数传递给容器中运行的进程。我们不能在pod.spec.containers.args字段中直接引用ConfigMap，但是可以从ConfigMap中初始化一个环境变量，然后引用参数中的值，相关代码如下所示:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='yaml'><span class='line'><span class="l-Scalar-Plain">apiVersion</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">v1</span>
</span><span class='line'><span class="l-Scalar-Plain">kind</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">Pod</span>
</span><span class='line'><span class="l-Scalar-Plain">metadata</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">fortune-args-from-configmap</span>
</span><span class='line'><span class="l-Scalar-Plain">spec</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="l-Scalar-Plain">containers</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">image</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">xxxxx</span>
</span><span class='line'>    <span class="l-Scalar-Plain">env</span><span class="p-Indicator">:</span>
</span><span class='line'>    <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">INTERVAL</span>
</span><span class='line'>      <span class="l-Scalar-Plain">valueFrom</span><span class="p-Indicator">:</span>
</span><span class='line'>        <span class="l-Scalar-Plain">configMapKeyRef</span><span class="p-Indicator">:</span>
</span><span class='line'>          <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">fortune-config</span>
</span><span class='line'>          <span class="l-Scalar-Plain">key</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">sleep-interval</span>
</span><span class='line'>    <span class="l-Scalar-Plain">args</span><span class="p-Indicator">:</span> <span class="p-Indicator">[</span><span class="s">&quot;$(INTERVAL)&quot;</span><span class="p-Indicator">]</span>
</span><span class='line'><span class="nn">...</span>
</span></code></pre></td></tr></table></div></figure>


<p>其关系如图所示：</p>

<p><img src="http://wldandan.github.com/images/k8s/k8s-volume-configmap-as-cmd-args.png" /></p>

<h5>4.3 使用ConfigMap volume导出ConfigMap的Entry</h5>

<p>ConfigMap除了可以作为环境变量以及命令行参数外，还可以包括整个目录中的配置文件。</p>

<p>譬如，在<code>configmap-files</code>目录下存在如下2个文件：</p>

<ul>
<li>my-nginx-config.conf</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='yaml'><span class='line'><span class="l-Scalar-Plain">server {</span>
</span><span class='line'>  <span class="l-Scalar-Plain">listen              80;</span>
</span><span class='line'>  <span class="l-Scalar-Plain">server_name         www.kubia-example.com;</span>
</span><span class='line'>
</span><span class='line'>  <span class="l-Scalar-Plain">gzip on;                                       1</span>
</span><span class='line'>  <span class="l-Scalar-Plain">gzip_types text/plain application/xml;         1</span>
</span><span class='line'>
</span><span class='line'>  <span class="l-Scalar-Plain">location / {</span>
</span><span class='line'>    <span class="l-Scalar-Plain">root   /usr/share/nginx/html;</span>
</span><span class='line'>    <span class="l-Scalar-Plain">index  index.html index.htm;</span>
</span><span class='line'>  <span class="l-Scalar-Plain">}</span>
</span><span class='line'><span class="l-Scalar-Plain">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>sleep-interval.txt</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>25
</span></code></pre></td></tr></table></div></figure>


<p>接下来，使用命令创建<code>ConfigMap</code></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>$ kubectl create configmap fortune-config --from-file=configmap-files
</span></code></pre></td></tr></table></div></figure>


<p>然后，我们可以使用volume将ConfigMap中的内容暴露给容器：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>apiVersion: v1
</span><span class='line'>kind: Pod
</span><span class='line'>metadata:
</span><span class='line'>  name: fortune-configmap-volume
</span><span class='line'>spec:
</span><span class='line'>  containers:
</span><span class='line'>  - image: nginx:alpine
</span><span class='line'>    name: web-server
</span><span class='line'>    volumeMounts:
</span><span class='line'>    ...
</span><span class='line'>    - name: config
</span><span class='line'>      mountPath: /etc/nginx/conf.d      //挂载到Pod中的目录
</span><span class='line'>      readOnly: true
</span><span class='line'>    ...
</span><span class='line'>  volumes:
</span><span class='line'>  ...
</span><span class='line'>  - name: config
</span><span class='line'>    configMap:                          //使用configMap作为volume的内容
</span><span class='line'>      name: fortune-config
</span><span class='line'>  ...
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[K8s之Volume]]></title>
    <link href="http://wldandan.github.com/blog/2019/04/05/k8s-concept-volume/"/>
    <updated>2019-04-05T21:04:00+08:00</updated>
    <id>http://wldandan.github.com/blog/2019/04/05/k8s-concept-volume</id>
    <content type="html"><![CDATA[<p>本篇文章主要介绍在K8S中，pod的容器如何访问外部磁盘存储，以及容器间如何实现共享存储，主要内容包括</p>

<ul>
<li>通过volume和emptyDir在容器中共享数据</li>
<li>在Pod中使用Git Repo</li>
<li>使用外部存储，如GCE</li>
<li>使用PV(PersistentVolume)和PVC(PersistentVolumeClaim)</li>
</ul>


<!--More-->


<h4>一. 使用emptyDir</h4>

<p>最简单的卷类型是emptyDir。顾名思义，emptyDir是从空目录开始。在pod中运行的应用程序可以向它写入任何文件。因为emptyDir卷的生命周期与pod的生命周期相关联，所以当pod被删除时，卷的内容会丢失。</p>

<p>emptyDir卷对于在同一个pod中运行的容器间共享文件特别有用。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='yaml'><span class='line'><span class="l-Scalar-Plain">apiVersion</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">v1</span>
</span><span class='line'><span class="l-Scalar-Plain">kind</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">Pod</span>
</span><span class='line'><span class="l-Scalar-Plain">metadata</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">fortune</span>
</span><span class='line'><span class="l-Scalar-Plain">spec</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="l-Scalar-Plain">containers</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">image</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">luksa/fortune                   1</span>
</span><span class='line'>    <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">html-generator                   1</span>
</span><span class='line'>    <span class="l-Scalar-Plain">volumeMounts</span><span class="p-Indicator">:</span>                          <span class="l-Scalar-Plain">2</span>
</span><span class='line'>    <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">html                           2</span>
</span><span class='line'>      <span class="l-Scalar-Plain">mountPath</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">/var/htdocs               2</span>
</span><span class='line'>  <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">image</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">nginx:alpine                    3</span>
</span><span class='line'>    <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">web-server                       3</span>
</span><span class='line'>    <span class="l-Scalar-Plain">volumeMounts</span><span class="p-Indicator">:</span>                          <span class="l-Scalar-Plain">4</span>
</span><span class='line'>    <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">html                           4</span>
</span><span class='line'>      <span class="l-Scalar-Plain">mountPath</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">/usr/share/nginx/html     4</span>
</span><span class='line'>      <span class="l-Scalar-Plain">readOnly</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">true                       4</span>
</span><span class='line'>    <span class="l-Scalar-Plain">ports</span><span class="p-Indicator">:</span>
</span><span class='line'>    <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">containerPort</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">80</span>
</span><span class='line'>      <span class="l-Scalar-Plain">protocol</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">TCP</span>
</span><span class='line'>  <span class="l-Scalar-Plain">volumes</span><span class="p-Indicator">:</span>                                 <span class="l-Scalar-Plain">5</span>
</span><span class='line'>  <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">html                             5</span>
</span><span class='line'>    <span class="l-Scalar-Plain">emptyDir</span><span class="p-Indicator">:</span> <span class="p-Indicator">{}</span>                           <span class="l-Scalar-Plain">5</span>
</span></code></pre></td></tr></table></div></figure>


<blockquote><ol>
<li>第1个容器名为<code>html-generator</code>，其镜像为<code>luksa/fortune</code></li>
<li>volume的名称是<code>html</code>，其在容器中的路径为<code>/var/htdocs</code></li>
<li>第2个容器为<code>web-server</code>，镜像为<code>nginx:alpine</code></li>
<li>第2个容器使用的卷为<code>html</code>，加载到<code>/usr/share/nginx/html</code></li>
<li>volume名称为<code>name</code>，emptyDir初始为为空</li>
</ol>
</blockquote>

<p>默认情况下，emptyDir使用Node的磁盘，但是你也可以使用内存，类似如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='yaml'><span class='line'><span class="l-Scalar-Plain">volumes</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">html</span>
</span><span class='line'>    <span class="l-Scalar-Plain">emptyDir</span><span class="p-Indicator">:</span>
</span><span class='line'>      <span class="l-Scalar-Plain">medium</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">Memory</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<h4>二. 使用Git Repo</h4>

<p>Git Repo卷基本上是基于emptyDir，通过克隆Git仓库并在pod启动时（但在创建其容器之前）签出特定版本。如图6.3所示:</p>

<p><img src="http://wldandan.github.com/images/k8s/k8s-volume-gitrepo.png" /></p>

<p>示例代码如下所示：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='yaml'><span class='line'><span class="l-Scalar-Plain">apiVersion</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">v1</span>
</span><span class='line'><span class="l-Scalar-Plain">kind</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">Pod</span>
</span><span class='line'><span class="l-Scalar-Plain">metadata</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">gitrepo-volume-pod</span>
</span><span class='line'><span class="l-Scalar-Plain">spec</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="l-Scalar-Plain">containers</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">image</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">nginx:alpine</span>
</span><span class='line'>    <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">web-server</span>
</span><span class='line'>    <span class="l-Scalar-Plain">volumeMounts</span><span class="p-Indicator">:</span>
</span><span class='line'>    <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">html</span>
</span><span class='line'>      <span class="l-Scalar-Plain">mountPath</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">/usr/share/nginx/html</span>
</span><span class='line'>      <span class="l-Scalar-Plain">readOnly</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">true</span>
</span><span class='line'>    <span class="l-Scalar-Plain">ports</span><span class="p-Indicator">:</span>
</span><span class='line'>    <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">containerPort</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">80</span>
</span><span class='line'>      <span class="l-Scalar-Plain">protocol</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">TCP</span>
</span><span class='line'>  <span class="l-Scalar-Plain">volumes</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">html</span>
</span><span class='line'>    <span class="l-Scalar-Plain">gitRepo</span><span class="p-Indicator">:</span>
</span><span class='line'>      <span class="l-Scalar-Plain">repository</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">https://github.com/luksa/kubia-website-example.git</span>
</span><span class='line'>      <span class="l-Scalar-Plain">revision</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">master</span>
</span><span class='line'>      <span class="l-Scalar-Plain">directory</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">.</span>
</span></code></pre></td></tr></table></div></figure>


<p>默认情况下，使用gitrepo卷存在一个缺点，它不会与所引用的git repo保持同步。只有当pod重启或者创建一个新pod时，才会从Git仓库获取最新的内容。</p>

<h4>三. 使用hostPath</h4>

<p>hostPath是一种持久性存储，它指向Node文件系统中的目录，如下图所示。</p>

<p>运行在同一节点上的Pod，如果使用相同的hostPath卷，则可以彼此访问相同的文件。</p>

<p><img src="http://wldandan.github.com/images/k8s/k8s-volume-hostpath.png" /></p>

<p>使用hostPath的方式如下所示：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='yaml'><span class='line'><span class="l-Scalar-Plain">Volumes</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="l-Scalar-Plain">varlog</span><span class="p-Indicator">:</span>
</span><span class='line'>    <span class="l-Scalar-Plain">Type</span><span class="p-Indicator">:</span>       <span class="l-Scalar-Plain">HostPath (bare host directory volume)</span>
</span><span class='line'>    <span class="l-Scalar-Plain">Path</span><span class="p-Indicator">:</span>       <span class="l-Scalar-Plain">/var/log</span>
</span><span class='line'>  <span class="l-Scalar-Plain">varlibdockercontainers</span><span class="p-Indicator">:</span>
</span><span class='line'>    <span class="l-Scalar-Plain">Type</span><span class="p-Indicator">:</span>       <span class="l-Scalar-Plain">HostPath (bare host directory volume)</span>
</span><span class='line'>    <span class="l-Scalar-Plain">Path</span><span class="p-Indicator">:</span>       <span class="l-Scalar-Plain">/var/lib/docker/containers</span>
</span></code></pre></td></tr></table></div></figure>


<p>当一个pod被删除时，gitrepo和emptydir卷的内容都会被删除，但hostPath卷的内容不会。对于在某Node上创建的新pod，如果设置hostPath卷与之前pod的路径一致，那么它能也能访问到之前Pod写入的数据。</p>

<p>但是，如果您考虑使用hostPath作为数据库数据目录的话，请谨慎考虑。因为卷的内容存储在特定Node的文件系统中，当数据库pod被重新调度到另一个节点时，数据将无法被看到。</p>

<h4>四. 使用网络文件存储</h4>

<p>对于网络存储而言，可以使用GCE Persistent Disk、AWS Elastic BlockStore、Azure File、Azure Disk。</p>

<p>譬如，使用GCE Persisteng Disk的方式如下所示：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='yaml'><span class='line'><span class="l-Scalar-Plain">apiVersion</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">v1</span>
</span><span class='line'><span class="l-Scalar-Plain">kind</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">Pod</span>
</span><span class='line'><span class="l-Scalar-Plain">metadata</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">mongodb</span>
</span><span class='line'><span class="l-Scalar-Plain">spec</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="l-Scalar-Plain">volumes</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">mongodb-data           1</span>
</span><span class='line'>    <span class="l-Scalar-Plain">gcePersistentDisk</span><span class="p-Indicator">:</span>           <span class="l-Scalar-Plain">1</span>
</span><span class='line'>      <span class="l-Scalar-Plain">pdName</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">mongodb            1</span>
</span><span class='line'>      <span class="l-Scalar-Plain">fsType</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">ext4               1</span>
</span><span class='line'>  <span class="l-Scalar-Plain">containers</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">image</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">mongo</span>
</span><span class='line'>    <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">mongodb</span>
</span><span class='line'>    <span class="l-Scalar-Plain">volumeMounts</span><span class="p-Indicator">:</span>
</span><span class='line'>    <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">mongodb-data         2</span>
</span><span class='line'>      <span class="l-Scalar-Plain">mountPath</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">/data/db        2</span>
</span><span class='line'>    <span class="l-Scalar-Plain">ports</span><span class="p-Indicator">:</span>
</span><span class='line'>    <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">containerPort</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">27017</span>
</span><span class='line'>      <span class="l-Scalar-Plain">protocol</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">TCP</span>
</span></code></pre></td></tr></table></div></figure>


<blockquote><ol>
<li>使用GCE Persistent Disk.</li>
<li>使用GCE Persistent Disk，挂载到/data/db上</li>
</ol>
</blockquote>

<h4>五. 自建文件系统存储</h4>

<p>除此之外，也可以使用自建的文件系统，如
NFS、iscsi(ISCSI disk)、glusterfs(GlusterFS), rbd(RADOS Block Device), flexVolume, cinder, cephfs, flocker, fc (Fibre Channel)等</p>

<h4>六. 如何将Pod与存储机制解耦</h4>

<p>到目前为止，所有持久卷类型都要求POD的开发人员了解集群实际的网络存储基础结构。例如，要创建一个支持NFS的卷，开发人员必须知道NFS所在的实际服务器。这与Kubernetes的基本理念背道而驰，Kubernetes的目标是对应用程序及其开发人员透明化其背后的基础设施，使他们不必关心基础设施的具体情况，也不必让应用程序在各种云提供商和内部数据中心之间实现数据的移植。</p>

<p>理想情况下，在Kubernetes上部署应用程序的开发人员不必知道底层使用的是哪种存储技术，就像他们不必知道运行其pod所使用的物理服务器类型一样。当开发人员需要为他们的应用程序提供持久化的存储时，他们应该直接能够配置，就像在创建pod时配置CPU、内存和其他资源一样。</p>

<p>为了使应用程序能够在Kubernetes集群中请求存储，而不必处理基础设施的具体细节，K8S引入了两种新的资源:</p>

<ul>
<li>PersistentVolumes</li>
<li>PersistentVolumeClaims</li>
</ul>


<p>使用方式如下所示:</p>

<p><img src="http://wldandan.github.com/images/k8s/k8s-volume-pv-and-pvc.png" /></p>

<p>如图所示，开发人员不需要在pod中使用特定的存储机制，集群管理员设置底层存储，然后通过kubernetes创建PV，并且指定其大小和支持的访问模式。</p>

<p>当开发人员需要在pod中使用持久存储时，他们首先创建一个PVC清单，指定所需的大小和访问模式。然后用户将PVC清单提交给kubernetes ，kubernetes找到适当的PV并将其绑定到PV上。</p>

<p>当使用了PV和PVC后，使用GCE Persisent Disk的机制如下所示：</p>

<p><img src="http://wldandan.github.com/images/k8s/k8s-volume-pv-vs-volume.png" /></p>

<p>总而言之，在pod中使用持久性存储的最佳方法是创建pvc（必要时使用显式指定的storageclassname），并由动态PersistentVolume Provider负责创建。</p>

<h4>总结</h4>

<p>在K8S中使用存储机制总结如下：</p>

<ul>
<li>使用EmptyDir卷存储临时的非持久性数据</li>
<li>使用gitrepo卷在pod启动时获取git存储库的内容。</li>
<li>使用hostpath卷访问主机节点的文件</li>
<li>在volume中挂在外部存储，在pod启动后保持数据</li>
<li>通过使用persistentvolume和persistentvolumeclaims将pod与存储基础结构分离</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[K8s之Service]]></title>
    <link href="http://wldandan.github.com/blog/2019/03/17/k8s-concept-service/"/>
    <updated>2019-03-17T20:45:00+08:00</updated>
    <id>http://wldandan.github.com/blog/2019/03/17/k8s-concept-service</id>
    <content type="html"><![CDATA[<h3>如何访问Pod？</h3>

<p>在非k8s世界中，管理员可以通过在配置文件中指定IP地址或主机名，容许客户端访问，但在k8s中这种方式是行不通的。因为Pod 是有生命周期的，它们可以被创建或销毁。虽然通过 ReplicationController 能够动态地创建Pod，但当Pod被分配到某个节点时，K8s都会为其分配一个IP地址，而该IP地址不总是稳定可依赖的。因此，在 Kubernetes 集群中，如果一组 Pod（称为 backend）为其它 Pod （称为 frontend）提供服务，那么那些 frontend 该如何发现，并连接到这组backend的Pod呢？</p>

<!-- More -->


<h3>Service</h3>

<p>Kubernetes中的Service是一种资源的定义，它将Pod逻辑分组，并提供客户端访问。</p>

<p><img src="http://wldandan.github.com/images/k8s/k8s-service-1.png" /></p>

<p> 通过 Label Selector，一组 Pod 能够被暴露为Service，供客户端访问。</p>

<p> <img src="http://wldandan.github.com/images/k8s/k8s-service-2.png" /></p>

<p>举个例子，考虑一个图片处理 backend，它运行了3个副本。这些副本是可互换的，通过Service能够解耦frontend与backend的关联。</p>

<blockquote><p>frontend 不需要关心它们调用了哪个 backend 副本。 然而组成这一组 backend 程序的 Pod 实际上可能会发生变化，frontend 客户端不应该也没必要知道，而且也不需要跟踪这一组 backend 的状态。</p></blockquote>

<h3>创建Service</h3>

<p>一个 Service 在 Kubernetes 中是一个 REST 对象，和 Pod 类似。 像所有的 REST 对象一样， Service 定义可以基于 POST 方式，请求 apiserver 创建新的实例。 例如，假定有一组 Pod，它们对外暴露了 9376 端口，同时还被打上 &ldquo;app=MyApp&rdquo; 标签。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='yaml'><span class='line'><span class="l-Scalar-Plain">kind</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">Service</span>
</span><span class='line'><span class="l-Scalar-Plain">apiVersion</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">v1</span>
</span><span class='line'><span class="l-Scalar-Plain">metadata</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">my-service</span>
</span><span class='line'><span class="l-Scalar-Plain">spec</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="l-Scalar-Plain">selector</span><span class="p-Indicator">:</span>
</span><span class='line'>    <span class="l-Scalar-Plain">app</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">MyApp            //根据Label选择一组Pod</span>
</span><span class='line'>  <span class="l-Scalar-Plain">ports</span><span class="p-Indicator">:</span>
</span><span class='line'>    <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">protocol</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">TCP</span>
</span><span class='line'>      <span class="l-Scalar-Plain">port</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">80            //用于访问该Service的端口</span>
</span><span class='line'>      <span class="l-Scalar-Plain">targetPort</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">9376    //用于访问容器的端口</span>
</span></code></pre></td></tr></table></div></figure>


<p>接下来，我们可以使用<code>kubectl</code>访问该Service</p>

<p><img src="http://wldandan.github.com/images/k8s/k8s-service-3.png" /></p>

<h3>Service如何被外部网络的Client访问</h3>

<p>可以通过如下三种方式，容许外部网络的Client访问Service：</p>

<h4>1.将Service Type置为<code>NodePort</code></h4>

<p>对于NotePort的Service，每个节点(Node)都会打开节点本身的端口，并将该端口上接收到的流量重定向到Service。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='yaml'><span class='line'><span class="l-Scalar-Plain">apiVersion</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">v1</span>
</span><span class='line'><span class="l-Scalar-Plain">kind</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">Service</span>
</span><span class='line'><span class="l-Scalar-Plain">metadata</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">kubia-nodeport</span>
</span><span class='line'><span class="l-Scalar-Plain">spec</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="l-Scalar-Plain">type</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">NodePort             //NodePort类型</span>
</span><span class='line'>  <span class="l-Scalar-Plain">ports</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">port</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">80                 //Service内部访问的地址</span>
</span><span class='line'>    <span class="l-Scalar-Plain">targetPort</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">8080         //转发给目标Pod的地址</span>
</span><span class='line'>    <span class="l-Scalar-Plain">nodePort</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">30123          //可访问的nodeport端口</span>
</span><span class='line'>  <span class="l-Scalar-Plain">selector</span><span class="p-Indicator">:</span>
</span><span class='line'>    <span class="l-Scalar-Plain">app</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">kubia</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>使用NodePort的Service如下图所示：
<img src="http://wldandan.github.com/images/k8s/k8s-service-4.png" /></p>

<h4>2.将Service Type设置为<code>LoadBalancer</code></h4>

<p>通过设置<code>LoadBalancer</code>，Service可以通过一个专用的负载均衡器来访问（这个均衡器是运行kubernetes的基础设施提供的）。负载均衡器将流量重定向到所有节点上的节点端口。客户机通过负载均衡器的IP连接到服务。</p>

<p>如果kubernetes在不支持LoadBalancer服务的环境中运行，则不会提供负载均衡器，但该服务的行为仍将类似于NodePort服务。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='yaml'><span class='line'><span class="l-Scalar-Plain">apiVersion</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">v1</span>
</span><span class='line'><span class="l-Scalar-Plain">kind</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">Service</span>
</span><span class='line'><span class="l-Scalar-Plain">metadata</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">kubia-loadbalancer</span>
</span><span class='line'><span class="l-Scalar-Plain">spec</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="l-Scalar-Plain">type</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">LoadBalancer</span>
</span><span class='line'>  <span class="l-Scalar-Plain">ports</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">port</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">80</span>
</span><span class='line'>    <span class="l-Scalar-Plain">targetPort</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">8080</span>
</span><span class='line'>  <span class="l-Scalar-Plain">selector</span><span class="p-Indicator">:</span>
</span><span class='line'>    <span class="l-Scalar-Plain">app</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">kubia</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>使用如上配置文件创建Service之后，会调用云基础设施，创建负载均衡器并将其IP地址写入Service对象。一旦结束，IP地址将作为Service的外部IP地址列出：</p>

<p>如下图所示：
<img src="http://wldandan.github.com/images/k8s/k8s-service-5.png" /></p>

<h4>3.使用<code>Ingress</code>资源</h4>

<p>这是一种完全不同的机制，通过一个IP地址公开多个服务，它在HTTP（网络层7）上运行，因此可以提供比第4层服务更多的功能。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='yaml'><span class='line'><span class="l-Scalar-Plain">apiVersion</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">extensions/v1beta1</span>
</span><span class='line'><span class="l-Scalar-Plain">kind</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">Ingress</span>
</span><span class='line'><span class="l-Scalar-Plain">metadata</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">kubia</span>
</span><span class='line'><span class="l-Scalar-Plain">spec</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="l-Scalar-Plain">rules</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">host</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">kubia.example.com               //使用domain name访问service</span>
</span><span class='line'>    <span class="l-Scalar-Plain">http</span><span class="p-Indicator">:</span>
</span><span class='line'>      <span class="l-Scalar-Plain">paths</span><span class="p-Indicator">:</span>
</span><span class='line'>      <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">path</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">/                           //访问的路径</span>
</span><span class='line'>        <span class="l-Scalar-Plain">backend</span><span class="p-Indicator">:</span>
</span><span class='line'>          <span class="l-Scalar-Plain">serviceName</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">kubia-nodeport</span>
</span><span class='line'>          <span class="l-Scalar-Plain">servicePort</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">80</span>
</span></code></pre></td></tr></table></div></figure>


<p>通过Ingress访问Service的流程如下：</p>

<p><img src="http://wldandan.github.com/images/k8s/k8s-service-7.png" /></p>

<p>另外，可以通过Ingress访问多个服务：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='yaml'><span class='line'><span class="nn">...</span>
</span><span class='line'>  <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">host</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">kubia.example.com</span>
</span><span class='line'>    <span class="l-Scalar-Plain">http</span><span class="p-Indicator">:</span>
</span><span class='line'>      <span class="l-Scalar-Plain">paths</span><span class="p-Indicator">:</span>
</span><span class='line'>      <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">path</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">/kubia</span>
</span><span class='line'>        <span class="l-Scalar-Plain">backend</span><span class="p-Indicator">:</span>
</span><span class='line'>          <span class="l-Scalar-Plain">serviceName</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">kubia</span>
</span><span class='line'>          <span class="l-Scalar-Plain">servicePort</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">80</span>
</span><span class='line'>      <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">path</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">/foo</span>
</span><span class='line'>        <span class="l-Scalar-Plain">backend</span><span class="p-Indicator">:</span>
</span><span class='line'>          <span class="l-Scalar-Plain">serviceName</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">bar</span>
</span><span class='line'>          <span class="l-Scalar-Plain">servicePort</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">80</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="http://wldandan.github.com/images/k8s/k8s-service-6.png" /></p>

<h3>Service的诊断</h3>

<p>Service是Kubernetes的关键概念，也是令许多开发人员沮丧的根源。我见过许多开发人员耗费大量时间，来弄清楚为什么无法通过Servic IP或fqdn访问到自己的pods。
出于这个原因，简单介绍一下如何对服务进行故障排除。当无法通过Service访问您的pod时，可以从以下列表开始：</p>

<ul>
<li><p>首先，确保从集群内而不是从外部连接到Service的集群IP。</p></li>
<li><p>不要费心Ping Service的IP来确定服务是否可以访问（记住，服务的集群IP是一个虚拟IP，Ping它永远不会工作）。</p></li>
<li><p>如果您已经定义了一个readiness probe，请确保它是成功的；否则Pod将不属于服务的一部分。</p></li>
<li><p>要确认Pod是服务的一部分，请使用kubectl get endpoints检查相应的endpoint对象。</p></li>
<li><p>如果您试图通过其fqdname或其一部分（例如，myservice.mynamespace.svc.cluster.local或myservice.mynamespace）访问服务，但该服务不起作用，请查看是否可以使用其群集IP而不是fqdname访问该服务。</p></li>
<li><p>检查您是否连接到服务公开的端口，而不是目标端口。</p></li>
<li><p>尝试直接连接到pod ip以确认pod是否接受正确端口上的连接。</p></li>
<li><p>如果你甚至不能通过pod的IP访问你的应用，确保你的应用是否绑定到locahost。</p></li>
</ul>


<h3>总结</h3>

<p>Service是K8s中重要的概念，你应该至少明白Service的这些内容：</p>

<ul>
<li><p>通过Lable selector，将一组Pod设置为Service，并为Service配置静态的IP和端口</p></li>
<li><p>Service可以从Cluster内部访问，也可以通过设置为NodePort或者LoadBalancer的方式从外部访问</p></li>
<li><p>Pod可以通过环境变量获取Service的IP和Port，进行访问</p></li>
<li><p>可以将对Pod的关联关系，设置到Endpoint资源中，而简化label selector的方式</p></li>
<li><p>通过设置ServiceType为<code>ExternalName</code>，可以访问外部的Service</p></li>
<li><p>通过Ingress可以设置多个Service被外部访问</p></li>
<li><p>使用pod的readiness probe可以决定pod是否被作为service的一部分</p></li>
<li><p>通过headless Service，可以使用DNS获取Pod的IP</p></li>
</ul>


<h3>参考</h3>

<p>《Kubernetes in action》
《Kubernetes handbook》</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[K8s之控制器]]></title>
    <link href="http://wldandan.github.com/blog/2019/03/16/k8s-concept-controller/"/>
    <updated>2019-03-16T20:45:00+08:00</updated>
    <id>http://wldandan.github.com/blog/2019/03/16/k8s-concept-controller</id>
    <content type="html"><![CDATA[<p>Kubernetes中内建了很多controller（控制器），这些相当于一个状态机，用来控制Pod的具体状态和行为。</p>

<!-- More -->


<p>这里已经讲的很详细了，请<a href="https://jimmysong.io/kubernetes-handbook/concepts/deployment.html">参考</a></p>

<h4>Deployment 是什么？</h4>

<p>Deployment为Pod和Replica Set（下一代Replication Controller）提供声明式更新。</p>

<p>您只需要在 Deployment 中描述期望的目标状态，Deployment controller 会帮您将 Pod 和ReplicaSet 的实际状态改变到您的目标状态。</p>

<p>典型的用例如下：</p>

<ul>
<li>使用Deployment来创建ReplicaSet。ReplicaSet在后台创建pod。检查启动状态，看它是成功还是失败。</li>
<li>然后，通过更新Deployment的PodTemplateSpec字段来声明Pod的新状态。这会创建一个新的ReplicaSet，Deployment会按照控制的速率将pod从旧的ReplicaSet移动到新的ReplicaSet中。</li>
<li>如果当前状态不稳定，回滚到之前的Deployment revision。每次回滚都会更新Deployment的revision。</li>
<li>扩容Deployment以满足更高的负载。</li>
<li>暂停Deployment来应用PodTemplateSpec的多个修复，然后恢复上线。</li>
<li>根据Deployment 的状态判断上线是否hang住了。</li>
<li>清除旧的不必要的 ReplicaSet。</li>
</ul>


<h4>创建 Deployment</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ kubectl create -f https://kubernetes.io/docs/user-guide/nginx-deployment.yaml --record
</span><span class='line'>deployment "nginx-deployment" created</span></code></pre></td></tr></table></div></figure>


<h4>更新Deployment</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ kubectl set image deployment/nginx-deployment nginx=nginx:1.9.1
</span><span class='line'>deployment "nginx-deployment" image updated</span></code></pre></td></tr></table></div></figure>


<h4>检查 Deployment 升级的历史记录</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ kubectl rollout history deployment/nginx-deployment
</span><span class='line'>deployments "nginx-deployment":
</span><span class='line'>REVISION    CHANGE-CAUSE
</span><span class='line'>1           kubectl create -f https://kubernetes.io/docs/user-guide/nginx-deployment.yaml--record
</span><span class='line'>2           kubectl set image deployment/nginx-deployment nginx=nginx:1.9.1
</span><span class='line'>3           kubectl set image deployment/nginx-deployment nginx=nginx:1.91</span></code></pre></td></tr></table></div></figure>


<h4>回退到历史版本</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ kubectl rollout undo deployment/nginx-deployment --to-revision=2
</span><span class='line'>deployment "nginx-deployment" rolled back</span></code></pre></td></tr></table></div></figure>


<h4>Deployment 扩容</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ kubectl scale deployment nginx-deployment --replicas 10
</span><span class='line'>deployment "nginx-deployment" scaled</span></code></pre></td></tr></table></div></figure>


<h4>Deployment 状态</h4>

<p>Deployment 在生命周期中有多种状态。在创建一个新的 ReplicaSet 的时候它可以是 <code>progressing</code> 状态， <code>complete</code> 状态，或者 <code>fail to progress</code> 状态。</p>

<h3>编写 Deployment Spec</h3>

<p>在所有的 Kubernetes 配置中，Deployment 也需要<code>apiVersion</code>，<code>kind</code>和<code>metadata</code>这些配置项。配置文件的通用使用说明查看 <a href="https://kubernetes.io/docs/tasks/run-application/run-stateless-application-deployment/">部署应用</a>，配置容器，和 <a href="https://kubernetes.io/docs/tutorials/object-management-kubectl/object-management/">使用 kubectl 管理资源 </a> 文档。</p>

<h4>Pod Template</h4>

<p> <code>.spec.template</code> 是 <code>.spec</code>中唯一要求的字段。</p>

<p><code>.spec.template</code> 是 <a href="https://kubernetes.io/docs/user-guide/replication-controller/#pod-template">pod template</a>. 它跟 <a href="https://kubernetes.io/docs/user-guide/pods">Pod</a>有一模一样的schema，除了它是嵌套的并且不需要<code>apiVersion</code> 和 <code>kind</code>字段。</p>

<p>另外为了划分Pod的范围，Deployment中的pod template必须指定适当的label（不要跟其他controller重复了，参考<a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment#selector">selector</a>）和适当的重启策略。</p>

<p><a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle"><code>.spec.template.spec.restartPolicy</code></a> 可以设置为 <code>Always</code> , 如果不指定的话这就是默认配置。</p>

<h4>Replicas</h4>

<p><code>.spec.replicas</code> 是可以选字段，指定期望的pod数量，默认是1。</p>

<h4>Selector</h4>

<p><code>.spec.selector</code>是可选字段，用来指定 <a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/labels">label selector</a> ，圈定Deployment管理的pod范围。</p>

<p>如果被指定， <code>.spec.selector</code> 必须匹配 <code>.spec.template.metadata.labels</code>，否则它将被API拒绝。如果 <code>.spec.selector</code> 没有被指定， <code>.spec.selector.matchLabels</code> 默认是 <code>.spec.template.metadata.labels</code>。</p>

<p>在Pod的template跟<code>.spec.template</code>不同或者数量超过了<code>.spec.replicas</code>规定的数量的情况下，Deployment会杀掉label跟selector不同的Pod。</p>

<p><strong>注意：</strong> 您不应该再创建其他label跟这个selector匹配的pod，或者通过其他Deployment，或者通过其他Controller，例如ReplicaSet和ReplicationController。否则该Deployment会被把它们当成都是自己创建的。Kubernetes不会阻止您这么做。</p>

<p>如果您有多个controller使用了重复的selector，controller们就会互相打架并导致不正确的行为。</p>

<h4>策略</h4>

<p><code>.spec.strategy</code> 指定新的Pod替换旧的Pod的策略。 <code>.spec.strategy.type</code> 可以是"Recreate"或者是 &ldquo;RollingUpdate"。"RollingUpdate"是默认值。</p>

<h5>Recreate Deployment</h5>

<p><code>.spec.strategy.type==Recreate</code>时，在创建出新的Pod之前会先杀掉所有已存在的Pod。</p>

<h5>Rolling Update Deployment</h5>

<p><code>.spec.strategy.type==RollingUpdate</code>时，Deployment使用<a href="https://kubernetes.io/docs/tasks/run-application/rolling-update-replication-controller">rolling update</a> 的方式更新Pod 。您可以指定<code>maxUnavailable</code> 和 <code>maxSurge</code> 来控制 rolling update 进程。</p>

<h5>Max Unavailable</h5>

<p><code>.spec.strategy.rollingUpdate.maxUnavailable</code> 是可选配置项，用来指定在升级过程中不可用Pod的最大数量。该值可以是一个绝对值（例如5），也可以是期望Pod数量的百分比（例如10%）。通过计算百分比的绝对值向下取整。如果<code>.spec.strategy.rollingUpdate.maxSurge</code> 为0时，这个值不可以为0。默认值是1。</p>

<p>例如，该值设置成30%，启动rolling update后旧的ReplicatSet将会立即缩容到期望的Pod数量的70%。新的Pod ready后，随着新的ReplicaSet的扩容，旧的ReplicaSet会进一步缩容，确保在升级的所有时刻可以用的Pod数量至少是期望Pod数量的70%。</p>

<h5>Max Surge</h5>

<p><code>.spec.strategy.rollingUpdate.maxSurge</code> 是可选配置项，用来指定可以超过期望的Pod数量的最大个数。该值可以是一个绝对值（例如5）或者是期望的Pod数量的百分比（例如10%）。当<code>MaxUnavailable</code>为0时该值不可以为0。通过百分比计算的绝对值向上取整。默认值是1。</p>

<p>例如，该值设置成30%，启动rolling update后新的ReplicatSet将会立即扩容，新老Pod的总数不能超过期望的Pod数量的130%。旧的Pod被杀掉后，新的ReplicaSet将继续扩容，旧的ReplicaSet会进一步缩容，确保在升级的所有时刻所有的Pod数量和不会超过期望Pod数量的130%。</p>

<h4>Progress Deadline Seconds</h4>

<p><code>.spec.progressDeadlineSeconds</code> 是可选配置项，用来指定在系统报告Deployment的<a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment#failed-deployment">failed progressing</a> ——表现为resource的状态中<code>type=Progressing</code>、<code>Status=False</code>、 <code>Reason=ProgressDeadlineExceeded</code>前可以等待的Deployment进行的秒数。Deployment controller会继续重试该Deployment。未来，在实现了自动回滚后， deployment controller在观察到这种状态时就会自动回滚。</p>

<p>如果设置该参数，该值必须大于 <code>.spec.minReadySeconds</code>。</p>

<h4>Min Ready Seconds</h4>

<p><code>.spec.minReadySeconds</code>是一个可选配置项，用来指定没有任何容器crash的Pod并被认为是可用状态的最小秒数。默认是0（Pod在ready后就会被认为是可用状态）。进一步了解什么什么后Pod会被认为是ready状态，参阅 <a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes">Container Probes</a>。</p>

<h4>Rollback To</h4>

<p><code>.spec.rollbackTo</code> 是一个可以选配置项，用来配置Deployment回退的配置。设置该参数将触发回退操作，每次回退完成后，该值就会被清除。</p>

<h4>Revision</h4>

<p><code>.spec.rollbackTo.revision</code>是一个可选配置项，用来指定回退到的revision。默认是0，意味着回退到上一个revision。</p>

<h4>Revision History Limit</h4>

<p>Deployment revision history存储在它控制的ReplicaSets中。</p>

<p><code>.spec.revisionHistoryLimit</code> 是一个可选配置项，用来指定可以保留的旧的ReplicaSet数量。该理想值取决于心Deployment的频率和稳定性。如果该值没有设置的话，默认所有旧的Replicaset或会被保留，将资源存储在etcd中，是用<code>kubectl get rs</code>查看输出。每个Deployment的该配置都保存在ReplicaSet中，然而，一旦您删除的旧的RepelicaSet，您的Deployment就无法再回退到那个revison了。</p>

<p>如果您将该值设置为0，所有具有0个replica的ReplicaSet都会被删除。在这种情况下，新的Deployment rollout无法撤销，因为revision history都被清理掉了。</p>

<h4>Paused</h4>

<p><code>.spec.paused</code>是可以可选配置项，boolean值。用来指定暂停和恢复Deployment。Paused和没有paused的Deployment之间的唯一区别就是，所有对paused deployment中的PodTemplateSpec的修改都不会触发新的rollout。Deployment被创建之后默认是非paused。</p>

<h3>资源参考</h3>

<p><a href="https://jimmysong.io/kubernetes-handbook/concepts/deployment.html">k8s handbook - Deployment</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[K8s之Pod]]></title>
    <link href="http://wldandan.github.com/blog/2019/03/16/k8s-concept-pod/"/>
    <updated>2019-03-16T19:45:00+08:00</updated>
    <id>http://wldandan.github.com/blog/2019/03/16/k8s-concept-pod</id>
    <content type="html"><![CDATA[<p>Pod是kubernetes中你可以创建和部署的最小也是最简的单位。Pod代表着集群中运行的进程。Pod中封装着应用的容器（1或多个容器）、存储、独立的网络IP，并管理着容器运行的策略选项。</p>

<!-- More -->


<h3>Pod概览</h3>

<p>Pod是一个服务的多个进程的聚合单位，pod通过提供一个更高级别的抽象的方式，极大简化了应用部署管理。
Pod作为一个独立的部署单位，支持横向扩展和复制、协同调度、命运共同体（例如被同时终结），协同复制，资源共享，依赖管理等，Pod会自动的为容器处理这些问题。</p>

<h4>什么是Pod</h4>

<p>Pod是kubernetes中你可以创建和部署的最小也是最简的单位。Pod代表着集群中运行的进程。</p>

<p>Pod中封装着应用的容器（1或多个容器）、存储、独立的网络IP，并管理着容器运行的策略选项。</p>

<p>在Kubrenetes集群中Pod有如下两种使用方式：</p>

<ul>
<li><p>一个Pod中运行一个容器。“每个Pod中一个容器”的模式是最常见的用法；在这种使用方式中，你可以把Pod想象成是单容器的封装，kuberentes管理的是Pod而不是容器。</p></li>
<li><p>在一个Pod中同时运行多个容器。一个Pod中也可以同时封装几个紧密耦合、互相协作的容器，它们之间共享资源。这些在同一个Pod中的容器互相协作，成为一个service单位——如一个容器共享文件，另一个容器更新文件。Pod将这些容器的存储资源作为一个实体来管理。</p></li>
</ul>


<h4>Pod的生命周期</h4>

<p>Pod 的 status 字段是一个 PodStatus 对象，PodStatus中有一个 phase 字段。</p>

<p>下面是 phase 可能的值：</p>

<ul>
<li>挂起（Pending）：Pod 已被 Kubernetes
系统接受，但有一个或者多个容器镜像尚未创建。等待时间包括调度 Pod的时间和通过网络下载镜像的时间，这可能需要花点时间。</li>
<li>运行中（Running）：该 Pod 已经绑定到了一个节点上，Pod 中所有的容器都已被创建。至少有一个容器正在运行，或者正处于启动或重启状态。</li>
<li>成功（Succeeded）：Pod 中的所有容器都被成功终止，并且不会再重启。</li>
<li>失败（Failed）：Pod 中的所有容器都已终止了，并且至少有一个容器是因为失败终止。也就是说，容器以非0状态退出或者被系统终止。</li>
<li>未知（Unknown）：因为某些原因无法取得 Pod 的状态，通常是因为与 Pod 所在主机通信失败。</li>
</ul>


<p>下图是Pod的生命周期示意图，从图中可以看到Pod状态的变化。</p>

<p><img src="http://wldandan.github.com/images/k8s/kubernetes-pod-life-cycle.jpg" /></p>

<h4>Pod如何管理多个容器</h4>

<p>Pod中可以同时运行多个容器（独立进程运行）并协同工作。同一个Pod中的容器会自动的分配到同一个node 上运行，同时，同一个Pod中的容器共享存储、网络和依赖，它们总是被同时调度。</p>

<ul>
<li><p>网络</p>

<blockquote><p>每个Pod都会被分配唯一的一个IP地址。Pod中的所有容器共享网络空间，包括IP地址和端口。Pod内部的容器可以使用localhost互相通信。Pod中的容器与外界通信时，必须分配共享网络资源（例如使用宿主机的端口映射）。</p></blockquote></li>
<li><p>存储</p>

<blockquote><p>可以为一个Pod指定多个共享的Volume。Pod中的所有容器都可以访问共享的volume。Volume也可以用来持久化Pod中的存储资源，以防容器重启后文件丢失。</p></blockquote></li>
</ul>


<h3>Pod的管理</h3>

<h4>Pod间发现</h4>

<p>Pod中应用容器共享网络空间（IP地址和端口），因此可以通过localhost互相发现。
Pod中应用容器的hostname被设置成Pod的名字。
Pod中应用容器可以共享volume。volume能够保证pod重启时使用的数据不丢失。</p>

<h4>Pod的使用</h4>

<p>Pod也可以用于垂直应用（例如LAMP），这样使用的动机是为了支持共同调度和协调应用程序，例如：
* 内容管理系统、文件和数据加载器、本地换群管理器等。
* 日志和检查点备份、压缩、旋转、快照等。
* 数据变更观察者、日志和监控适配器、活动发布者等。
* 代理、桥接和适配器等。
* 控制器、管理器、配置器、更新器等。</p>

<h4>Pod的持久性</h4>

<p>Pod不是作为持久化设计的。在调度失败、节点故障、缺少资源或者节点维护的状态下都会失败。</p>

<p>通常，用户不需要手动直接创建Pod，而是应该使用controller（例如Deployments），即使是在创建单个Pod的情况下。Controller可以提供集群级别的自愈功能、复制和升级管理。</p>

<h3>Pod高级特性</h3>

<h4>Pod Preset</h4>

<p>Kubernetes提供了一个准入控制器（PodPreset），当其启用时，Pod Preset 会将应用创建请求传入到该控制器上。因此，<code>Pod Preset</code>是用来在 Pod 被创建的时候向其中注入额外的运行时需求的 API 资源。</p>

<p>您可以使用<code>label selector</code> 来指定为哪些 Pod 应用 Pod Preset。</p>

<h4>Pod和Controller</h4>

<p>Controller可以创建和管理多个Pod，提供副本管理、滚动升级和集群级别的自愈能力。例如，如果一个Node故障，Controller就能自动将该节点上的Pod调度到其他健康的Node上。</p>

<p>包含一个或者多个Pod的Controller示例：</p>

<ul>
<li>Deployment</li>
<li>StatefulSet</li>
<li>DaemonSet</li>
</ul>


<p>通常，Controller会用你提供的Pod Template来创建相应的Pod。</p>

<h4>Init容器</h4>

<p>Init是一种专用的容器，在应用程序容器启动之前运行，包含应用镜像中工具或环境的安装脚本。</p>

<p>Pod 能够有一个或多个先于应用容器启动的 Init 容器。</p>

<p>Init 容器与普通的容器非常像，除了如下两点：
* Init 容器总是运行到成功完成为止。
* 每个 Init 容器都必须在下一个 Init 容器启动之前成功完成。</p>

<p>如果 Pod 的 Init 容器失败，Kubernetes 会不断地重启该 Pod，直到 Init容器成功为止。然而，如果 Pod 对应的 restartPolicy 为 Never，它不会重新启动。</p>

<p>因为 Init 容器具有与应用程序容器分离的单独镜像，所以它们的启动相关代码具有如下优势：</p>

<ul>
<li><p>它们可以包含并运行实用工具，它们可以包含使用工具和定制化代码来安装。例如，创建镜像没必要FROM 另一个镜像，只需要在安装过程中使用类似 sed、 awk、 python 或 dig 这样的工具。</p></li>
<li><p>应用程序镜像可以分离出创建和部署的角色，而没有必要联合它们构建一个单独的镜像。</p></li>
<li><p>Init 容器使用 Linux Namespace，所以相对应用程序容器来说具有不同的文件系统视图。因此，它们能够具有访问 Secret 的权限，而应用程序容器则不能。</p></li>
<li><p>它们必须在应用程序容器启动之前运行完成，所以 Init 容器能够提供一种简单的阻塞或延迟应用容器的启动的方法，直到满足了一组先决条件。</p></li>
</ul>


<h4>Pod 安全策略</h4>

<p>Pod 安全策略 是集群级别的资源，它能够控制 Pod 运行的行为，以及它具有访问什么资源的能力。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[K8s之网络]]></title>
    <link href="http://wldandan.github.com/blog/2019/03/15/k8s-concept-network/"/>
    <updated>2019-03-15T23:45:00+08:00</updated>
    <id>http://wldandan.github.com/blog/2019/03/15/k8s-concept-network</id>
    <content type="html"><![CDATA[<p>K8s的网络介绍</p>

<!-- More -->


<h3>K8s集群IP</h3>

<p>Kubernetes集群内部存在三类IP，分别是：</p>

<ul>
<li>Node IP：宿主机的IP地址</li>
<li>Pod IP：使用网络插件创建的IP（如flannel），使跨主机的Pod可以互通</li>
<li>Cluster IP：虚拟IP，通过iptables规则访问服务</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[K8s之集群]]></title>
    <link href="http://wldandan.github.com/blog/2019/03/15/k8s-concept-cluster/"/>
    <updated>2019-03-15T21:45:00+08:00</updated>
    <id>http://wldandan.github.com/blog/2019/03/15/k8s-concept-cluster</id>
    <content type="html"><![CDATA[<p>为了管理异构和不同配置的主机，为了便于Pod的运维管理，Kubernetes中提供了很多集群管理的配置和管理功能，通过namespace划分的空间，通过为node节点创建label和taint用于pod的调度等。</p>

<!-- More -->


<h3>Node</h3>

<p>Node是kubernetes集群的工作节点，可以是物理机也可以是虚拟机。</p>

<h5>Node的状态:</h5>

<ul>
<li><p>Address</p>

<ul>
<li>HostName：可以被kubelet中的&ndash;hostname-override参数替代。</li>
<li>ExternalIP：可以被集群外部路由到的IP地址。</li>
<li>InternalIP：集群内部使用的IP，集群外部无法访问。</li>
</ul>
</li>
<li><p>Condition</p>

<ul>
<li>OutOfDisk：磁盘空间不足时为True</li>
<li>Ready：Node controller 40秒内没有收到node的状态报告为Unknown，健康为True，否则为False。</li>
<li>MemoryPressure：当node没有内存压力时为True，否则为False。</li>
<li>DiskPressure：当node没有磁盘压力时为True，否则为False。</li>
</ul>
</li>
<li><p>Capacity</p>

<ul>
<li>CPU</li>
<li>内存</li>
<li>可运行的最大Pod个数</li>
</ul>
</li>
<li><p>Info：节点的一些版本信息，如OS、kubernetes、docker等</p></li>
</ul>


<h3>Namespace</h3>

<p>在一个Kubernetes集群中可以使用namespace创建多个“虚拟集群”，这些集群之间可以完全隔离。如当项目和人员众多的时候可以考虑根据项目属性，例如生产、测试、开发划分不同的namespace。</p>

<p>另外，也可以让一个namespace中的service访问到其他的namespace中的服务。</p>

<h3>Label &amp; Annonication</h3>

<p>Label是附在对象上（例如Pod）的键值对。可以在创建对象的时候指定，也可以在对象创建后随时指定。Labels的值对系统本身并没有什么含义，只是对用户有意义。通过label selector，客户端／用户可以指定一个object集合，通过label selector对object的集合进行操作。</p>

<p>Annotation,可以将Kubernetes资源对象关联到任意的非标识性元数据。使用客户端（如工具和库）可以检索到这些元数据。</p>

<p>Label和Annotation都可以将元数据关联到Kubernetes资源对象。Label主要用于选择对象，可以挑选出满足特定条件的对象。相比之下，annotation 不能用于标识及选择对象。annotation中的元数据可多可少，可以是结构化的或非结构化的，也可以包含label中不允许出现的字符。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[K8s核心概念]]></title>
    <link href="http://wldandan.github.com/blog/2019/03/14/k8s-concepts/"/>
    <updated>2019-03-14T23:45:00+08:00</updated>
    <id>http://wldandan.github.com/blog/2019/03/14/k8s-concepts</id>
    <content type="html"><![CDATA[<p>Paxos发明人Leslie Lamport提出，分布式系统有两类特性：</p>

<ul>
<li><p>安全性(Safety)</p>

<blockquote><p>保证系统的稳定，保证系统不会崩溃，不会出现业务错误，不会做坏事，是严格约束的。</p></blockquote></li>
<li><p>活性(Liveness)</p>

<blockquote><p>使得系统可以提供功能，提高性能，增加易用性，让系统可以在用户“看到的时间内”做些好事，是尽力而为的。</p></blockquote></li>
</ul>


<p>从Kubernetes的系统架构和设计来看，存在两个最核心的设计理念，符合Lamport的理论：</p>

<ul>
<li><p>容错性</p>

<blockquote><p>容错性实际是保证Kubernetes系统稳定性和安全性的基础</p></blockquote></li>
<li><p>易扩展性</p>

<blockquote><p>易扩展性是保证对变更友好，可以快速迭代增加新功能的基础</p></blockquote></li>
</ul>


<!-- More -->


<p>在K8S中，支撑核心设计理念的背后，存在着诸多领域对象，本文主要梳理了K8S系统中存在的主要概念。</p>

<table>
<thead>
<tr>
<th>类别</th>
<th>名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>资源对象</td>
<td>Pod、ReplicaSet、ReplicationController、Deployment、StatefulSet、DaemonSet、Job、CronJob、HorizontalPodAutoscaling、Node、Namespace、Service、Ingress、Label、CustomResourceDefinition</td>
</tr>
<tr>
<td>存储对象</td>
<td>Volume、PersistentVolume、Secret、ConfigMap</td>
</tr>
<tr>
<td>策略对象</td>
<td>SecurityContext、ResourceQuota、LimitRange</td>
</tr>
<tr>
<td>身份对象</td>
<td>ServiceAccount、Role、ClusterRole</td>
</tr>
</tbody>
</table>


<h4>1.核心概念</h4>

<h5>Pod</h5>

<blockquote><p>Pod是在Kubernetes集群中运行部署应用或服务的最小单元，它是可以支持多容器的。Pod的设计理念是支持多个容器在一个Pod中共享网络地址和文件系统，可以通过进程间通信和文件共享这种简单高效的方式组合完成服务。
目前Kubernetes中的业务主要可以分为长期伺服型（long-running）、批处理型（batch）、后台支撑型（node-daemon）和有状态应用型（stateful application）；分别对应的控制器为Deployment、Job、DaemonSet和StatefulSet，</p></blockquote>

<h5>部署（Deployment）</h5>

<blockquote><p>部署表示用户对Kubernetes集群的一次更新操作。部署是一个比RS应用模式更广的API对象，可以是创建一个新的服务，更新一个新的服务，也可以是滚动升级一个服务。滚动升级一个服务，实际是创建一个新的RS，然后逐渐将新RS中副本数增加到理想状态。以Kubernetes的发展方向，未来对所有长期伺服型的的业务的管理，都会通过Deployment来管理。</p></blockquote>

<h5>服务（Service）</h5>

<blockquote><p>RC、RS和Deployment只是保证了支撑服务的微服务Pod的数量，但是没有解决如何访问这些服务的问题。一个Pod只是一个运行服务的实例，随时可能在不同节点上停止或者启动，因此不能确定其IP和端口号提供服务。那谁来稳定地提供<code>服务发现</code>和<code>负载均衡</code>的能力呢？在K8集群中，客户端要访问的服务就是Service对象。
每个Service会对应一个集群内部有效的虚拟IP，集群内部通过虚拟IP访问服务。
在K8集群中微服务的负载均衡是由Kube-proxy实现的。Kube-proxy是Kubernetes集群内部的负载均衡器。它是一个分布式代理服务器，在Kubernetes的每个节点上都有一个。这一设计体现了它的伸缩性优势，需要访问服务的节点越多，提供负载均衡能力的Kube-proxy就越多，高可用节点也随之增多。</p></blockquote>

<h5>节点（Node）</h5>

<blockquote><p>Kubernetes集群中的计算能力由Node提供，最初Node称为服务节点Minion，后来改名为Node。Kubernetes集群中的Node也就等同于Mesos集群中的Slave节点，是所有Pod运行所在的工作主机，可以是物理机也可以是虚拟机。不论是物理机还是虚拟机，工作主机的统一特征是上面要运行kubelet管理节点上运行的容器。</p></blockquote>

<h5>命名空间（Namespace）</h5>

<blockquote><p>命名空间为Kubernetes集群提供虚拟的隔离作用，Kubernetes集群初始有两个命名空间，分别是默认命名空间default和系统命名空间kube-system，除此以外，管理员可以可以创建新的命名空间满足需要。</p></blockquote>

<h5>任务(Job)</h5>

<blockquote><p>Job是Kubernetes用来控制批处理型任务的API对象。批处理业务与长期伺服业务的主要区别是批处理业务的运行有头有尾，而长期伺服业务在用户不停止的情况下永远运行。Job管理的Pod把任务成功完成就自动退出了。成功完成的标志根据不同的spec.completions策略而不同：单Pod型任务有一个Pod成功就标志完成；多任务的成功保证有N个任务全部执行成功；工作队列型任务根据应用确认的全局成功而标志成功。</p></blockquote>

<h4>2.管理与支撑概念</h4>

<h5>API</h5>

<blockquote><p>API对象是Kubernetes集群中的管理操作单元。Kubernetes集群系统每支持一项新功能，引入一项新概念，一定会新引入对应的API对象，支持对该功能的管理操作。例如副本集Replica Set对应的API对象是RS。
每个API对象都有3大类属性：元数据metadata、规范spec和状态status</p></blockquote>

<h5>副本控制器（Replication Controller，RC）</h5>

<blockquote><p>RC是Kubernetes集群中最早的保证Pod高可用的API对象。通过监控运行中的Pod来保证集群中运行指定数目的Pod副本。</p></blockquote>

<h5>副本集（Replica Set，RS)</h5>

<blockquote><p>RS是新一代RC，提供同样的高可用能力，区别主要在于RS后来居上，能支持更多种类的匹配模式。副本集对象一般不单独使用，而是作为Deployment的理想状态参数使用。</p></blockquote>

<h5>后台支撑服务集（DaemonSet）</h5>

<blockquote><p>长期伺服型和批处理型服务的核心在业务应用，可能有些节点运行多个同类业务的Pod，有些节点上又没有这类Pod运行；而后台支撑型服务的核心关注点在Kubernetes集群中的节点（物理机或虚拟机），要保证每个节点上都有一个此类Pod运行。节点可能是所有集群节点也可能是通过nodeSelector选定的一些特定节点。典型的后台支撑型服务包括，存储，日志和监控等在每个节点上支持Kubernetes集群运行的服务。</p></blockquote>

<h5>有状态服务集（StatefulSet）</h5>

<blockquote><p>在云原生应用的体系里，有下面两组近义词；第一组是无状态（stateless）、牲畜（cattle）、无名（nameless）、可丢弃（disposable）；第二组是有状态（stateful）、宠物（pet）、有名（having name）、不可丢弃（non-disposable）
RC和RS主要是控制提供无状态服务的，其所控制的Pod的名字是随机设置的，一个Pod出故障了就被丢弃掉，在另一个地方重启一个新的Pod，名字变了和启动在哪儿都不重要，重要的只是Pod总数；而StatefulSet是用来控制有状态服务，StatefulSet中的每个Pod的名字都是事先确定的，不能更改。
对于RC和RS中的Pod，一般不挂载存储或者挂载共享存储，保存的是所有Pod共享的状态，Pod像牲畜一样没有分别（这似乎也确实意味着失去了人性特征）；对于StatefulSet中的Pod，每个Pod挂载自己独立的存储，如果一个Pod出现故障，从其他节点启动一个同样名字的Pod，要挂载上原来Pod的存储继续以它的状态提供服务。
适合于StatefulSet的业务包括数据库服务MySQL和PostgreSQL，集群化管理服务ZooKeeper、etcd等有状态服务。使用StatefulSet，Pod仍然可以通过漂移到不同节点提供高可用，而存储也可以通过外挂的存储来提供高可靠性，StatefulSet做的只是将确定的Pod与确定的存储关联起来保证状态的连续性。</p></blockquote>

<h5>集群联邦（Federation）</h5>

<blockquote><p>在云计算环境中，服务的作用距离范围从近到远一般可以有：同主机（Host，Node）、跨主机同可用区（Available Zone）、跨可用区同地区（Region）、跨地区同服务商（Cloud Service Provider）、跨云平台。Kubernetes的设计定位是单一集群在同一个地域内，因为同一个地区的网络性能才能满足Kubernetes的调度和计算存储连接要求。而联合集群服务就是为提供跨Region跨服务商Kubernetes集群服务而设计的。
每个Kubernetes Federation有自己的分布式存储、API Server和Controller Manager。用户可以通过Federation的API Server注册该Federation的成员Kubernetes Cluster。当用户通过Federation的API Server创建、更改API对象时，Federation API Server会在自己所有注册的子Kubernetes Cluster都创建一份对应的API对象。在提供业务请求服务时，Kubernetes Federation会先在自己的各个子Cluster之间做负载均衡，而对于发送到某个具体Kubernetes Cluster的业务请求，会依照这个Kubernetes Cluster独立提供服务时一样的调度模式去做Kubernetes Cluster内部的负载均衡。而Cluster之间的负载均衡是通过域名服务的负载均衡来实现的。</p></blockquote>

<h4>3.用户与权限概念</h4>

<h5>用户帐户（User Account）</h5>

<blockquote><p>用户帐户为人提供账户标识，对应的是人的身份，人的身份与服务的namespace无关，所以用户账户是跨namespace的</p></blockquote>

<h5>服务帐户（Service Account）</h5>

<blockquote><p>服务账户为计算机进程和Kubernetes集群中运行的Pod提供账户标识。服务帐户对应的是一个运行中程序的身份，与特定namespace是相关的。</p></blockquote>

<h5>密钥对象（Secret）</h5>

<blockquote><p>Secret是用来保存和传递密码、密钥、认证凭证这些敏感信息的对象。为了避免将类似的敏感信息明文写在配置文件中，可以将其存入一个Secret对象，并在配置文件中通过Secret对象引用这些敏感信息</p></blockquote>

<h5>RBAC访问授权</h5>

<blockquote><p>RBAC主要是引入了角色（Role）以及与角色绑定（RoleBinding）的相关抽象概念。</p></blockquote>

<h3>参考资料</h3>

<p><a href="https://infoq.cn/article/kubernetes-and-cloud-native-applications-part01">《Kubernetes 与云原生应用》系列之 Kubernetes 的系统架构与设计理念</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[K8s核心架构]]></title>
    <link href="http://wldandan.github.com/blog/2019/03/14/k8s-architecture/"/>
    <updated>2019-03-14T23:45:00+08:00</updated>
    <id>http://wldandan.github.com/blog/2019/03/14/k8s-architecture</id>
    <content type="html"><![CDATA[<p>Kubernetes主要由以下几个核心组件组成：</p>

<ul>
<li>etcd保存了整个集群的状态；</li>
<li>apiserver提供了资源操作的唯一入口，并提供认证、授权、访问控制、API注册和发现等机制；</li>
<li>controller manager负责维护集群的状态，比如故障检测、自动扩展、滚动更新等；</li>
<li>scheduler负责资源的调度，按照预定的调度策略将Pod调度到相应的机器上；</li>
<li>kubelet负责维护容器的生命周期，同时也负责Volume（CSI）和网络（CNI）的管理；</li>
<li>Container runtime负责镜像管理以及Pod和容器的真正运行（CRI）；</li>
<li>kube-proxy负责为Service提供cluster内部的服务发现和负载均衡；</li>
</ul>


<!-- More -->


<p>除了核心组件，还有一些推荐的插件，其中有的已经成为CNCF中的托管项目：</p>

<ul>
<li>CoreDNS负责为整个集群提供DNS服务</li>
<li>Ingress Controller为服务提供外网入口</li>
<li>Prometheus提供资源监控</li>
<li>Dashboard提供GUI</li>
<li>Federation提供跨可用区的集群</li>
</ul>


<h3>K8s整体架构</h3>

<p><img src="http://wldandan.github.com/images/k8s/kubernetes-whole-arch.png" /></p>

<h5>K8s-Master架构图</h5>

<p><img src="http://wldandan.github.com/images/k8s/kubernetes-master-arch.png" /></p>

<h5>K8s-Node架构图</h5>

<p><img src="http://wldandan.github.com/images/k8s/kubernetes-node-arch.png" /></p>

<h3>K8s分层架构</h3>

<p><img src="http://wldandan.github.com/images/k8s/kubernetes-layers-arch.png" /></p>

<h3>K8s简化图</h3>

<p><img src="http://wldandan.github.com/images/k8s/k8s-control-plane.jpg" /></p>

<ul>
<li>核心层：Kubernetes最核心的功能，对外提供API构建高层的应用，对内提供插件式应用执行环境</li>
<li>应用层：部署（无状态应用、有状态应用、批处理任务、集群应用等）和路由（服务发现、DNS解析等）、Service Mesh（部分位于应用层）</li>
<li>管理层：系统度量（如基础设施、容器和网络的度量），自动化（如自动扩展、动态Provision等）以及策略管理（RBAC、Quota、PSP、NetworkPolicy等）、Service Mesh（部分位于管理层）</li>
<li>接口层：kubectl命令行工具、客户端SDK以及集群联邦</li>
<li><p>生态系统：在接口层之上的庞大容器集群管理调度的生态系统，可以划分为两个范畴</p>

<ul>
<li><p>Kubernetes外部：日志、监控、配置管理、CI/CD、Workflow、FaaS、OTS应用、ChatOps、GitOps、SecOps等</p></li>
<li><p>Kubernetes内部：CRI、CNI、CSI、镜像仓库、Cloud Provider、集群自身的配置和管理等</p></li>
</ul>
</li>
</ul>


<blockquote><p>关于分层架构，可以关注下Kubernetes社区正在推进的<a href="https://docs.google.com/document/d/1XkjVm4bOeiVkj-Xt1LgoGiqWsBfNozJ51dyI-ljzt1o">Kubernetes architectual roadmap</a>和<a href="https://docs.google.com/presentation/d/1GpELyzXOGEPY0Y1ft26yMNV19ROKt8eMN67vDSSHglk/edit">slide</a>。</p></blockquote>

<h3>参考资料</h3>

<p><a href="http://queue.acm.org/detail.cfm?id=2898444">Borg, Omega, and Kubernetes - Lessons learned from three container-management systems over a decade</a></p>

<p><a href="http://static.googleusercontent.com/media/research.google.com/zh-CN//pubs/archive/43438.pdf">Paper - Large-scale cluster management at Google with Borg</a></p>

<p><a href="http://thenewstack.io/kubernetes-an-overview">KUBERNETES: AN OVERVIEW</a></p>

<p><a href="https://docs.google.com/document/d/1XkjVm4bOeiVkj-Xt1LgoGiqWsBfNozJ51dyI-ljzt1o">Kubernetes architectual roadmap</a>和<a href="https://docs.google.com/presentation/d/1GpELyzXOGEPY0Y1ft26yMNV19ROKt8eMN67vDSSHglk/edit">slide</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[微服务实战系列(5) - HAL 101]]></title>
    <link href="http://wldandan.github.com/blog/2016/11/08/microservices-in-action-rest-hal/"/>
    <updated>2016-11-08T23:45:00+08:00</updated>
    <id>http://wldandan.github.com/blog/2016/11/08/microservices-in-action-rest-hal</id>
    <content type="html"><![CDATA[<p>[如需转载，请联系本人]</p>

<p>过去的几个月，我作为独立咨询师，为多个传统企业提供了微服务架构的培训、咨询以及交付工作。实际上，传统企业在过去多年的业务积累中，由于组织架构、业务发展和市场竞争等综合因素，技术体系相对封闭，缺乏快速交付的理念。因此，微服务的出现，加之社区的热捧，导致很多传统的团队过于追热而并没有完全理解微服务。</p>

<p>经过2015年的快速普及，微服务的优势被越来越多的传统组织和企业所认可，但由于架构相关的知识本身比较抽象，虽然各大会议上有很多互联网公司的案例分享，但开发者似乎依然很难全面了解微服务架构。</p>

<p>所以，希望通过本系列的文章以及视频，以一个真实的案例为背景，以持续交付和DevOps为主线，帮助初学者理解微服务架构，并能通过动手实验，了解相关的实践以及方法论。</p>

<p>精彩课程已经出炉，请移步<a href="http://www.stuq.org/course/detail/1088">这里</a></p>

<!-- More -->


<h3>综述</h3>

<p>REST API通常作为服务间协作的轻量级通信协议(语言无关、平台无关)，被微服务架构广泛采用。</p>

<p>在微服务架构的中，如何有效的设计REST API，如何处理API响应中资源的依赖关系，服务规模化后如何提高服务团队间的协作效率&hellip;..这些都成为微服务实践中API设计面临的挑战。</p>

<p>本篇将介绍REST、REST成熟度模型、为什么使用HAL以及HAL的核心。</p>

<h3>REST 101</h3>

<p>REST（Representational State Transfer，表述性状态传递）是近几年使用广泛的架构风格之一。在微服务架构的实践中，REST经常作为服务间协作的轻量级通信协议(语言无关、平台无关)被采用。</p>

<p><img src="http://wldandan.github.com/images/microservice-in-action-with-spring/rest-hal/rest-core-600-450.png" /></p>

<p>REST从语义层面将响应结果定义为资源，并使用HTTP协议的标准动词映射为对资源的操作，形成了一种以资源为核心、以HTTP协议为操作方式的，与语言无关、平台无关的服务间的通信机制。</p>

<p>通过资源表述、状态转移以及统一接口，REST将客户端的请求、服务器端的响应基于资源联系起来，形成一种以资源为核心、以HTTP协议为操作方式的，与语言无关、平台无关的通信机制。</p>

<p>同时，由于HTTP协议本身的无状态性，使用REST，能够有效保持服务应用的无状态型，并利于水平伸缩。</p>

<h3>REST 成熟度模型</h3>

<p>REST成熟度模型描述了REST在实施过程中不同的级别。</p>

<p><img src="http://wldandan.github.com/images/microservice-in-action-with-spring/rest-hal/rest-maturity-model-600-450.png" /></p>

<h3>REST不是银弹</h3>

<p>随着组织业务的不断增长，服务规模化的实施，以及响应内容复杂度的增加，REST的使用面临如下两个挑战：</p>

<ul>
<li>如何标准化资源结构</li>
</ul>


<p>使用REST，需要将业务场景的响应抽象为资源，并基于JSON或者XML的格式，返回给客户端。随着业务复杂度的增加，响应的内容会愈发复杂。</p>

<p>REST架构风格，并没有定义响应结构应该遵循什么标准。这也就意味着，在企业内部，不同的部门，不同的开发团队，对同一类资源，所定义的结构可能不尽相同；</p>

<p>譬如，如下是服务器端对客户端获取产品请求的的响应结果，两种结构都是合理的，但存在着差异</p>

<pre><code>GET http://bookstore.com/books/12 
Accept: application/json
</code></pre>

<hr />

<pre><code>响应结构一
{  
    "name":"Spring Boot In Action",  
    "category": "Book",  
    "price":69.00,  
    "ref": "http://bookstore.com/books/12",
    "created_at": "2015-05-01 10:00:00",
    "updated_at": "2015-06-01 11:00:00"
}  
</code></pre>

<hr />

<pre><code>响应结构二
{
  "basic_info":
  {
    "name":"Spring Boot In Action",
    "category":"Book"
    "price":69.00,
  },

  "ref":{
    "self": "http://bookstore.com/books/12”,
    “list": "http://bookstore.com/books"
  },

  "timestamp":{
    "created_at": "2015-05-01 10:00:00",
    "updated_at": "2015-06-01 11:00:00"
  }
}
</code></pre>

<p>因此，如何定义一套标准的资源响应结构，成为服务规模化后使用REST面临的一个挑战。</p>

<ul>
<li>如何处理资源的跳转链接</li>
</ul>


<p>在<a href="http://martinfowler.com/articles/richardsonMaturityModel.html">《Richardson Maturity Model》</a>模型中，定义了REST API不同成熟度应该具备的特征。</p>

<p>对于REST API Level 3，明确提出了"资源跳转的重要性"，即<code>HATEOAS</code>。</p>

<p>对于实际情况而言，大部分REST的实现，都是基于JSON作为传输格式，不过JSON最大的遗憾，正如W3C所描述的：</p>

<blockquote><p>JSON has no built-in support for hyperlinks, which are a fundamental building block on the Web.</p>

<p>没有对超链接处理做内建的支持，是JSON最大的遗憾。而这部分却恰恰是互联网的基石。</p></blockquote>

<p>这带来的潜在问题是，对于调用接口的Consumer而言，需要通过查看相关文档，才能了解如何获取相关的资源信息。譬如，某些社交系统可能会提供类似如下的接口文档，来帮助Consumer了解如何使用其提供的接口。</p>

<pre><code>https://api.example.com/users/1234567890      GET 获取用户明细
https://api.example.com/users/[ID]/friends    GET 获取用户相关的好友
https://api.example.com/users/[ID]/posts      GET 获取用户相关的文章
</code></pre>

<h3>HAL 101</h3>

<p>HAL（Hypertext Application Language）是一种轻量级超文本应用描述协议。HAL的实现基于REST，并对REST中资源结构无法标准化和不支持资源间跳转链接做了有效的互补。</p>

<p>目前，越来越多的企业和组织开始使用HAL提供标准化的服务接口，譬如</p>

<ul>
<li><p><a href="http://docs.aws.amazon.com/appstream/latest/developerguide/rest-api-application.html">AWS APP Stream API</a></p></li>
<li><p><a href="https://smxemail.com">SMXEmail API</a></p></li>
<li><p><a href="http://api.m.ox.ac.uk/browser/#/">牛津大学官方数据API</a></p></li>
</ul>


<p>更多案例请可以参考<a href="http://stateless.co/hal_specification.html">HAL官方网站</a>。</p>

<h3>HAL的核心</h3>

<p>在HAL中，任何响应都被定义成一种资源（Resource），这是遵循REST原则对资源的定义标准。
同REST不同的是，在每个资源中，HAL又将其分成了如下三个标准的部分：</p>

<ul>
<li>状态(Resource State) - 通常指资源本身固有的属性，如之前提到的book的title、price等</li>
<li>链接(Links) - 定义了与当前资源相关的资源链接的集合</li>
<li>子资源(Embedded Resource) - 描述在当前资源的内部，其嵌套的资源。</li>
</ul>


<p><img src="http://wldandan.github.com/images/microservice-design-and-practice/rest-api-design/hal-model-400-300.png" /></p>

<h4>使用HAL定义单一资源(Resource)</h4>

<p>对于单一资源而言，如果没有使用HAL，通常我们会定义成这样：</p>

<pre><code>GET - /api/users/wldandan
Content-Type: application/json

{
    "id": "wldandan",
    "name": "Wang Lei",
    "email": "useremail@email.com",
    "wechat": "abcdefg"
}   
</code></pre>

<p>如果要访问用户相关的联系人资源，则可能需要查看文档获取相应的API接口，或者将相关信息放在之前返回的结果里：</p>

<pre><code>{
    "id": "wldandan",
    "name": "Wang Lei",
    "email": "useremail@email.com",
    "wechat": "abcdefg",
    "contacts": [
        {
            "id": "chenyue",
            "name": "Chen Yue"
            "link": "/api/users/chenyue"
        },
        {
            "id": "kouxi",
            "name": "Kou Xi"
            "link": "/api/users/chenyue"
        }
    ]
}   
</code></pre>

<p>如果基于HAL，则可以使用<code>_links</code>描述相关链接，同时使用<code>_embedded</code>描述嵌套资源，类似如下：</p>

<pre><code>{
    "_links": {
        "self": {
            "href": "http://example.org/api/users/wldandan"
        }
    },
    "id": "wldandan",
    email: 'useremail@email.com',
    "name": "Wang Lei"
    wechat: 'abcdefg',

    "_embedded": {
        "contacts": [
        {
            "_links": {
                "self": {
                    "href": "http://example.org/api/users/chenyue"
                }
            },
            "id": "chenyue",
            "name": "Chen Yue"
        },
        {
            "_links": {
                "self": {
                    "href": "http://example.org/api/users/kouxi"
                }
            },
            "id": "kouxi",
            "name": "Kou Xi"
        }
        ]
    }
}
</code></pre>

<h4>使用HAL定义集合资源(Collection Resource)</h4>

<p>对于集合资源而言，如果没有使用HAL，通常我们会定义成这样：</p>

<pre><code>GET - /api/users
Content-Type: application/json

{
    total: 10
    page: 5
    page_size: 2
    users: [
    {
        id: 'wldandan',
        name: 'Wang Lei'
    },
    {
        id: 'chenyue',
        name: 'Chen Yue'
    },
    ]
}
</code></pre>

<p>基于HAL，则使用<code>_links</code>描述相关链接，同时使用<code>_embedded</code>描述嵌套资源，类似则如下所示：
    {
        &ldquo;<em>links&rdquo;: {
            &ldquo;self&rdquo;: {
                &ldquo;href&rdquo;: &ldquo;<a href="http://example.org/api/users?page=3">http://example.org/api/users?page=3</a>&rdquo;
            },
            &ldquo;first&rdquo;: {
                &ldquo;href&rdquo;: &ldquo;<a href="http://example.org/api/users">http://example.org/api/users</a>&rdquo;
            },
            &ldquo;prev&rdquo;: {
                &ldquo;href&rdquo;: &ldquo;<a href="http://example.org/api/users?page=2">http://example.org/api/users?page=2</a>&rdquo;
            },
            &ldquo;next&rdquo;: {
                &ldquo;href&rdquo;: &ldquo;<a href="http://example.org/api/users?page=4">http://example.org/api/users?page=4</a>&rdquo;
            },
            &ldquo;last&rdquo;: {
                &ldquo;href&rdquo;: &ldquo;<a href="http://example.org/api/users?page=5">http://example.org/api/users?page=5</a>&rdquo;
            }
        },
        &ldquo;page_size&rdquo;: 2,
        &ldquo;total&rdquo;: 10,
        &ldquo;page&rdquo;: 5,
        &ldquo;</em>embedded&rdquo;: {
            &ldquo;users&rdquo;: [
                {
                    &ldquo;<em>links&rdquo;: {
                        &ldquo;self&rdquo;: {
                            &ldquo;href&rdquo;: &ldquo;<a href="http://example.org/api/users/wldandan">http://example.org/api/users/wldandan</a>&rdquo;
                        }
                    },
                    &ldquo;id&rdquo;: &ldquo;wldandan&rdquo;,
                    &ldquo;name&rdquo;: &ldquo;Wang Lei&rdquo;
                },
                {
                    &ldquo;</em>links&rdquo;: {
                        &ldquo;self&rdquo;: {
                            &ldquo;href&rdquo;: &ldquo;<a href="http://example.org/api/user/chenyue">http://example.org/api/user/chenyue</a>&rdquo;
                        }
                    },
                    &ldquo;id&rdquo;: &ldquo;chenyue&rdquo;,
                    &ldquo;name&rdquo;: &ldquo;Chen Yue&rdquo;
                }
            ]
        }
    }</p>

<blockquote><p>所以，HAL的最大价值，帮助我们标准化定义了Resource的结构，并同时实现了HATEOAS。</p></blockquote>

<p>关于课程更多内容，请看<a href="http://www.stuq.org/course/detail/1088">这里</a></p>

<h3>参考资料</h3>

<p><a href="https://apigility.org/documentation/api-primer/halprimer">Hypertext Application Language</a></p>

<p><a href="http://blog.stateless.co/post/13296666138/json-linking-with-hal">JSON Linking with HAL</a></p>

<p><a href="Creating%20Service%20Contract%20with%20AutoRest,%20Swagger%20and%20HAL">Creating Service Contract with AutoRest, Swagger and HAL</a></p>

<p><a href="https://opencredo.com/hal-hypermedia-api-spring-hateoas/">Implementing HAL hypermedia REST API using Spring HATEOAS</a></p>

<p><a href="http://stateless.co/hal_specification.html">HAL Specification</a></p>

<p><a href="https://groups.google.com/forum/#!forum/hal-discuss">hal-discuss@google groups</a></p>

<p><a href="http://hyperschema.org/mediatypes/hal">HAL+JSON</a></p>

<p><a href="https://opencredo.com/rest-api-tooling-review/">Documenting REST APIs – a tooling review</a></p>

<p><a href="http://phlyrestfully.readthedocs.io/en/latest/halprimer.html">HAL Primer</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[微服务实战(4) - Spring Cloud 101]]></title>
    <link href="http://wldandan.github.com/blog/2016/11/07/microservices-in-action-spring-cloud-101/"/>
    <updated>2016-11-07T23:37:00+08:00</updated>
    <id>http://wldandan.github.com/blog/2016/11/07/microservices-in-action-spring-cloud-101</id>
    <content type="html"><![CDATA[<p>[如需转载，请联系本人]</p>

<p>过去的几个月，我作为独立咨询师，为多个传统企业提供了微服务架构的培训、咨询以及交付工作。实际上，传统企业在过去多年的业务积累中，由于组织架构、业务发展和市场竞争等综合因素，技术体系相对封闭，缺乏快速交付的理念。因此，微服务的出现，加之社区的热捧，导致很多传统的团队过于追热而并没有完全理解微服务。</p>

<p>经过2015年的快速普及，微服务的优势被越来越多的传统组织和企业所认可，但由于架构相关的知识本身比较抽象，虽然各大会议上有很多互联网公司的案例分享，但开发者似乎依然很难全面了解微服务架构。</p>

<p>所以，希望通过本系列的文章以及视频，以一个真实的案例为背景，以持续交付和DevOps为主线，帮助初学者理解微服务架构，并能通过动手实验，了解相关的实践以及方法论。</p>

<p>精彩课程已经出炉，请移步<a href="http://www.stuq.org/course/detail/1088">这里</a></p>

<!-- More -->


<h2>服务实施的挑战</h2>

<h3>个体服务的实现越来越容易</h3>

<p>在上一节中，我们学习了Spring Boot的核心，明白了<code>Starter</code>与<code>AutoConfiguration</code>的重要性，并知道了如何快速创建Spring Boot应用。</p>

<p>基于现有的<code>Spring Framework</code>，以及<code>Spring Boot的Starter</code>，加上<code>官方CLI</code>、 <code>Initializr</code>以及各种<code>IDE</code>提供的快速创建SpringBoot 应用的方式，我们能轻松的完成一个基于RESTful API的服务实现。</p>

<p>因此，从Spring Boot的优势来看，构建单个的服务单元非常容易了~</p>

<blockquote><p>从IT社区的发展来看，工具正在变得越来越强大，开发人员的大部分重复性工作都将会被简化。</p>

<p>伴随着人工智能的快速发展，将来编码的工作都可以交给机器了，喝着咖啡告诉它，你想要什么语言，你的验收条件，啦啦啦&hellip;.</p></blockquote>

<h3>但服务间的协作、管理成本越来越高</h3>

<p>但是，对于微服务的实施而言，服务单元不会孤立存在，必然相互协作，共同实现业务价值。</p>

<p><img src="http://wldandan.github.com/images/microservice-in-action-with-spring/spring-boot/microservice-coordination-600-450.png" /></p>

<p>而随着服务规模化的推进，服务间协作和管理的成本会越来越高，包括但不限于：</p>

<ul>
<li>服务地址发生变化

<ul>
<li>服务结点数量动态变化(水平伸缩)</li>
<li>服务结点地址动态变化(重启、升级)</li>
</ul>
</li>
<li>服务的配置信息变更

<ul>
<li>配置信息修改后，如何动态更新单实例</li>
<li>配置信息修改后，如何同步多个实例</li>
<li>配置信息的追溯、回滚及可用性保障</li>
</ul>
</li>
<li>服务间调用出现异常

<ul>
<li>如何防止调用间的”雪崩”</li>
</ul>
</li>
<li>为消费者提供统一接口

<ul>
<li>如何提供单一的入口简化设备的调用</li>
<li>屏蔽不同的应用协议(MQ/JMS)</li>
</ul>
</li>
</ul>


<p>所以，如何应对如上这些问题，成为微服务实施中重要的环节。</p>

<h2>什么是Spring Cloud</h2>

<p><code>Spring Cloud</code>是Pivotal官方提供的旨在帮助开发者降低构建复杂分布式系统的工具集。</p>

<p>2015年3月4日，Spring Cloud发布了第一个GA版本。</p>

<p>Spring Cloud的核心宗旨是：</p>

<blockquote><p>A toolset designed for building complexed distributed systems.</p></blockquote>

<p>在Spring Cloud中，整合了很多功能组件，包括Config、Messaging、Netflix OSS以及对Heroku、Amazon Web Service、Cloud Foundry等云平台的接口支持。</p>

<p><img src="http://wldandan.github.com/images/microservice-in-action-with-spring/spring-boot/spring-cloud-components-600-450.png" /></p>

<p>基于这些组件，能够帮助我们解决之前提到的服务实施后面临的挑战。</p>

<h2>常用的Spring Cloud组件</h2>

<p>Spring Cloud中的组件很多，而且在快速的演进中，在本系列<code>服务构建篇</code>里，主要涉及的有</p>

<blockquote><p>Spring Cloud Netflix</p></blockquote>

<p>集成了Netflix OSS的组件(Eureka/Ribbon/Hystrix/Zuul等)</p>

<blockquote><p>Spring Cloud Config</p></blockquote>

<p>提供集中化的服务配置信息，动态更新实例的配置</p>

<blockquote><p>Spring Cloud Bus</p></blockquote>

<p>使用分布式消息机制，提供不同服务实例之间的协作</p>

<blockquote><p>Spring Cloud Security</p></blockquote>

<p>提供服务安全相关的实现机制(OAuth2)</p>

<h2>总结</h2>

<blockquote><p>Spring Cloud本着<code>全家桶</code>的一站式解决方案，为微服务的实施提供了支持。</p>

<p>虽然Spring Cloud GA的时间并不长，但其快速的演进以及大量社区用户的支持，已成为Java领域微服务架构实施的利器，帮助我们有效的应对服务实践时的构建支撑组件的挑战。</p>

<p>后续我们将使用Spring Cloud构建本案例服务的支撑组件。</p>

<p>关于课程，请看<a href="http://www.stuq.org/course/detail/1088">这里</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[微服务实战(3) - Spring Boot 101]]></title>
    <link href="http://wldandan.github.com/blog/2016/11/06/microservices-in-action-spring-boot-101/"/>
    <updated>2016-11-06T17:57:00+08:00</updated>
    <id>http://wldandan.github.com/blog/2016/11/06/microservices-in-action-spring-boot-101</id>
    <content type="html"><![CDATA[<p>[如需转载，请联系本人]</p>

<p>过去的几个月，我作为独立咨询师，为多个传统企业提供了微服务架构的培训、咨询以及交付工作。实际上，传统企业在过去多年的业务积累中，由于组织架构、业务发展和市场竞争等综合因素，技术体系相对封闭，缺乏快速交付的理念。因此，微服务的出现，加之社区的热捧，导致很多传统的团队过于追热而并没有完全理解微服务。</p>

<p>经过2015年的快速普及，微服务的优势被越来越多的传统组织和企业所认可，但由于架构相关的知识本身比较抽象，虽然各大会议上有很多互联网公司的案例分享，但开发者似乎依然很难全面了解微服务架构。</p>

<p>所以，希望通过本系列的文章以及视频，以一个真实的案例为背景，以持续交付和DevOps为主线，帮助初学者理解微服务架构，并能通过动手实验，了解相关的实践以及方法论。</p>

<p>精彩课程已经出炉，请移步<a href="http://www.stuq.org/course/detail/1088">这里</a></p>

<!-- More -->


<h2>为什么是Spring Boot</h2>

<p>在Java开发领域，估计没有多少兄弟不知道Spring，当年的SSH组合，风靡社区，几乎成为J2EE 程序开发的标配。</p>

<p>另外，Spring对诸多企业特性的强大支持，为构建Java的企业应用提供了<code>全家桶</code>的解决方案。</p>

<p><img src="http://wldandan.github.com/images/microservice-in-action-with-spring/spring-boot/spring-io-600-450.png" /></p>

<p>对于现代Java开发，尤其是以微服务为主的应用，虽然有<a href="https://dropwizard.github.io/">DropWizard</a>、<a href="https://ee.kumuluz.com/">KumuluzEE</a>等微服务框架的诞生，但Spring Boot借助极致的<code>Convention Over Configuration</code>，加上对<code>Spring Framework</code>的无缝支持，被社区普遍看好。</p>

<p>在今年10月中旬结束的<a href="https://jaxlondon.com/jax-awards/">2016 JAX Java Innovation</a>评选中，Spring Boot一举拔得头筹，而去年Java领域的这个奖项是颁给了著名的<a href="https://netflix.github.io/">Netflix OSS</a>，足以证明Spring Boot在社区的影响力。</p>

<p><img src="http://wldandan.github.com/images/microservice-in-action-with-spring/spring-boot/jax-award-spring-boot-600-450.png" /></p>

<h2>Spring Boot的优势</h2>

<ul>
<li><code>快速构建</code>可运行的应用

<ul>
<li><code>无XML配置</code></li>
<li>支持<code>内嵌</code>WebServer(Tomcat/Jetty/Undertow)</li>
<li>通过<code>注解</code>的方式，一行代码启动应用</li>
</ul>
</li>
<li><code>自动配置</code>和<code>装载机制</code>

<ul>
<li>使用Starter</li>
<li>自动配置装载依赖</li>
</ul>
</li>
<li>运维接口友好

<ul>
<li><code>Metrics/health</code>显示健康监控状态</li>
<li><code>Trace/dump</code>显示调用/调试信息</li>
</ul>
</li>
</ul>


<h2>Spring Boot核心</h2>

<h3>简单的说，Spring Boot的核心，主要包括两大部分：</h3>

<blockquote><p>1.Starter</p></blockquote>

<p>Starter负责将申明的依赖Jar包导入到当前ClassPath。</p>

<p>每个Starter都提供一个<code>spring.providers文件</code>，申明当前Starter依赖的Jar包。</p>

<p>譬如，<code>Spring-boot-starter-web</code>中的<code>spring.providers文件</code>描述的依赖如下所示：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>provides: spring-webmvc,spring-web,jackson-databind</span></code></pre></td></tr></table></div></figure>


<p>包括<code>spring-webmvc</code>，<code>spring-web</code>，<code>jackson-databind</code>，分别提供mvc，web和JSON解析绑定的功能。</p>

<p>欲了解更多的Starter，请移步<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-starters">官方列表</a></p>

<blockquote><p>2.AutoConfiguratioin</p></blockquote>

<p>AutoConfiguratioin根据<code>ConditionalOnXxx</code>条件，使用<code>@Bean</code>注解，完成对Bean的创建和组装。</p>

<p>根据不同的<code>ConditionalOnXxx</code>，AutoConfiguration可以根据合适的场景创建并组装Bean。</p>

<p>譬如</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ConditionalOnMissingBean(A.class)</span></code></pre></td></tr></table></div></figure>


<blockquote><p>表示当前指定的A实例不存在，才创建@Bean.</p></blockquote>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ConditionalOnWebApplication</span></code></pre></td></tr></table></div></figure>


<blockquote><p>表示当前是在Web Application才创建@Bean</p></blockquote>

<p>Java Web中我们经常使用<code>HttpEncodingAutoConfiguration</code>，完成UTF8的转码。如下是SpringBoot中，HttpEncodingAutoConfiguration的部分实现：</p>

<blockquote><p>仅当ApplicationContext中没有CharacterEncodingFilter的时候，才会创建<code>CharacterEncodingFilter</code></p></blockquote>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@Bean
</span><span class='line'>@ConditionalOnMissingBean(CharacterEncodingFilter.class)
</span><span class='line'>public CharacterEncodingFilter characterEncodingFilter() {
</span><span class='line'>  CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter();
</span><span class='line'>  filter.setEncoding(this.properties.getCharset().name());
</span><span class='line'>  filter.setForceRequestEncoding(this.properties.shouldForce(Type.REQUEST));
</span><span class='line'>  filter.setForceResponseEncoding(this.properties.shouldForce(Type.RESPONSE));
</span><span class='line'>  return filter;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<blockquote><p>所以, 我对SpringBoot的理解为，如下两个核心点(配合起来，天下无敌&hellip;.)</p></blockquote>

<ul>
<li><code>Starter打包提供相关的包依赖，加载到ClassPath</code></li>
<li><code>EnableAutoConfiguration借助ConditionalOnXxx条件，创建并配置Bean的依赖关系</code></li>
</ul>


<p>关于更多<code>Conditional</code>的细节，请查看包
<em>org.springframework.boot.autoconfigure.condition</em>中的具体实现，其列表如下图所示：</p>

<p><img src="http://wldandan.github.com/images/microservice-in-action-with-spring/spring-boot/spring-boot-conditional-xxx-600-450.png" /></p>

<h3>另外，每个SpringBoot应用上都会加标签@SpringBootApplication</h3>

<p>这个标签是SpringBoot应用的核心标签，主要包括三部分子：</p>

<ul>
<li>@Configuration</li>
</ul>


<p>Spring3.0引入@Configuration(Java配置)，使用Java配置简化XML配置。</p>

<p>譬如以前我们通常使用类似如下XML配置Spring Bean</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;beans xmlns="http://www.springframework.org/schema/beans"
</span><span class='line'>  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
</span><span class='line'>  xsi:schemaLocation="http://www.springframework.org/schema/beans
</span><span class='line'>  http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt;
</span><span class='line'>
</span><span class='line'>  &lt;bean id="helloBean" class=“com.microservice.training.HelloWorldImpl"&gt;
</span><span class='line'>&lt;/beans&gt;</span></code></pre></td></tr></table></div></figure>


<p>通过使用Java Configuration，声明当前类是一个配置类， 相当于声明一个Spring配置的XML文件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@Configuration
</span><span class='line'>public class AppConfig {
</span><span class='line'>
</span><span class='line'>    @Bean(name="helloBean")
</span><span class='line'>    public HelloWorld helloWorld() {
</span><span class='line'>        return new HelloWorldImpl();
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ul>
<li>@EnableAutoConfiguration</li>
</ul>


<p>它帮助我们加载当前Spring Boot中META-INF/spring.factories，并使用其中的*AutoConfiguration</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>HttpEncodingAutoConfiguration
</span><span class='line'>RabbitAutoConfiguration 
</span><span class='line'>EmbeddedServletContainerAutoConfiguration
</span><span class='line'>……</span></code></pre></td></tr></table></div></figure>


<p>每个AutoConfiguration都会根据其中的Condition条件，在合适的场景完成对相关Bean的创建</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@ConditionalOnBean //容器里有指定Bean存在
</span><span class='line'>@ConditionalOnClass //类路径下有指定Class存在
</span><span class='line'>@ConditionalOnWebApplication //当前项目是Web项目
</span><span class='line'>……</span></code></pre></td></tr></table></div></figure>


<ul>
<li>@ComponentScan</li>
</ul>


<p>它定义Spring了自动加载Bean的根路径，是Spring Framwork中较早的一个标签，这里就不赘述了。</p>

<h2>快速构建Spring Boot应用</h2>

<p>Spring Boot提供了方便的项目创建方式，使得我们可以快速创建基于SpringBoot的项目：</p>

<ul>
<li>使用<a href="http://sdkman.io/">命令行CLI</a></li>
<li>使用<a href="start.spring.io">Initializr</a></li>
<li>使用IDE(IDEA，Spring Tool Suite等)</li>
</ul>


<h2>总结</h2>

<blockquote><p>本部分介绍了SpringBoot的核心，并提到了快速创建SpringBoot应用的方式，通过这部分内容，能够帮助大家完成<code>SpringBoot从0到1的过程</code> :)</p>

<p>关于课程，请看<a href="http://www.stuq.org/course/detail/1088">这里</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[微服务实战(2) - 目标系统]]></title>
    <link href="http://wldandan.github.com/blog/2016/11/05/microservices-in-action-simulation/"/>
    <updated>2016-11-05T14:28:00+08:00</updated>
    <id>http://wldandan.github.com/blog/2016/11/05/microservices-in-action-simulation</id>
    <content type="html"><![CDATA[<p>[如需转载，请联系本人]</p>

<p>过去的几个月，我作为独立咨询师，为多个传统企业提供了微服务架构的培训、咨询以及交付工作。在这些企业中，大部分的开发者对微服务的理解，以“银弹观念”为主。实际上，传统企业在过去多年的业务积累中，由于组织架构、业务发展和市场竞争等综合因素，技术体系相对封闭，缺乏快速交付的理念。因此，微服务的出现，加之社区的热捧，导致这种现象出现也是比较能理解的。</p>

<p>经过2015年的快速普及，微服务的优势被越来越多的传统组织和企业所认可，但由于架构相关的知识本身比较抽象，虽然各大会议上有很多互联网公司的案例分享，但开发者似乎依然很难全面了解微服务架构。</p>

<p>所以，希望通过本系列的文章，以一个模拟的案例为背景，以持续交付和DevOps为主线，帮助初学者理解微服务架构，并能通过动手实验，了解相关的实践以及方法论。</p>

<p>精彩课程已经出炉，请移步<a href="http://www.stuq.org/course/detail/1088">这里</a></p>

<!-- More -->


<h2>目标系统</h2>

<blockquote><p>构建一个用户查看活动、报名活动、接收通知的系统</p>

<ul>
<li>匿名用户可查看活动列表</li>
<li>匿名用户可以查看活动详情</li>
<li>匿名用户可以查看相关活动推荐和评论</li>
<li>用户登陆成功后完成报名</li>
<li>报名成功，用户获取通知</li>
</ul>
</blockquote>

<h2>服务定义</h2>

<blockquote><p>关于服务的划分，是一个非常有深度的话题，与业务场景、技术实现、团队能力有着密不可分的关系。
从方法论上有：</p>

<ul>
<li>根据<a href="https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215">DDD</a>，包括业务上下文、事件驱动、读写分离等</li>
<li>根据名词类对象，譬如商品、订单等</li>
<li>根据动词类行为，譬如支付，预订等</li>
<li>其他切入点</li>
</ul>


<p>在这个模拟场景中，为了保持简洁，我假定使用名词和动词进行划分，包括如下：</p></blockquote>

<ul>
<li><code>活动服务Event-service</code>(提供活动的列表和活动详情的相关数据）</li>
<li><code>推荐服务Recommendation-service</code>(提供与某个活动相关的推荐信息)</li>
<li><code>评论服务Review-service</code>(提供与某个活动相关的评论信息)</li>
<li><code>活动聚合服务Event-composite-service</code>(聚合服务 - 提供某个活动及其相关的推荐、评论信息</li>
<li><code>报名服务Enroll-service</code>(为登录用户提供报名)</li>
<li><code>通知服务Notification-service</code>(用户报名成功后获取通知)</li>
</ul>


<blockquote><p>该活动报名系统的应用架构图如下：</p></blockquote>

<p><img src="http://wldandan.github.com/images/microservice-in-action-with-spring/events-system-architecture-600-450.png" /></p>

<h2>服务实现</h2>

<ul>
<li>Java 8/Gradle 2.13</li>
<li>SpringBoot 1.4.2 / SpringCloud Camden.SR2</li>
<li>MongoDB 使用Document存储活动数据</li>
<li>REST/HAL/HAL-Browser 定义服务之间通信的接口</li>
<li>JVM-Pact 实现契约测试,服务间接口的测试</li>
</ul>


<h2>服务支撑组件</h2>

<ul>
<li>Netflix OSS Eureka 实现服务注册</li>
<li>Spring Cloud Config 实现服务的配置</li>
<li>Hystrix/Turbine 实现断路器</li>
<li>Zuul 实现API网关</li>
<li>Spring Cloud Security 实现安全</li>
</ul>


<h2>基础设施</h2>

<ul>
<li>ELK 提供服务的日志的聚合服务</li>
<li>Prometheus 提供服务的监控与告警</li>
<li>Jenkins 2.0搭建系统的持续交付流水线</li>
<li>Docker提供服务的打包以及发布</li>
<li>Rancher提供Docker的轻量级管理方案</li>
</ul>


<blockquote><p>该活动报名系统的微服务生态系统图如下：</p></blockquote>

<p><img src="http://wldandan.github.com/images/microservice-in-action-with-spring/microservices-eco-system-adoption-600-450.png" /></p>

<h2>总结</h2>

<blockquote><p>通过理论+模拟+实战的方式，梳理微服务的生态系统，并以持续交付和DevOps的实施为主线，体
系化的形成微服务从0到1的学习过程。</p>

<p>关于课程，请看<a href="http://www.stuq.org/course/detail/1088">这里</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[微服务实战(1) - 内容大纲]]></title>
    <link href="http://wldandan.github.com/blog/2016/11/04/microservices-in-action-outline/"/>
    <updated>2016-11-04T14:28:00+08:00</updated>
    <id>http://wldandan.github.com/blog/2016/11/04/microservices-in-action-outline</id>
    <content type="html"><![CDATA[<script src="https://cdn1.lncld.net/static/js/av-mini-0.6.10.js"></script>


<script src="http://jerry-cdn.b0.upaiyun.com/hit-kounter/hit-kounter-lc-0.2.0.js"></script>


<p>[如需转载，请联系本人]</p>

<p>过去的几个月，我作为独立咨询师，为多个传统企业提供了微服务架构的培训、咨询以及交付工作。实际上，传统企业在过去多年的业务积累中，由于组织架构、业务发展和市场竞争等综合因素，技术体系相对封闭，缺乏快速交付的理念。因此，微服务的出现，加之社区的热捧，导致很多传统的团队过于追热而并没有完全理解微服务。</p>

<p>经过2015年的快速普及，微服务的优势被越来越多的传统组织和企业所认可，但由于架构相关的知识本身比较抽象，虽然各大会议上有很多互联网公司的案例分享，但开发者似乎依然很难全面了解微服务架构。</p>

<p>所以，希望通过本系列的文章以及视频，以一个真实的案例为背景，以持续交付和DevOps为主线，帮助初学者理解微服务架构，并能通过动手实验，了解相关的实践以及方法论。</p>

<p>精彩视频课程已经出炉，请移步<a href="http://www.stuq.org/course/detail/1088">这里</a></p>

<!-- More -->


<h2>核心思路</h2>

<ul>
<li>以<code>微服务生态系统</code>和<code>持续交付</code>为指导原则</li>
<li>以<code>模拟案例实战</code>为主，并使<code>用SpringBoot</code>和<code>Spring Cloud</code>实现服务</li>
<li>分为<code>服务构建</code>与<code>服务实施</code>两个专题，包括<code>应用架构</code>，<code>部署模型</code>和<code>交付流水线</code></li>
</ul>


<h2>主要亮点</h2>

<h4>1.全面了解微服务架构的理论基础</h4>

<ul>
<li>微服务的定义与认识误区</li>
<li>微服务的核心原则以及同SOA的关系</li>
<li>微服务的<code>持续交付体系</code></li>
</ul>


<h4>2.基于微服务生态系统，搭建模拟案例</h4>

<ul>
<li>通过案例理解<code>微服务架构生态系统</code></li>
<li>掌握<code>REST &amp; HAL &amp; HAL Browser</code>的使用方式</li>
<li>掌握<code>Spring Boot</code>的核心与使用</li>
<li>熟悉<code>Spring Cloud</code>的服务支撑组件</li>
</ul>


<blockquote><p>微服务生态系统</p></blockquote>

<p><img src="http://wldandan.github.com/images/microservice-in-action-with-spring/microservices-eco-system-600-450.png" /></p>

<h4>3.理解微服务的高级话题</h4>

<ul>
<li>使用<code>PACT契约测试</code>验证服务接口</li>
<li>使用<code>OAuth</code>与<code>JWT</code>实现服务的安全</li>
<li><code>RESTful API</code>设计相关</li>
</ul>


<blockquote><p>基于消费者驱动的契约测试</p></blockquote>

<p><img src="http://wldandan.github.com/images/microservice-in-action-with-spring/pact-600-450.png" /></p>

<h4>4.理解实施微服务与DevOps(基于Docker)</h4>

<ul>
<li>建立<code>Docker私有仓库</code>，并将服务发布成Docker镜像</li>
<li>使用<code>Docker搭建Jenkins</code>持续交付流水线</li>
<li>以<code>Pipeline as Code</code>的方式管理流水线</li>
<li>使用<code>ELK实现日志聚合</code>的实践</li>
<li>使用<code>Prometheus</code>实现监控告警的实践</li>
<li>使用<code>Rancher</code>完成服务Docker镜像的部署</li>
</ul>


<blockquote><p>部署模型图</p></blockquote>

<p><img src="http://wldandan.github.com/images/microservice-in-action-with-spring/events-system-deployment-600-450.png" /></p>

<blockquote><p>持续交付流水线</p></blockquote>

<p><img src="http://wldandan.github.com/images/microservice-in-action-with-spring/events-system-cd-600-450.png" /></p>

<h2>总结</h2>

<blockquote><p>通过理论+模拟+实战的方式，梳理微服务的生态系统，并以持续交付和DevOps的实施为主线，体
系化的形成微服务从0到1的学习过程。</p>

<p>关于课程，请看<a href="http://www.stuq.org/course/detail/1088">这里</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[微服务实战视频课(0) - 聊聊开篇]]></title>
    <link href="http://wldandan.github.com/blog/2016/11/03/microservices-in-action-introduction/"/>
    <updated>2016-11-03T14:28:00+08:00</updated>
    <id>http://wldandan.github.com/blog/2016/11/03/microservices-in-action-introduction</id>
    <content type="html"><![CDATA[<p>[如需转载，请联系本人]</p>

<p>过去的几个月，我作为独立咨询师，为多个传统企业提供了微服务架构的培训、咨询以及交付工作。实际上，传统企业在过去多年的业务积累中，由于组织架构、业务发展和市场竞争等综合因素，技术体系相对封闭，缺乏快速交付的理念。因此，微服务的出现，加之社区的热捧，导致很多传统的团队过于追热而并没有完全理解微服务。</p>

<p>经过2015年的快速普及，微服务的优势被越来越多的传统组织和企业所认可，但由于架构相关的知识本身比较抽象，虽然各大会议上有很多互联网公司的案例分享，但开发者似乎依然很难全面了解微服务架构。</p>

<p>所以，希望通过本系列的文章以及视频，以一个模拟的案例为背景，以持续交付和DevOps为主线，帮助初学者理解微服务架构，并能通过动手实验，了解相关的实践以及方法论。</p>

<p>精彩课程已经出炉，请移步<a href="http://www.stuq.org/course/detail/1088">这里</a></p>

<!-- More -->


<h2>为什么搞这么个系列</h2>

<h4>1.微服务涉及内容广泛，学习成本高</h4>

<p>微服务架构提倡将<code>单一应用程序</code>划分成<code>一组小的服务</code>，<code>每个服务运行在独立的进程中</code>，服务间<code>采用轻量级的通信机制</code>互相协作(通常是基于 HTTP 协议的 RESTful API )，每个服务都围绕着具体业务进行构建，并且能被独立的<code>开发、测试、构建、部署和交付</code>。</p>

<p>客观来说，微服务架构所涉及的内容，已经不仅仅是<code>架构本身</code>，还包括了<code>持续集成</code>、<code>持续交付</code>、<code>自动化测试</code>、<code>部署/运维、监控</code>以及<code>DevOps</code>等多个方面，这些方面互相配合、相辅相成，才能在微服务实施的过程中展现威力。</p>

<p>一个完整的微服务系统，在实施的过程中，可能还要考虑服务的<code>公共支撑部分</code>，包括但不限于：</p>

<ul>
<li><code>日志聚合</code>(将不同服务实例上的日志聚合起来，便于分析、统计和定位问题)</li>
<li><code>监控</code>和<code>告警</code>(监控每个服务的状态，必要时产生告警)</li>
<li>服务的<code>注册和发现</code>机制</li>
<li>服务的<code>认证</code>和<code>鉴权</code></li>
<li><code>服务构建</code>和<code>打包机制</code></li>
<li>服务间的<code>接口测试</code></li>
<li><code>持续集成</code>/<code>持续交付流水线</code></li>
<li><code>服务依赖</code>关系管理</li>
<li>&hellip;&hellip;</li>
</ul>


<p>对于这么多的内容，如果能基于模拟场景的理解与练习，再借鉴各大会议上诸多公司的微服务实施案例，能够快速理解并开始尝试。</p>

<h3>2.《微服务与实践》一书，该更新了</h3>

<p>2015年4月，我开始撰写《微服务架构与实践》一书，当时国内微服务架构的概念还谈的比较少，所以《微服务架构与实践》侧重讲了微服务的理论基础和诞生背景，并分享了我在ThoughtWorks就职期间，实现微服务的工作方式（我们以持续交付和DevOps为核心，构建服务开发模板，并基于AWS实现快速发布，快速监控，快速反馈）。同时，也探讨了我们如何将遗留系统改造成微服务架构的策略和步骤，但由于精力有限，很多细节无法一一展开讨论。</p>

<p>另外，书中的大部分例子都是以<code>Ruby和AWS</code>为主，很多读者也提出了建议，希望给出采用Java实现的例子，更容易理解和使用。</p>

<p>当今时代，技术发展的速度越来越快，诞生的框架、工具越来越多，虽然有心更新书的内容，但时间和精力都无法快速更新并发布新版，所以，这次希望能通过这个系列，先将过去的一些实践细化，包括DevOps、持续集成、持续交付以及使用Pact等实践，并采用Java(基于Spring Boot/Spring Cloud的快速发展)实现一个模拟的案例。</p>

<h3>3. 为感兴趣的传统开发者提供可用的案例</h3>

<p>过去两年微服务的快速发展，已经有很多传统企业开始尝试使用微服务解耦业务系统。传统企业和互联网企业的业务形态不一样，互联网公司业务变化快，响应速度快，组织愿意积极尝试开源的工具和方法论，降低交付成本和缩短交付周期。互联网领域中，大部分的产品，本身就是基于分布式系统构建，所以微服务的概念只是新瓶装旧酒。</p>

<p>而传统企业在过去多年的业务运作积累中，综合多种因素（组织结构、业务发展等），技术体系相对封闭，缺乏持续交付的理念。如果光有微服务的理论基础，和业界的成功案例，不动手尝试持续交付、DevOps等，很难有深刻的理解。</p>

<p>Github上微服务相关的实现Repo蛮多，但作为完整系列的不多。</p>

<p>所以，基于这些原因，结合过去为企业实施微服务架构培训的内容，也希望能输出这个系列。</p>

<h2>受众用户是谁</h2>

<ul>
<li><p>本系列的受众用户，主要是年轻(1~3年)的Java开发者、传统应用的IT架构师，以及对微服务感兴趣的童鞋们。</p></li>
<li><p>希望通过本系列，能将微服务、持续交付、Docker以及DevOps等技术，作为整体输出，帮助大家缩短系统了解微服务的成本。</p></li>
</ul>


<h2>数据说话</h2>

<p>关于IT社区对微服务的关注度和市场的需求数据，请看下图，一个字🔥。</p>

<p><img src="http://wldandan.github.com/images/microservice-in-action-with-spring/google_trends.png" /></p>

<blockquote><p>图的上部分是Google Trends上关于<code>Microservice</code>的增长趋势。</p>

<p>图的左下部分是<code>Microservice</code>相关关键字的增长速度，<code>Breakout</code>表明在搜索的区间内，其增长的幅度超过5000%。</p>

<p>图的右下部分是Indeed.com中对于<code>Microservice</code>的市场招聘需求的增长曲线。(趋势来了，挡都挡不住，提升个人竞争力，赶紧哈~ 😝)</p></blockquote>

<h2>总结</h2>

<blockquote><p>好的，进入正题，请移步<a href="http://www.stuq.org/course/detail/1088">课程</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[解析微服务架构]]></title>
    <link href="http://wldandan.github.com/blog/2015/03/17/microservice-design-and-implementation/"/>
    <updated>2015-03-17T11:13:00+08:00</updated>
    <id>http://wldandan.github.com/blog/2015/03/17/microservice-design-and-implementation</id>
    <content type="html"><![CDATA[<p>过去的1年多，一直在助力澳洲最大的房地产互联网门户，研究并使用微服务架构改造其复杂的遗留系统。鉴于此，准备开个系列，讲讲我个人眼中的微服务是神马样的，它的概念，优缺点，为什么我们要使用它，以及在使用微服务的实践过程中，从开发、测试、部署、运维等几个方面相比以前方式有什么不同；同时，分享一下我们在微服务实践过程中的经验和踩过的那些坑。</p>

<!-- More -->


<p>目录大概如下</p>

<ul>
<li><h3>理论篇</h3>

<ul>
<li><h5>单块架构应用以及挑战</h5></li>
<li><h5>什么是微服务</h5></li>
<li><h5>微服务的核心特征</h5></li>
<li><h5>微服务的优缺点</h5></li>
<li><h5>微服务的适用场景</h5></li>
<li><h5>微服务与SOA</h5></li>
<li><h5>微服务诞生的催化剂</h5></li>
</ul>
</li>
<li><h3>实践篇</h3>

<ul>
<li><h5>麻雀虽小，五脏俱全</h5></li>
<li><h5>实现一个服务</h5></li>
<li><h5>微服务开发模板的重要性</h5></li>
<li><h5>不仅仅是REST</h5></li>
<li><h5>消费者驱动的契约测试</h5></li>
<li><h5>如何划分微服务</h5></li>
<li><h5>微服务的依赖管理</h5></li>
<li><h5>微服务与DevOPS</h5></li>
<li><h5>微服务与监控</h5></li>
</ul>
</li>
<li><h3>案例篇</h3>

<ul>
<li><h5>合同管理系统</h5></li>
<li><h5>市场定价系统</h5></li>
<li><h5>信息搜索系统</h5></li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[解析微服务架构(四)]]></title>
    <link href="http://wldandan.github.com/blog/2015/03/16/wei-fu-wu-jia-gou-she-ji-yu-shi-xian-4-wei-fu-wu-jia-gou-de-you-que-dian/"/>
    <updated>2015-03-16T22:07:00+08:00</updated>
    <id>http://wldandan.github.com/blog/2015/03/16/wei-fu-wu-jia-gou-she-ji-yu-shi-xian-4-wei-fu-wu-jia-gou-de-you-que-dian</id>
    <content type="html"><![CDATA[<p>[请勿转载]</p>

<h1>微服务架构的优缺点</h1>

<p>将单块架构应用分解为一系列相对独立的微服务，其中每个服务都运行在自己的进程中，并且通过轻量级的机制实现彼此间的通信，这通常是HTTP资源的微服务。这些服务是围绕着业务功能构建的，并且可以通过完全自动化的部署机制进行独立部署。这些服务的集中式管理做到了最小化，每一种服务都可以通过不同的编程语言进行编写，并且可以使用不同的数据存储技术。</p>

<!-- More -->


<p>从上面的定义可以看出，微服务的优势是显而易见的：</p>

<ul>
<li>每个服务都很简单，只关注于一个业务功能。</li>
<li>每个微服务可以由不同的团队独立开发。</li>
<li>微服务是松散耦合的。</li>
<li>微服务可以通过不同的编程语言与工具进行开发。</li>
</ul>


<p>这些优势使得微服务看起来是非常完美的解决方案，不过微服务难道就没有缺点么？下面我们就来探讨一下微服务在其实施过程中所遇到的问题和一些缺点。</p>

<h5>运维成本过高</h5>

<h5>DevOps是必须的</h5>

<h5>接口不匹配</h5>

<h5>代码重复</h5>

<h5>分布式系统的复杂性</h5>

<p>总而言之，微服务架构有很多吸引人的地方，不过在拥抱微服务之前，你需要认清它所带来的挑战。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[解析微服务架构(三)]]></title>
    <link href="http://wldandan.github.com/blog/2015/03/16/wei-fu-wu-jia-gou-she-ji-yu-shi-xian-3-wei-fu-wu-jia-gou-de-he-xin-te-zhen/"/>
    <updated>2015-03-16T22:07:00+08:00</updated>
    <id>http://wldandan.github.com/blog/2015/03/16/wei-fu-wu-jia-gou-she-ji-yu-shi-xian-3-wei-fu-wu-jia-gou-de-he-xin-te-zhen</id>
    <content type="html"><![CDATA[<p>[请勿转载]</p>

<h1>微服务架构的核心特征</h1>

<p>   什么是核心特征，就是当我们谈论同一件事情的时候，那些不同的人们所关注的相同的部分。从业界的讨论来看，微服务通
常有如下几个显著特征:</p>

<ul>
<li><h5>服务与组件</h5></li>
</ul>


<p>  一直以来，我们都比较提倡使用组件（Component）的方式，模块化应用系统。它类似生活中的汽车，由不同的零件组成，每个零件都是可以独立替换的。因此，这类通常都有很好的灵活性和替换性。</p>

<p>  在软件领域，我们也将组件定义为应用软件构建中独立的单元，它的最大特点是，对整个应用软件而言，组件能够被容易的替代或者更新。</p>

<p>   传统实现组件的方式是采用和应用程序一样的的编程语言，构建独立的共享库（Libaray），从而达到解耦和复用的效果。对于共享库而言，我们知道它是语言相关、平台相关，并且是和应用程序运行在同一个进程中的，因此，任何共享库的变化都意味着整个应用程序也要被更新，并且需要被重新部署。换句话说，如果应用由多个共享库组件组成，那么任何库的变更都将导致整体应用的重新发布。</p>

<!-- More -->


<p>   其实，微服务也可以作为组件。把微服务当成应用程序中的组件，其中一个最主要的好处是微
服务可以独立部署。如果应用由多个共享库组成，那么其只能跑在一个进程中，那么任何库的变更都将导致整体应用的重新发布。</p>

<p><img src="http://wldandan.github.com/images/microservice-design-and-practice/chapter3/library-as-component-800-600.png" /></p>

<p>但是如果应用程序由多个服务构成，我们可以想像，大部分情况下，每个服务的变更仅需要重新部署相应的服务。当然，这也不是绝对的，比如某些对服务接口的变更就需要其相关服务也发生变化，但微服务架构的目的，是尽量避免这种服务间的耦合并完善服务的交互接口。换句话说，通过服务来实现组件，将应用拆散为一系列的服务，运行在不同的进程中时，任何一个服务的局部变化只需重新部署对应的服务本身。同时，将服务作为组件也可以帮助我们明确的定义出组件的边界，因为服务之间的调用是跨进程的，清晰的边界和职责定义应该是在设计阶段时必须考虑的。</p>

<p><img src="http://wldandan.github.com/images/microservice-design-and-practice/chapter3/service-as-component-800-600.png" /></p>

<p>   把服务当成组件的另外一个优点是在组件和组件之间、或者组件和应用程序之间定义了清晰的、跨语言、跨平台的接口。许
多开发语言虽然定义了良好的公共调用接口的机制，也提供了详尽的文档和规范说明，但由于共享库其本身的特性，充分依赖于特定平台、特定语言，因此组件间的耦合度较高。同共享库相比，微服务是通过语言无关、平台无关的远程接口调用，因此不存在这个问题。当然，使用微服务也有它的不足之处，那就是远程调用比进制内部调用更消耗性能，而且远程的接口由于是分布式调用，无疑增加了维护的复杂度。</p>

<ul>
<li><h5>围绕业务组织团队</h5></li>
</ul>


<p>  在单块应用架构的时代，为了节省成本、快速实现目标，企业或者组织一般都会根
据技能类型的差异化来划分团队。例如用户体验设计师一般都被划分到用户体验设计团队，而懂服务器端的开发人员，一般都被归类为后端业务逻辑开发团队；对于那些精通数据库技能的开发者，一般会在DBA团队中找到他们的身影。实际上，当团队被按照这个策略或者维度划分后，即便是某些简单的需求变更，都有可能导致不同团队之间跨组织、跨团队的协作，耗费很高的跨团队的沟通和协作成本。</p>

<p>  正如<a href="http://en.wikipedia.org/wiki/Conway's_law">康威定律（Conway’s law)</a>提出的，一个组织的设计成果，其
结构往往对应于这个组织中的沟通和组织结构。另外，《敏捷宣言》的一个核心理念是“个体与交互高于过程和工具”。</p>

<p>如果仔细想想，我们发现康威定律从正反两方面支持了这一理念。有些公司受困于垂直、等级化的管理结构，这给工程师们带来了完成工作时不必要的阻力。更多的互联网公司则放手，让团队找到自组织的管理结构。我们既看到“漠视”康威定律所造成的危害，也看到了“拥抱”该定律所带来的好处。</p>

<p><img src="http://wldandan.github.com/images/microservice-design-and-practice/chapter3/build-team-aroud-business-800-600.png" /></p>

<p>   而微服务架构的开发模式不同于传统方式，它倡导围绕应用程序为核心，按业务能力来划分为不同的团队。每个团队都要求能
够对每个服务，将其对应的业务领域的全部功能实现，譬如对于某业务需求的更改，从用户体验界面到业务逻辑实现，再到数据的存储和迁移等。因此团队的组织是跨职能的，会包含实现该业务所需功能的所有技能。近年兴起的全栈工程师正是因为架构和开发模式的转变而出现，当然具备全栈的工程师其实很少，但将不同领域的工程师组织为一个全栈的团队就容易的多。</p>

<ul>
<li><h5>关注产品而不是项目</h5></li>
</ul>


<p>   传统的应用开发大部分都是基于项目模式的。什么是项目模式？就是当项目启动后，企业或者组织会从开发
团队中抽出一部分资源、从测试团队中抽出一部分资源，同时也从其他不同的技能团队中抽出不同的资源，组成一个项目团队，然后设置一个时间期限，让大家完成项目。当项目结束后，所有的资源都会被释放，所有人在项目中的职责结束。</p>

<p><img src="http://wldandan.github.com/images/microservice-design-and-practice/chapter3/team-by-skills-800-600.png" /></p>

<p>   但服务架构倡导的是避免采用这种项目模式，更倾向于让开发团队负责整个产品的生命周期。大家熟知的亚
马逊CTO Werner Vogels，曾经说过一句经典的名言，“You build it, you run it”。即对于开发产品的团队而言，产品就是团队的，也是每个成员的。团队中的每个人都有责任、有义务确保产品的快速发展以及演进。</p>

<ul>
<li><h5>去中心化</h5></li>
</ul>


<p>   在第二章我们提到，传统的单块应用架构，倾向于采用统一的技术平台或方案来解决所有问题。其实，我们
知道，在现实生活中，并不是每个问题都是钉子，也不是每个解决方案都是一个锤子。
问题有其具体性，解决方案也应有其针对性。用最适合的技术方案去解决具体的问题，往往会事半功倍。传统的单块架构系统倾向采用统一的技术平台或方案来解决所有问题，而微服务的架构意味着，可以针对不同的业务特征选择不同的技术方案，有针对性的解决具体的业务问题。</p>

<p>   对于单块架构系统，初始的技术选型严重限制将来采用不同语言或框架的能力。如果想尝试新的编程语言
或者框架，没有完备的功能测试集，很难平滑的完成替换，而且系统规模越大，风险越高。</p>

<p>  而基于微服务架构，使我们更容易在系统上尝试新的技术或解决方案。譬如说，可以先挑选风险最小的服务作为尝试，快速得到
反馈后再决定是否试用于其他服务。这也意味着，即便对一项新技术的尝试失败，也可以抛弃这个方案，并不会对整个产品带来风险。</p>

<ul>
<li><h5>独立业务数据</h5></li>
</ul>


<p>  传统的单块应用架构，倾向于采用统一的数据存储平台来存储所有的数据。随着业务的快速发展，需求的不断变化，一方面，数
据变得越来越复杂，难以管理；另一方面，随着应用系统的业务逻辑不断更新和发展，数据库不仅承担着数据存储的作用，还承担着不同系统之间的集成作用。同时，传统的数据库大多是关系型数据库，存储的数据都是以结构化信息为主，但随着互联网的快速发展，数据的结构并不具有确定性，或者说结构发生变化的频率非常快，因此，对于如何有效维护业务数据，也成了一个难题，相应的维护成本越来越高。</p>

<p>  微服务架构，提倡具有业务属性的独立单元或者服务自身维护其相关的业务数据。这样的话，有几个非常明显的优势：首先具有
业务属性的服务单元能够有权利管理其相关的数据，同时能够随着业务的发展，不断更新业务数据。其次，每个业务单元只关心自己的业务数据，因此可以选择最合适的工具或者产品来存储以及管理数据。譬如可以根据具体业务场景，使用MySQL、PostgreSQL等关系型数据库，也可以使用文档类型的MongoDB、键值类型的Riak等NoSQL数据库。譬如，在一个复杂的电商系统中，产品数据的种类繁多，更新也比较频繁，如果使用类似MongoDB这种文档数据库，能灵活的根据需求动态调整结构。而像当用户访问系统时产生的会话信息，则可以使用Redis等键值系统进行存储；通常来说，报表数据的结构变化不大，而且要求数据的高一致性，因此可以使用熟悉的关系型数据库。</p>

<p><img src="http://wldandan.github.com/images/microservice-design-and-practice/chapter3/polyglot-persistence-800-600.png" /></p>

<ul>
<li><h5>基础设施自动化</h5></li>
</ul>


<p>随着云技术的大规模推广与使用，部署和运维的复杂度在大幅度降低。利用云，我们可以快速的创建系统需要的资源，降低应用的交付周期。同时，由于持续集成、持续交付等实践的深入人心，很多团队都开始在构建软件的过程中，使用持续交付提倡的基础设施自动化技术（更多关于持续交付的知识，请参考《持续交付-发布可靠软件的系统方法》一书）。</p>

<p>这也就意味着，如果微服务架构将应用程序本身分成多个小的服务，每个服务都是一个独立的部署单元。因此，微服务的实践，对持续交付和部署流
水线要求非常高。微服务的粒度越细，就意味着需要部署的业务单元就越多，业务单元越多，就需要更稳定的基础设置自动化机制，能够创建运行环境，安装依赖，部署应用等。</p>

<p><img src="http://wldandan.github.com/images/microservice-design-and-practice/chapter2/loose-decouple-microservice-800-600.png" /></p>

<ul>
<li><h5>演进式架构设计</h5></li>
</ul>


<p>  在过去十年中，敏捷方法论以及其实践已经被越来越多的组织尝试并认可。敏捷方法论正在帮助组织以拥抱变化的心
态，去不断尝试，不断获取反馈，从而以高效的方式构建正确的应用系统。实际上，敏捷并不是一种静止的状态，它是组织一直在拥抱变化，尝试改变、获取反馈的演进式发展的一个动态过程。</p>

<p>  类似的，架构设计也应该是随着业务的发展而不断发展，随着需求的变化而不断变化的。当我们试图构建一个单块应用架构系统
时，我们会面临非常艰难的技术选型。哪种方案才是合理的？那种方案才是最正确的？在传统的单块设计中，企业或者组织通常是希望构建一个大而全、无所不能的平台，但是在技术发展如此之快的今天，单一的技术平台已经无法适应市场的快速变化，组织应该随着业务的发展，随着企业的发展，不断尝试并改进架构设计，真正做到业务驱动架构，架构服务于业务。</p>

<hr />

<h3>总结</h3>

<p>微服务强调的是一种独立测试、独立部署、独立运行的软件架构模式，是一种更灵活、更开放、更松散的演进式架构。通过本章所介绍的微服务的核心特征，帮助我们更清晰、深刻的理解了微服务其概念背后所蕴含的思想。</p>
]]></content>
  </entry>
  
</feed>
