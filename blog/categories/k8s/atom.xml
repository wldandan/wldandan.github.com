<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: K8s | Happy Coding, Happy Life]]></title>
  <link href="http://wldandan.github.com/blog/categories/k8s/atom.xml" rel="self"/>
  <link href="http://wldandan.github.com/"/>
  <updated>2019-03-16T16:28:02+08:00</updated>
  <id>http://wldandan.github.com/</id>
  <author>
    <name><![CDATA[wldandan]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[K8s之Pod]]></title>
    <link href="http://wldandan.github.com/blog/2019/03/16/k8s-concept-pod/"/>
    <updated>2019-03-16T23:45:00+08:00</updated>
    <id>http://wldandan.github.com/blog/2019/03/16/k8s-concept-pod</id>
    <content type="html"><![CDATA[<p>Pod是kubernetes中你可以创建和部署的最小也是最简的单位。Pod代表着集群中运行的进程。Pod中封装着应用的容器（1或多个容器）、存储、独立的网络IP，并管理着容器运行的策略选项。</p>

<!-- More -->


<h3>Pod概览</h3>

<p>Pod是一个服务的多个进程的聚合单位，pod通过提供一个更高级别的抽象的方式，极大简化了应用部署管理。
Pod作为一个独立的部署单位，支持横向扩展和复制、协同调度、命运共同体（例如被同时终结），协同复制，资源共享，依赖管理等，Pod会自动的为容器处理这些问题。</p>

<h4>什么是Pod</h4>

<p>Pod是kubernetes中你可以创建和部署的最小也是最简的单位。Pod代表着集群中运行的进程。</p>

<p>Pod中封装着应用的容器（1或多个容器）、存储、独立的网络IP，并管理着容器运行的策略选项。</p>

<p>在Kubrenetes集群中Pod有如下两种使用方式：</p>

<ul>
<li><p>一个Pod中运行一个容器。“每个Pod中一个容器”的模式是最常见的用法；在这种使用方式中，你可以把Pod想象成是单容器的封装，kuberentes管理的是Pod而不是容器。</p></li>
<li><p>在一个Pod中同时运行多个容器。一个Pod中也可以同时封装几个紧密耦合、互相协作的容器，它们之间共享资源。这些在同一个Pod中的容器互相协作，成为一个service单位——如一个容器共享文件，另一个容器更新文件。Pod将这些容器的存储资源作为一个实体来管理。</p></li>
</ul>


<h4>Pod的生命周期</h4>

<p>Pod 的 status 字段是一个 PodStatus 对象，PodStatus中有一个 phase 字段。</p>

<p>下面是 phase 可能的值：</p>

<ul>
<li>挂起（Pending）：Pod 已被 Kubernetes
系统接受，但有一个或者多个容器镜像尚未创建。等待时间包括调度 Pod的时间和通过网络下载镜像的时间，这可能需要花点时间。</li>
<li>运行中（Running）：该 Pod 已经绑定到了一个节点上，Pod 中所有的容器都已被创建。至少有一个容器正在运行，或者正处于启动或重启状态。</li>
<li>成功（Succeeded）：Pod 中的所有容器都被成功终止，并且不会再重启。</li>
<li>失败（Failed）：Pod 中的所有容器都已终止了，并且至少有一个容器是因为失败终止。也就是说，容器以非0状态退出或者被系统终止。</li>
<li>未知（Unknown）：因为某些原因无法取得 Pod 的状态，通常是因为与 Pod 所在主机通信失败。</li>
</ul>


<p>下图是Pod的生命周期示意图，从图中可以看到Pod状态的变化。</p>

<p><img src="/images/k8s/kubernetes-pod-life-cycle.jpg" /></p>

<h4>Pod如何管理多个容器</h4>

<p>Pod中可以同时运行多个容器（独立进程运行）并协同工作。同一个Pod中的容器会自动的分配到同一个node 上运行，同时，同一个Pod中的容器共享存储、网络和依赖，它们总是被同时调度。</p>

<ul>
<li><p>网络</p>

<blockquote><p>每个Pod都会被分配唯一的一个IP地址。Pod中的所有容器共享网络空间，包括IP地址和端口。Pod内部的容器可以使用localhost互相通信。Pod中的容器与外界通信时，必须分配共享网络资源（例如使用宿主机的端口映射）。</p></blockquote></li>
<li><p>存储</p>

<blockquote><p>可以为一个Pod指定多个共享的Volume。Pod中的所有容器都可以访问共享的volume。Volume也可以用来持久化Pod中的存储资源，以防容器重启后文件丢失。</p></blockquote></li>
</ul>


<h3>Pod的管理</h3>

<h4>Pod间发现</h4>

<p>Pod中应用容器共享网络空间（IP地址和端口），因此可以通过localhost互相发现。
Pod中应用容器的hostname被设置成Pod的名字。
Pod中应用容器可以共享volume。volume能够保证pod重启时使用的数据不丢失。</p>

<h4>Pod的使用</h4>

<p>Pod也可以用于垂直应用（例如LAMP），这样使用的动机是为了支持共同调度和协调应用程序，例如：
* 内容管理系统、文件和数据加载器、本地换群管理器等。
* 日志和检查点备份、压缩、旋转、快照等。
* 数据变更观察者、日志和监控适配器、活动发布者等。
* 代理、桥接和适配器等。
* 控制器、管理器、配置器、更新器等。</p>

<h4>Pod的持久性</h4>

<p>Pod不是作为持久化设计的。在调度失败、节点故障、缺少资源或者节点维护的状态下都会失败。</p>

<p>通常，用户不需要手动直接创建Pod，而是应该使用controller（例如Deployments），即使是在创建单个Pod的情况下。Controller可以提供集群级别的自愈功能、复制和升级管理。</p>

<h3>Pod高级特性</h3>

<h4>Pod Preset</h4>

<p>Kubernetes提供了一个准入控制器（PodPreset），当其启用时，Pod Preset 会将应用创建请求传入到该控制器上。因此，<code>Pod Preset</code>是用来在 Pod 被创建的时候向其中注入额外的运行时需求的 API 资源。</p>

<p>您可以使用<code>label selector</code> 来指定为哪些 Pod 应用 Pod Preset。</p>

<h4>Pod和Controller</h4>

<p>Controller可以创建和管理多个Pod，提供副本管理、滚动升级和集群级别的自愈能力。例如，如果一个Node故障，Controller就能自动将该节点上的Pod调度到其他健康的Node上。</p>

<p>包含一个或者多个Pod的Controller示例：</p>

<ul>
<li>Deployment</li>
<li>StatefulSet</li>
<li>DaemonSet</li>
</ul>


<p>通常，Controller会用你提供的Pod Template来创建相应的Pod。</p>

<h4>Init容器</h4>

<p>Init是一种专用的容器，在应用程序容器启动之前运行，包含应用镜像中工具或环境的安装脚本。</p>

<p>Pod 能够有一个或多个先于应用容器启动的 Init 容器。</p>

<p>Init 容器与普通的容器非常像，除了如下两点：
* Init 容器总是运行到成功完成为止。
* 每个 Init 容器都必须在下一个 Init 容器启动之前成功完成。</p>

<p>如果 Pod 的 Init 容器失败，Kubernetes 会不断地重启该 Pod，直到 Init容器成功为止。然而，如果 Pod 对应的 restartPolicy 为 Never，它不会重新启动。</p>

<p>因为 Init 容器具有与应用程序容器分离的单独镜像，所以它们的启动相关代码具有如下优势：</p>

<ul>
<li><p>它们可以包含并运行实用工具，它们可以包含使用工具和定制化代码来安装。例如，创建镜像没必要FROM 另一个镜像，只需要在安装过程中使用类似 sed、 awk、 python 或 dig 这样的工具。</p></li>
<li><p>应用程序镜像可以分离出创建和部署的角色，而没有必要联合它们构建一个单独的镜像。</p></li>
<li><p>Init 容器使用 Linux Namespace，所以相对应用程序容器来说具有不同的文件系统视图。因此，它们能够具有访问 Secret 的权限，而应用程序容器则不能。</p></li>
<li><p>它们必须在应用程序容器启动之前运行完成，所以 Init 容器能够提供一种简单的阻塞或延迟应用容器的启动的方法，直到满足了一组先决条件。</p></li>
</ul>


<h4>Pod 安全策略</h4>

<p>Pod 安全策略 是集群级别的资源，它能够控制 Pod 运行的行为，以及它具有访问什么资源的能力。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[K8s之网络]]></title>
    <link href="http://wldandan.github.com/blog/2019/03/15/k8s-network/"/>
    <updated>2019-03-15T23:45:00+08:00</updated>
    <id>http://wldandan.github.com/blog/2019/03/15/k8s-network</id>
    <content type="html"><![CDATA[<p>K8s的网络介绍</p>

<!-- More -->


<h3>K8s集群IP</h3>

<p>Kubernetes集群内部存在三类IP，分别是：</p>

<ul>
<li>Node IP：宿主机的IP地址</li>
<li>Pod IP：使用网络插件创建的IP（如flannel），使跨主机的Pod可以互通</li>
<li>Cluster IP：虚拟IP，通过iptables规则访问服务</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[K8s核心概念]]></title>
    <link href="http://wldandan.github.com/blog/2019/03/15/k8s-concepts/"/>
    <updated>2019-03-15T23:45:00+08:00</updated>
    <id>http://wldandan.github.com/blog/2019/03/15/k8s-concepts</id>
    <content type="html"><![CDATA[<p>Paxos发明人Leslie Lamport提出，分布式系统有两类特性：</p>

<ul>
<li><p>安全性(Safety)</p>

<blockquote><p>保证系统的稳定，保证系统不会崩溃，不会出现业务错误，不会做坏事，是严格约束的。</p></blockquote></li>
<li><p>活性(Liveness)</p>

<blockquote><p>使得系统可以提供功能，提高性能，增加易用性，让系统可以在用户“看到的时间内”做些好事，是尽力而为的。</p></blockquote></li>
</ul>


<p>从Kubernetes的系统架构和设计来看，存在两个最核心的设计理念，符合Lamport的理论：</p>

<ul>
<li><p>容错性</p>

<blockquote><p>容错性实际是保证Kubernetes系统稳定性和安全性的基础</p></blockquote></li>
<li><p>易扩展性</p>

<blockquote><p>易扩展性是保证对变更友好，可以快速迭代增加新功能的基础</p></blockquote></li>
</ul>


<!-- More -->


<p>在K8S中，支撑核心设计理念的背后，存在着诸多领域对象，本文主要梳理了K8S系统中存在的主要概念。</p>

<table>
<thead>
<tr>
<th></th>
<th>类别</th>
<th>名称</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>资源对象</td>
<td>Pod、ReplicaSet、ReplicationController、Deployment、StatefulSet、DaemonSet、Job、CronJob、HorizontalPodAutoscaling、Node、Namespace、Service、Ingress、Label、CustomResourceDefinition|</td>
</tr>
<tr>
<td></td>
<td>存储对象</td>
<td>Volume、PersistentVolume、Secret、ConfigMap|</td>
</tr>
<tr>
<td></td>
<td>策略对象</td>
<td>SecurityContext、ResourceQuota、LimitRange|</td>
</tr>
<tr>
<td></td>
<td>身份对象</td>
<td>ServiceAccount、Role、ClusterRole|</td>
</tr>
</tbody>
</table>


<h4>1.核心概念</h4>

<h5>Pod</h5>

<blockquote><p>Pod是在Kubernetes集群中运行部署应用或服务的最小单元，它是可以支持多容器的。Pod的设计理念是支持多个容器在一个Pod中共享网络地址和文件系统，可以通过进程间通信和文件共享这种简单高效的方式组合完成服务。
目前Kubernetes中的业务主要可以分为长期伺服型（long-running）、批处理型（batch）、后台支撑型（node-daemon）和有状态应用型（stateful application）；分别对应的控制器为Deployment、Job、DaemonSet和StatefulSet，</p></blockquote>

<h5>部署（Deployment）</h5>

<blockquote><p>部署表示用户对Kubernetes集群的一次更新操作。部署是一个比RS应用模式更广的API对象，可以是创建一个新的服务，更新一个新的服务，也可以是滚动升级一个服务。滚动升级一个服务，实际是创建一个新的RS，然后逐渐将新RS中副本数增加到理想状态。以Kubernetes的发展方向，未来对所有长期伺服型的的业务的管理，都会通过Deployment来管理。</p></blockquote>

<h5>服务（Service）</h5>

<blockquote><p>RC、RS和Deployment只是保证了支撑服务的微服务Pod的数量，但是没有解决如何访问这些服务的问题。一个Pod只是一个运行服务的实例，随时可能在不同节点上停止或者启动，因此不能确定其IP和端口号提供服务。那谁来稳定地提供<code>服务发现</code>和<code>负载均衡</code>的能力呢？在K8集群中，客户端要访问的服务就是Service对象。
每个Service会对应一个集群内部有效的虚拟IP，集群内部通过虚拟IP访问服务。
在K8集群中微服务的负载均衡是由Kube-proxy实现的。Kube-proxy是Kubernetes集群内部的负载均衡器。它是一个分布式代理服务器，在Kubernetes的每个节点上都有一个。这一设计体现了它的伸缩性优势，需要访问服务的节点越多，提供负载均衡能力的Kube-proxy就越多，高可用节点也随之增多。</p></blockquote>

<h5>节点（Node）</h5>

<blockquote><p>Kubernetes集群中的计算能力由Node提供，最初Node称为服务节点Minion，后来改名为Node。Kubernetes集群中的Node也就等同于Mesos集群中的Slave节点，是所有Pod运行所在的工作主机，可以是物理机也可以是虚拟机。不论是物理机还是虚拟机，工作主机的统一特征是上面要运行kubelet管理节点上运行的容器。</p></blockquote>

<h5>命名空间（Namespace）</h5>

<blockquote><p>命名空间为Kubernetes集群提供虚拟的隔离作用，Kubernetes集群初始有两个命名空间，分别是默认命名空间default和系统命名空间kube-system，除此以外，管理员可以可以创建新的命名空间满足需要。</p></blockquote>

<h5>任务(Job)</h5>

<blockquote><p>Job是Kubernetes用来控制批处理型任务的API对象。批处理业务与长期伺服业务的主要区别是批处理业务的运行有头有尾，而长期伺服业务在用户不停止的情况下永远运行。Job管理的Pod把任务成功完成就自动退出了。成功完成的标志根据不同的spec.completions策略而不同：单Pod型任务有一个Pod成功就标志完成；多任务的成功保证有N个任务全部执行成功；工作队列型任务根据应用确认的全局成功而标志成功。</p></blockquote>

<h4>2.管理与支撑概念</h4>

<h5>API</h5>

<blockquote><p>API对象是Kubernetes集群中的管理操作单元。Kubernetes集群系统每支持一项新功能，引入一项新概念，一定会新引入对应的API对象，支持对该功能的管理操作。例如副本集Replica Set对应的API对象是RS。
每个API对象都有3大类属性：元数据metadata、规范spec和状态status</p></blockquote>

<h5>副本控制器（Replication Controller，RC）</h5>

<blockquote><p>RC是Kubernetes集群中最早的保证Pod高可用的API对象。通过监控运行中的Pod来保证集群中运行指定数目的Pod副本。</p></blockquote>

<h5>副本集（Replica Set，RS)</h5>

<blockquote><p>RS是新一代RC，提供同样的高可用能力，区别主要在于RS后来居上，能支持更多种类的匹配模式。副本集对象一般不单独使用，而是作为Deployment的理想状态参数使用。</p></blockquote>

<h5>后台支撑服务集（DaemonSet）</h5>

<blockquote><p>长期伺服型和批处理型服务的核心在业务应用，可能有些节点运行多个同类业务的Pod，有些节点上又没有这类Pod运行；而后台支撑型服务的核心关注点在Kubernetes集群中的节点（物理机或虚拟机），要保证每个节点上都有一个此类Pod运行。节点可能是所有集群节点也可能是通过nodeSelector选定的一些特定节点。典型的后台支撑型服务包括，存储，日志和监控等在每个节点上支持Kubernetes集群运行的服务。</p></blockquote>

<h5>有状态服务集（StatefulSet）</h5>

<blockquote><p>在云原生应用的体系里，有下面两组近义词；第一组是无状态（stateless）、牲畜（cattle）、无名（nameless）、可丢弃（disposable）；第二组是有状态（stateful）、宠物（pet）、有名（having name）、不可丢弃（non-disposable）
RC和RS主要是控制提供无状态服务的，其所控制的Pod的名字是随机设置的，一个Pod出故障了就被丢弃掉，在另一个地方重启一个新的Pod，名字变了和启动在哪儿都不重要，重要的只是Pod总数；而StatefulSet是用来控制有状态服务，StatefulSet中的每个Pod的名字都是事先确定的，不能更改。
对于RC和RS中的Pod，一般不挂载存储或者挂载共享存储，保存的是所有Pod共享的状态，Pod像牲畜一样没有分别（这似乎也确实意味着失去了人性特征）；对于StatefulSet中的Pod，每个Pod挂载自己独立的存储，如果一个Pod出现故障，从其他节点启动一个同样名字的Pod，要挂载上原来Pod的存储继续以它的状态提供服务。
适合于StatefulSet的业务包括数据库服务MySQL和PostgreSQL，集群化管理服务ZooKeeper、etcd等有状态服务。使用StatefulSet，Pod仍然可以通过漂移到不同节点提供高可用，而存储也可以通过外挂的存储来提供高可靠性，StatefulSet做的只是将确定的Pod与确定的存储关联起来保证状态的连续性。</p></blockquote>

<h5>集群联邦（Federation）</h5>

<blockquote><p>在云计算环境中，服务的作用距离范围从近到远一般可以有：同主机（Host，Node）、跨主机同可用区（Available Zone）、跨可用区同地区（Region）、跨地区同服务商（Cloud Service Provider）、跨云平台。Kubernetes的设计定位是单一集群在同一个地域内，因为同一个地区的网络性能才能满足Kubernetes的调度和计算存储连接要求。而联合集群服务就是为提供跨Region跨服务商Kubernetes集群服务而设计的。
每个Kubernetes Federation有自己的分布式存储、API Server和Controller Manager。用户可以通过Federation的API Server注册该Federation的成员Kubernetes Cluster。当用户通过Federation的API Server创建、更改API对象时，Federation API Server会在自己所有注册的子Kubernetes Cluster都创建一份对应的API对象。在提供业务请求服务时，Kubernetes Federation会先在自己的各个子Cluster之间做负载均衡，而对于发送到某个具体Kubernetes Cluster的业务请求，会依照这个Kubernetes Cluster独立提供服务时一样的调度模式去做Kubernetes Cluster内部的负载均衡。而Cluster之间的负载均衡是通过域名服务的负载均衡来实现的。</p></blockquote>

<h4>3.用户与权限概念</h4>

<h5>用户帐户（User Account）</h5>

<blockquote><p>用户帐户为人提供账户标识，对应的是人的身份，人的身份与服务的namespace无关，所以用户账户是跨namespace的</p></blockquote>

<h5>服务帐户（Service Account）</h5>

<blockquote><p>服务账户为计算机进程和Kubernetes集群中运行的Pod提供账户标识。服务帐户对应的是一个运行中程序的身份，与特定namespace是相关的。</p></blockquote>

<h5>密钥对象（Secret）</h5>

<blockquote><p>Secret是用来保存和传递密码、密钥、认证凭证这些敏感信息的对象。为了避免将类似的敏感信息明文写在配置文件中，可以将其存入一个Secret对象，并在配置文件中通过Secret对象引用这些敏感信息</p></blockquote>

<h5>RBAC访问授权</h5>

<blockquote><p>RBAC主要是引入了角色（Role）以及与角色绑定（RoleBinding）的相关抽象概念。</p></blockquote>

<h3>参考资料</h3>

<p><a href="https://infoq.cn/article/kubernetes-and-cloud-native-applications-part01">《Kubernetes 与云原生应用》系列之 Kubernetes 的系统架构与设计理念</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[K8s核心架构]]></title>
    <link href="http://wldandan.github.com/blog/2019/03/15/k8s-architecture/"/>
    <updated>2019-03-15T23:45:00+08:00</updated>
    <id>http://wldandan.github.com/blog/2019/03/15/k8s-architecture</id>
    <content type="html"><![CDATA[<p>Kubernetes主要由以下几个核心组件组成：</p>

<ul>
<li>etcd保存了整个集群的状态；</li>
<li>apiserver提供了资源操作的唯一入口，并提供认证、授权、访问控制、API注册和发现等机制；</li>
<li>controller manager负责维护集群的状态，比如故障检测、自动扩展、滚动更新等；</li>
<li>scheduler负责资源的调度，按照预定的调度策略将Pod调度到相应的机器上；</li>
<li>kubelet负责维护容器的生命周期，同时也负责Volume（CSI）和网络（CNI）的管理；</li>
<li>Container runtime负责镜像管理以及Pod和容器的真正运行（CRI）；</li>
<li>kube-proxy负责为Service提供cluster内部的服务发现和负载均衡；</li>
</ul>


<!-- More -->


<p>除了核心组件，还有一些推荐的插件，其中有的已经成为CNCF中的托管项目：</p>

<ul>
<li>CoreDNS负责为整个集群提供DNS服务</li>
<li>Ingress Controller为服务提供外网入口</li>
<li>Prometheus提供资源监控</li>
<li>Dashboard提供GUI</li>
<li>Federation提供跨可用区的集群</li>
</ul>


<h3>K8s整体架构</h3>

<p><img src="/images/k8s/kubernetes-whole-arch.png" /></p>

<h5>K8s-Master架构图</h5>

<p><img src="/images/k8s/kubernetes-master-arch.png" /></p>

<h5>K8s-Node架构图</h5>

<p><img src="/images/k8s/kubernetes-node-arch.png" /></p>

<h3>K8s分层架构</h3>

<p><img src="/images/k8s/kubernetes-layers-arch.png" /></p>

<ul>
<li>核心层：Kubernetes最核心的功能，对外提供API构建高层的应用，对内提供插件式应用执行环境</li>
<li>应用层：部署（无状态应用、有状态应用、批处理任务、集群应用等）和路由（服务发现、DNS解析等）、Service Mesh（部分位于应用层）</li>
<li>管理层：系统度量（如基础设施、容器和网络的度量），自动化（如自动扩展、动态Provision等）以及策略管理（RBAC、Quota、PSP、NetworkPolicy等）、Service Mesh（部分位于管理层）</li>
<li>接口层：kubectl命令行工具、客户端SDK以及集群联邦</li>
<li><p>生态系统：在接口层之上的庞大容器集群管理调度的生态系统，可以划分为两个范畴</p>

<ul>
<li><p>Kubernetes外部：日志、监控、配置管理、CI/CD、Workflow、FaaS、OTS应用、ChatOps、GitOps、SecOps等</p></li>
<li><p>Kubernetes内部：CRI、CNI、CSI、镜像仓库、Cloud Provider、集群自身的配置和管理等</p></li>
</ul>
</li>
</ul>


<blockquote><p>关于分层架构，可以关注下Kubernetes社区正在推进的<a href="https://docs.google.com/document/d/1XkjVm4bOeiVkj-Xt1LgoGiqWsBfNozJ51dyI-ljzt1o">Kubernetes architectual roadmap</a>和<a href="https://docs.google.com/presentation/d/1GpELyzXOGEPY0Y1ft26yMNV19ROKt8eMN67vDSSHglk/edit">slide</a>。</p></blockquote>

<h3>参考资料</h3>

<p><a href="http://queue.acm.org/detail.cfm?id=2898444">Borg, Omega, and Kubernetes - Lessons learned from three container-management systems over a decade</a></p>

<p><a href="http://static.googleusercontent.com/media/research.google.com/zh-CN//pubs/archive/43438.pdf">Paper - Large-scale cluster management at Google with Borg</a></p>

<p><a href="http://thenewstack.io/kubernetes-an-overview">KUBERNETES: AN OVERVIEW</a></p>

<p><a href="https://docs.google.com/document/d/1XkjVm4bOeiVkj-Xt1LgoGiqWsBfNozJ51dyI-ljzt1o">Kubernetes architectual roadmap</a>和<a href="https://docs.google.com/presentation/d/1GpELyzXOGEPY0Y1ft26yMNV19ROKt8eMN67vDSSHglk/edit">slide</a></p>
]]></content>
  </entry>
  
</feed>
